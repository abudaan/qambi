(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

var _qambi = require('../../src/qambi');

var _qambi2 = _interopRequireDefault(_qambi);

var _isomorphicFetch = require('isomorphic-fetch');

var _isomorphicFetch2 = _interopRequireDefault(_isomorphicFetch);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

document.addEventListener('DOMContentLoaded', function () {

  var song = void 0;

  _qambi2.default.init().then(function () {

    var test = 2;

    if (test === 1) {

      //console.time('song')
      (0, _isomorphicFetch2.default)('../../data/mozk545a.mid').then(function (response) {
        return response.arrayBuffer();
      }).then(function (data) {
        song = _qambi.Song.fromMIDIFile(data);
        initUI();
        //console.timeEnd('song')
      });
    } else if (test === 2) {

        //console.time('song')
        _qambi.Song.fromMIDIFileAsync('../../data/minute_waltz.mid').then(function (s) {
          song = s;
          //console.timeEnd('song')
          initUI();
        }, function (e) {
          return console.log(e);
        });
      }
  });

  function initUI() {

    var btnPlay = document.getElementById('play');
    var btnPause = document.getElementById('pause');
    var btnStop = document.getElementById('stop');
    var divTempo = document.getElementById('tempo');
    var divPosition = document.getElementById('position');
    var divPositionTime = document.getElementById('position_time');
    var rangePosition = document.getElementById('playhead');
    var userInteraction = false;

    btnPlay.disabled = false;
    btnPause.disabled = false;
    btnStop.disabled = false;

    btnPlay.addEventListener('click', function () {
      //song.play('barsbeats', 4, 1, 1, 0)
      //song.play('time', 0, 0, 15) // play from 15 seconds
      //song.play('millis', 34000) // play from 34 seconds
      song.play();
    });

    btnPause.addEventListener('click', function () {
      song.pause();
    });

    btnStop.addEventListener('click', function () {
      song.stop();
    });

    // song.addEventListener(qambi.TEMPO, event => {
    //   divTempo.innerHTML = `tempo: ${event.bpm} bpm`
    // })

    song.addEventListener('noteOn', function (event) {
      var note = event.data;
      //console.log('noteOn', note.id, note.noteOn.id, note.noteOn.data1, note.noteOn.ticks)
    });

    song.addEventListener('noteOff', function (event) {
      var note = event.data;
      //console.log('noteOff', note.id, note.noteOff.id, note.noteOff.data1, note.noteOff.ticks)
    });

    song.addEventListener('play', function (event) {
      console.log('started playing at position:', event.data);
    });

    song.addEventListener('stop', function () {
      console.log('stop');
      rangePosition.value = 0;
    });

    song.addEventListener('pause', function (event) {
      console.log('paused:', event.data);
    });

    var position = song.getPosition();
    divPosition.innerHTML = position.barsAsString;
    divPositionTime.innerHTML = position.timeAsString;
    divTempo.innerHTML = 'tempo: ' + position.bpm + ' bpm';

    song.addEventListener('position', function (event) {
      divPosition.innerHTML = event.data.barsAsString;
      divPositionTime.innerHTML = event.data.timeAsString;
      divTempo.innerHTML = 'tempo: ' + event.data.bpm + ' bpm';
      if (!userInteraction) {
        rangePosition.value = event.data.percentage;
      }
    });

    rangePosition.addEventListener('mouseup', function (e) {
      rangePosition.removeEventListener('mousemove', rangeListener);
      userInteraction = false;
    });

    rangePosition.addEventListener('mousedown', function (e) {
      setTimeout(function () {
        song.setPosition('percentage', e.target.valueAsNumber);
      }, 0);
      rangePosition.addEventListener('mousemove', rangeListener);
      userInteraction = true;
    });

    var rangeListener = function rangeListener(e) {
      song.setPosition('percentage', e.target.valueAsNumber);
    };
  }
});

},{"../../src/qambi":20,"isomorphic-fetch":2}],2:[function(require,module,exports){
// the whatwg-fetch polyfill installs the fetch() function
// on the global object (window or self)
//
// Return that as the export for use in Webpack, Browserify etc.
require('whatwg-fetch');
module.exports = self.fetch.bind(self);

},{"whatwg-fetch":3}],3:[function(require,module,exports){
(function(self) {
  'use strict';

  if (self.fetch) {
    return
  }

  function normalizeName(name) {
    if (typeof name !== 'string') {
      name = String(name)
    }
    if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
      throw new TypeError('Invalid character in header field name')
    }
    return name.toLowerCase()
  }

  function normalizeValue(value) {
    if (typeof value !== 'string') {
      value = String(value)
    }
    return value
  }

  function Headers(headers) {
    this.map = {}

    if (headers instanceof Headers) {
      headers.forEach(function(value, name) {
        this.append(name, value)
      }, this)

    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach(function(name) {
        this.append(name, headers[name])
      }, this)
    }
  }

  Headers.prototype.append = function(name, value) {
    name = normalizeName(name)
    value = normalizeValue(value)
    var list = this.map[name]
    if (!list) {
      list = []
      this.map[name] = list
    }
    list.push(value)
  }

  Headers.prototype['delete'] = function(name) {
    delete this.map[normalizeName(name)]
  }

  Headers.prototype.get = function(name) {
    var values = this.map[normalizeName(name)]
    return values ? values[0] : null
  }

  Headers.prototype.getAll = function(name) {
    return this.map[normalizeName(name)] || []
  }

  Headers.prototype.has = function(name) {
    return this.map.hasOwnProperty(normalizeName(name))
  }

  Headers.prototype.set = function(name, value) {
    this.map[normalizeName(name)] = [normalizeValue(value)]
  }

  Headers.prototype.forEach = function(callback, thisArg) {
    Object.getOwnPropertyNames(this.map).forEach(function(name) {
      this.map[name].forEach(function(value) {
        callback.call(thisArg, value, name, this)
      }, this)
    }, this)
  }

  function consumed(body) {
    if (body.bodyUsed) {
      return Promise.reject(new TypeError('Already read'))
    }
    body.bodyUsed = true
  }

  function fileReaderReady(reader) {
    return new Promise(function(resolve, reject) {
      reader.onload = function() {
        resolve(reader.result)
      }
      reader.onerror = function() {
        reject(reader.error)
      }
    })
  }

  function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader()
    reader.readAsArrayBuffer(blob)
    return fileReaderReady(reader)
  }

  function readBlobAsText(blob) {
    var reader = new FileReader()
    reader.readAsText(blob)
    return fileReaderReady(reader)
  }

  var support = {
    blob: 'FileReader' in self && 'Blob' in self && (function() {
      try {
        new Blob();
        return true
      } catch(e) {
        return false
      }
    })(),
    formData: 'FormData' in self,
    arrayBuffer: 'ArrayBuffer' in self
  }

  function Body() {
    this.bodyUsed = false


    this._initBody = function(body) {
      this._bodyInit = body
      if (typeof body === 'string') {
        this._bodyText = body
      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
        this._bodyBlob = body
      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
        this._bodyFormData = body
      } else if (!body) {
        this._bodyText = ''
      } else if (support.arrayBuffer && ArrayBuffer.prototype.isPrototypeOf(body)) {
        // Only support ArrayBuffers for POST method.
        // Receiving ArrayBuffers happens via Blobs, instead.
      } else {
        throw new Error('unsupported BodyInit type')
      }

      if (!this.headers.get('content-type')) {
        if (typeof body === 'string') {
          this.headers.set('content-type', 'text/plain;charset=UTF-8')
        } else if (this._bodyBlob && this._bodyBlob.type) {
          this.headers.set('content-type', this._bodyBlob.type)
        }
      }
    }

    if (support.blob) {
      this.blob = function() {
        var rejected = consumed(this)
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return Promise.resolve(this._bodyBlob)
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as blob')
        } else {
          return Promise.resolve(new Blob([this._bodyText]))
        }
      }

      this.arrayBuffer = function() {
        return this.blob().then(readBlobAsArrayBuffer)
      }

      this.text = function() {
        var rejected = consumed(this)
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return readBlobAsText(this._bodyBlob)
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as text')
        } else {
          return Promise.resolve(this._bodyText)
        }
      }
    } else {
      this.text = function() {
        var rejected = consumed(this)
        return rejected ? rejected : Promise.resolve(this._bodyText)
      }
    }

    if (support.formData) {
      this.formData = function() {
        return this.text().then(decode)
      }
    }

    this.json = function() {
      return this.text().then(JSON.parse)
    }

    return this
  }

  // HTTP methods whose capitalization should be normalized
  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']

  function normalizeMethod(method) {
    var upcased = method.toUpperCase()
    return (methods.indexOf(upcased) > -1) ? upcased : method
  }

  function Request(input, options) {
    options = options || {}
    var body = options.body
    if (Request.prototype.isPrototypeOf(input)) {
      if (input.bodyUsed) {
        throw new TypeError('Already read')
      }
      this.url = input.url
      this.credentials = input.credentials
      if (!options.headers) {
        this.headers = new Headers(input.headers)
      }
      this.method = input.method
      this.mode = input.mode
      if (!body) {
        body = input._bodyInit
        input.bodyUsed = true
      }
    } else {
      this.url = input
    }

    this.credentials = options.credentials || this.credentials || 'omit'
    if (options.headers || !this.headers) {
      this.headers = new Headers(options.headers)
    }
    this.method = normalizeMethod(options.method || this.method || 'GET')
    this.mode = options.mode || this.mode || null
    this.referrer = null

    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
      throw new TypeError('Body not allowed for GET or HEAD requests')
    }
    this._initBody(body)
  }

  Request.prototype.clone = function() {
    return new Request(this)
  }

  function decode(body) {
    var form = new FormData()
    body.trim().split('&').forEach(function(bytes) {
      if (bytes) {
        var split = bytes.split('=')
        var name = split.shift().replace(/\+/g, ' ')
        var value = split.join('=').replace(/\+/g, ' ')
        form.append(decodeURIComponent(name), decodeURIComponent(value))
      }
    })
    return form
  }

  function headers(xhr) {
    var head = new Headers()
    var pairs = xhr.getAllResponseHeaders().trim().split('\n')
    pairs.forEach(function(header) {
      var split = header.trim().split(':')
      var key = split.shift().trim()
      var value = split.join(':').trim()
      head.append(key, value)
    })
    return head
  }

  Body.call(Request.prototype)

  function Response(bodyInit, options) {
    if (!options) {
      options = {}
    }

    this.type = 'default'
    this.status = options.status
    this.ok = this.status >= 200 && this.status < 300
    this.statusText = options.statusText
    this.headers = options.headers instanceof Headers ? options.headers : new Headers(options.headers)
    this.url = options.url || ''
    this._initBody(bodyInit)
  }

  Body.call(Response.prototype)

  Response.prototype.clone = function() {
    return new Response(this._bodyInit, {
      status: this.status,
      statusText: this.statusText,
      headers: new Headers(this.headers),
      url: this.url
    })
  }

  Response.error = function() {
    var response = new Response(null, {status: 0, statusText: ''})
    response.type = 'error'
    return response
  }

  var redirectStatuses = [301, 302, 303, 307, 308]

  Response.redirect = function(url, status) {
    if (redirectStatuses.indexOf(status) === -1) {
      throw new RangeError('Invalid status code')
    }

    return new Response(null, {status: status, headers: {location: url}})
  }

  self.Headers = Headers;
  self.Request = Request;
  self.Response = Response;

  self.fetch = function(input, init) {
    return new Promise(function(resolve, reject) {
      var request
      if (Request.prototype.isPrototypeOf(input) && !init) {
        request = input
      } else {
        request = new Request(input, init)
      }

      var xhr = new XMLHttpRequest()

      function responseURL() {
        if ('responseURL' in xhr) {
          return xhr.responseURL
        }

        // Avoid security warnings on getResponseHeader when not allowed by CORS
        if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {
          return xhr.getResponseHeader('X-Request-URL')
        }

        return;
      }

      xhr.onload = function() {
        var status = (xhr.status === 1223) ? 204 : xhr.status
        if (status < 100 || status > 599) {
          reject(new TypeError('Network request failed'))
          return
        }
        var options = {
          status: status,
          statusText: xhr.statusText,
          headers: headers(xhr),
          url: responseURL()
        }
        var body = 'response' in xhr ? xhr.response : xhr.responseText;
        resolve(new Response(body, options))
      }

      xhr.onerror = function() {
        reject(new TypeError('Network request failed'))
      }

      xhr.open(request.method, request.url, true)

      if (request.credentials === 'include') {
        xhr.withCredentials = true
      }

      if ('responseType' in xhr && support.blob) {
        xhr.responseType = 'blob'
      }

      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value)
      })

      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)
    })
  }
  self.fetch.polyfill = true
})(typeof self !== 'undefined' ? self : this);

},{}],4:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.dispatchEvent = dispatchEvent;
exports.addEventListener = addEventListener;
exports.removeEventListener = removeEventListener;
var eventListeners = new Map();

function dispatchEvent(event) {
  //console.log(event.type)
  var map = void 0;

  if (event.type === 'event') {
    var midiEvent = event.data;
    var midiEventType = midiEvent.type;
    //console.log(midiEventType)
    if (eventListeners.has(midiEventType)) {
      map = eventListeners.get(midiEventType);
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = map.values()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var cb = _step.value;

          cb(midiEvent);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }

  if (eventListeners.has(event.type) === false) {
    return;
  }

  map = eventListeners.get(event.type);
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = map.values()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var _cb = _step2.value;

      _cb(event);
    }

    // @todo: run filters here, for instance if an eventlistener has been added to all NOTE_ON events, check the type of the incoming event
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }
}

function addEventListener(type, callback) {

  var map = void 0;
  var id = type + '_' + new Date().getTime();

  if (eventListeners.has(type) === false) {
    map = new Map();
    eventListeners.set(type, map);
  } else {
    map = eventListeners.get(type);
  }

  map.set(id, callback);
  //console.log(eventListeners)
  return id;
}

function removeEventListener(type, id) {

  if (eventListeners.has(type) === false) {
    console.log('no eventlisteners of type' + type);
    return;
  }

  var map = eventListeners.get(type);

  if (typeof id === 'function') {
    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
      for (var _iterator3 = map.entries()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
        var _step3$value = _slicedToArray(_step3.value, 2);

        var key = _step3$value[0];
        var value = _step3$value[1];

        console.log(key, value);
        if (value === id) {
          console.log(key);
          id = key;
          break;
        }
      }
    } catch (err) {
      _didIteratorError3 = true;
      _iteratorError3 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion3 && _iterator3.return) {
          _iterator3.return();
        }
      } finally {
        if (_didIteratorError3) {
          throw _iteratorError3;
        }
      }
    }

    if (typeof id === 'string') {
      map.delete(id);
    }
  } else if (typeof id === 'string') {
    map.delete(id);
  } else {
    console.log('could not remove eventlistener');
  }
}

},{}],5:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.status = status;
exports.json = json;
exports.arrayBuffer = arrayBuffer;
// fetch helpers

function status(response) {
  if (response.status >= 200 && response.status < 300) {
    return Promise.resolve(response);
  }
  return Promise.reject(new Error(response.statusText));
}

function json(response) {
  return response.json();
}

function arrayBuffer(response) {
  return response.arrayBuffer();
}

},{}],6:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Blob = exports.requestAnimationFrame = exports.getUserMedia = undefined;
exports.init = init;

var _init_audio = require('./init_audio');

var _init_midi = require('./init_midi');

var getUserMedia = exports.getUserMedia = function () {
  if (typeof navigator !== 'undefined') {
    return navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;
  }
  return function () {
    console.warn('getUserMedia is not available');
  };
}();

var requestAnimationFrame = exports.requestAnimationFrame = function () {
  if (typeof navigator !== 'undefined') {
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
  }
  return function () {
    console.warn('requestAnimationFrame is not available');
  };
}();

var Blob = exports.Blob = function () {
  if (typeof navigator !== 'undefined') {
    return window.Blob || window.webkitBlob;
  }
  return function () {
    console.warn('Blob is not available');
  };
}();

function init() {
  var settings = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];


  // load settings.instruments (array or object)
  // load settings.midifiles (array or object)
  /*
     qambi.init({
      instruments: ['../instruments/piano', '../instruments/violin'],
      midifiles: ['../midi/mozart.mid']
    })
    .then((loaded) => {
      let [piano, violin] = loaded.instruments
      let [mozart] = loaded.midifiles
    })
   */

  return new Promise(function (resolve, reject) {

    Promise.all([(0, _init_audio.initAudio)(), (0, _init_midi.initMIDI)()]).then(function (data) {
      // parseAudio
      var dataAudio = data[0];

      // parseMIDI
      var dataMidi = data[1];

      resolve({
        legacy: dataAudio.legacy,
        mp3: dataAudio.mp3,
        ogg: dataAudio.ogg,
        midi: dataMidi.midi,
        webmidi: dataMidi.webmidi
      });
    }, function (error) {
      reject(error);
    });
  });
}

},{"./init_audio":7,"./init_midi":8}],7:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.configureMasterCompressor = exports.enableMasterCompressor = exports.getCompressionReduction = exports.getMasterVolume = exports.setMasterVolume = exports.masterCompressor = exports.masterGain = exports.context = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; }; /*
                                                                                                                                                                                                                                                    Sets up the basic audio routing, tests which audio formats are supported and parses the samples for the metronome ticks.
                                                                                                                                                                                                                                                  */

exports.initAudio = initAudio;

var _samples = require('./samples');

var _samples2 = _interopRequireDefault(_samples);

var _parse_audio = require('./parse_audio');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var masterGain = void 0,
    compressor = void 0,
    initialized = false;

var context = exports.context = function () {
  console.log('init AudioContext');
  var ctx = void 0;
  if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object') {
    var AudioContext = window.AudioContext || window.webkitAudioContext;
    if (AudioContext !== 'undefined') {
      ctx = new AudioContext();
    }
  }
  if (typeof ctx === 'undefined') {
    //@TODO: create dummy AudioContext for use in node, see: https://www.npmjs.com/package/audio-context
    exports.context = context = {
      createGain: function createGain() {
        return {
          gain: 1
        };
      },
      createOscillator: function createOscillator() {}
    };
  }
  return ctx;
}();

function initAudio() {

  if (typeof context.createGainNode === 'undefined') {
    context.createGainNode = context.createGain;
  }
  // check for older implementations of WebAudio
  var data = {};
  var source = context.createBufferSource();
  data.legacy = false;
  if (typeof source.start === 'undefined') {
    data.legacy = true;
  }

  // set up the elementary audio nodes
  exports.masterCompressor = compressor = context.createDynamicsCompressor();
  compressor.connect(context.destination);
  exports.masterGain = masterGain = context.createGainNode();
  masterGain.connect(context.destination);
  masterGain.gain.value = 0.5;
  initialized = true;

  return new Promise(function (resolve, reject) {

    (0, _parse_audio.parseSamples)(_samples2.default).then(function onFulfilled(buffers) {
      //console.log(buffers)
      data.ogg = typeof buffers.emptyOgg !== 'undefined';
      data.mp3 = typeof buffers.emptyMp3 !== 'undefined';
      data.lowtick = buffers.lowtick;
      data.hightick = buffers.hightick;
      if (data.ogg === false && data.mp3 === false) {
        reject('No support for ogg nor mp3!');
      } else {
        resolve(data);
      }
    }, function onRejected() {
      reject('Something went wrong while initializing Audio');
    });
  });
}

var _setMasterVolume = function setMasterVolume() {
  var value = arguments.length <= 0 || arguments[0] === undefined ? 0.5 : arguments[0];

  if (initialized === false) {
    console.warn('please call qambi.init() first');
  } else {
    exports.setMasterVolume = _setMasterVolume = function setMasterVolume() {
      var value = arguments.length <= 0 || arguments[0] === undefined ? 0.5 : arguments[0];

      if (value > 1) {
        console.info('maximal volume is 1.0, volume is set to 1.0');
      }
      value = value < 0 ? 0 : value > 1 ? 1 : value;
      masterGain.gain.value = value;
    };
    _setMasterVolume(value);
  }
};

var _getMasterVolume = function getMasterVolume() {
  if (initialized === false) {
    console.warn('please call qambi.init() first');
  } else {
    exports.getMasterVolume = _getMasterVolume = function getMasterVolume() {
      return masterGain.gain.value;
    };
    return _getMasterVolume();
  }
};

var _getCompressionReduction = function getCompressionReduction() {
  if (initialized === false) {
    console.warn('please call qambi.init() first');
  } else {
    exports.getCompressionReduction = _getCompressionReduction = function getCompressionReduction() {
      return compressor.reduction.value;
    };
    return _getCompressionReduction();
  }
};

var _enableMasterCompressor = function enableMasterCompressor() {
  if (initialized === false) {
    console.warn('please call qambi.init() first');
  } else {
    exports.enableMasterCompressor = _enableMasterCompressor = function enableMasterCompressor(flag) {
      if (flag) {
        masterGain.disconnect(0);
        masterGain.connect(compressor);
        compressor.disconnect(0);
        compressor.connect(context.destination);
      } else {
        compressor.disconnect(0);
        masterGain.disconnect(0);
        masterGain.connect(context.destination);
      }
    };
    _enableMasterCompressor();
  }
};

var _configureMasterCompressor = function configureMasterCompressor(cfg) {
  /*
    readonly attribute AudioParam attack; // in Seconds
    readonly attribute AudioParam knee; // in Decibels
    readonly attribute AudioParam ratio; // unit-less
    readonly attribute AudioParam reduction; // in Decibels
    readonly attribute AudioParam release; // in Seconds
    readonly attribute AudioParam threshold; // in Decibels
     @see: http://webaudio.github.io/web-audio-api/#the-dynamicscompressornode-interface
  */
  if (initialized === false) {
    console.warn('please call qambi.init() first');
  } else {
    exports.configureMasterCompressor = _configureMasterCompressor = function configureMasterCompressor(cfg) {
      var _cfg$attack = cfg.attack;
      compressor.attack = _cfg$attack === undefined ? 0.003 : _cfg$attack;
      var _cfg$knee = cfg.knee;
      compressor.knee = _cfg$knee === undefined ? 30 : _cfg$knee;
      var _cfg$ratio = cfg.ratio;
      compressor.ratio = _cfg$ratio === undefined ? 12 : _cfg$ratio;
      var _cfg$reduction = cfg.reduction;
      compressor.reduction = _cfg$reduction === undefined ? 0 : _cfg$reduction;
      var _cfg$release = cfg.release;
      compressor.release = _cfg$release === undefined ? 0.250 : _cfg$release;
      var _cfg$threshold = cfg.threshold;
      compressor.threshold = _cfg$threshold === undefined ? -24 : _cfg$threshold;
    };
    _configureMasterCompressor(cfg);
  }
};

exports.masterGain = masterGain;
exports.masterCompressor = compressor;
exports.setMasterVolume = _setMasterVolume;
exports.getMasterVolume = _getMasterVolume;
exports.getCompressionReduction = _getCompressionReduction;
exports.enableMasterCompressor = _enableMasterCompressor;
exports.configureMasterCompressor = _configureMasterCompressor;

},{"./parse_audio":15,"./samples":22}],8:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getMIDIInputById = exports.getMIDIOutputById = exports.getMIDIInputIds = exports.getMIDIOutputIds = exports.getMIDIInputs = exports.getMIDIOutputs = exports.getMIDIAccess = undefined;
exports.initMIDI = initMIDI;

var _util = require('./util');

var MIDIAccess = void 0; /*
                           Requests MIDI access, queries all inputs and outputs and stores them in alphabetical order
                         */

var initialized = false;
var inputs = [];
var outputs = [];
var inputIds = [];
var outputIds = [];
var inputsById = new Map();
var outputsById = new Map();

var songMidiEventListener = void 0;
var midiEventListenerId = 0;

function getMIDIports() {
  inputs = Array.from(MIDIAccess.inputs.values());

  //sort ports by name ascending
  inputs.sort(function (a, b) {
    return a.name.toLowerCase() <= b.name.toLowerCase() ? 1 : -1;
  });

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = inputs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var port = _step.value;

      inputsById.set(port.id, port);
      inputIds.push(port.id);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  outputs = Array.from(MIDIAccess.outputs.values());

  //sort ports by name ascending
  outputs.sort(function (a, b) {
    return a.name.toLowerCase() <= b.name.toLowerCase() ? 1 : -1;
  });

  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = outputs[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var _port = _step2.value;

      outputsById.set(_port.id, _port);
      outputIds.push(_port.id);
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }
}

function initMIDI() {

  return new Promise(function executor(resolve, reject) {

    if (typeof navigator === 'undefined') {
      initialized = true;
      resolve({ midi: false });
    } else if (typeof navigator.requestMIDIAccess !== 'undefined') {
      (function () {

        var jazz = void 0,
            midi = void 0,
            webmidi = void 0;

        navigator.requestMIDIAccess().then(function onFulFilled(midiAccess) {
          MIDIAccess = midiAccess;
          if (typeof midiAccess._jazzInstances !== 'undefined') {
            jazz = midiAccess._jazzInstances[0]._Jazz.version;
            midi = true;
          } else {
            webmidi = true;
            midi = true;
          }

          getMIDIports();

          // onconnect and ondisconnect are not yet implemented in Chrome and Chromium
          midiAccess.onconnect = function (e) {
            console.log('device connected', e);
            getMIDIports();
          };

          midiAccess.ondisconnect = function (e) {
            console.log('device disconnected', e);
            getMIDIports();
          };

          initialized = true;
          resolve({
            jazz: jazz,
            midi: midi,
            webmidi: webmidi,
            inputs: inputs,
            outputs: outputs,
            inputsById: inputsById,
            outputsById: outputsById
          });
        }, function onReject(e) {
          //console.log(e)
          reject('Something went wrong while requesting MIDIAccess', e);
        });
        // browsers without WebMIDI API
      })();
    } else {
        initialized = true;
        resolve({ midi: false });
      }
  });
}

var _getMIDIAccess = function getMIDIAccess() {
  if (initialized === false) {
    console.warn('please call qambi.init() first');
  } else {
    exports.getMIDIAccess = _getMIDIAccess = function getMIDIAccess() {
      return MIDIAccess;
    };
    return _getMIDIAccess();
  }
  return false;
};

exports.getMIDIAccess = _getMIDIAccess;
var _getMIDIOutputs = function getMIDIOutputs() {
  if (initialized === false) {
    console.warn('please call qambi.init() first');
  } else {
    exports.getMIDIOutputs = _getMIDIOutputs = function getMIDIOutputs() {
      return outputs;
    };
    return _getMIDIOutputs();
  }
  return false;
};

exports.getMIDIOutputs = _getMIDIOutputs;
var _getMIDIInputs = function getMIDIInputs() {
  if (initialized === false) {
    console.warn('please call qambi.init() first');
  } else {
    exports.getMIDIInputs = _getMIDIInputs = function getMIDIInputs() {
      return inputs;
    };
    return _getMIDIInputs();
  }
  return false;
};

exports.getMIDIInputs = _getMIDIInputs;
var _getMIDIOutputIds = function getMIDIOutputIds() {
  if (initialized === false) {
    console.warn('please call qambi.init() first');
  } else {
    exports.getMIDIOutputIds = _getMIDIOutputIds = function getMIDIOutputIds() {
      return outputIds;
    };
    return _getMIDIOutputIds();
  }
  return false;
};

exports.getMIDIOutputIds = _getMIDIOutputIds;
var _getMIDIInputIds = function getMIDIInputIds() {
  if (initialized === false) {
    console.warn('please call qambi.init() first');
  } else {
    exports.getMIDIInputIds = _getMIDIInputIds = function getMIDIInputIds() {
      return inputIds;
    };
    return _getMIDIInputIds();
  }
  return false;
};

exports.getMIDIInputIds = _getMIDIInputIds;
var _getMIDIOutputById = function getMIDIOutputById(id) {
  if (initialized === false) {
    console.warn('please call qambi.init() first');
  } else {
    exports.getMIDIOutputById = _getMIDIOutputById = function getMIDIOutputById() {
      return outputsById.get(id);
    };
    return _getMIDIOutputById(id);
  }
  return false;
};

exports.getMIDIOutputById = _getMIDIOutputById;
var _getMIDIInputById = function getMIDIInputById(id) {
  if (initialized === false) {
    console.warn('please call qambi.init() first');
  } else {
    exports.getMIDIInputById = _getMIDIInputById = function getMIDIInputById() {
      return outputsById.get(id);
    };
    return _getMIDIInputById(id);
  }
  return false;
};

/*
export function initMidiSong(song){

  songMidiEventListener = function(e){
    //console.log(e)
    handleMidiMessageSong(song, e, this);
  };

  // by default a song listens to all available midi-in ports
  inputs.forEach(function(port){
    port.addEventListener('midimessage', songMidiEventListener);
    song.midiInputs.set(port.id, port);
  });

  outputs.forEach(function(port){
    song.midiOutputs.set(port.id, port);
  });
}


export function setMidiInputSong(song, id, flag){
  let input = inputs.get(id);

  if(input === undefined){
    warn('no midi input with id', id, 'found');
    return;
  }

  if(flag === false){
    song.midiInputs.delete(id);
    input.removeEventListener('midimessage', songMidiEventListener);
  }else{
    song.midiInputs.set(id, input);
    input.addEventListener('midimessage', songMidiEventListener);
  }

  let tracks = song.tracks;
  for(let track of tracks){
    track.setMidiInput(id, flag);
  }
}



export function setMidiOutputSong(song, id, flag){
  let output = outputs.get(id);

  if(output === undefined){
    warn('no midi output with id', id, 'found');
    return;
  }

  if(flag === false){
    song.midiOutputs.delete(id);
    let time = song.scheduler.lastEventTime + 100;
    output.send([0xB0, 0x7B, 0x00], time); // stop all notes
    output.send([0xB0, 0x79, 0x00], time); // reset all controllers
  }else{
    song.midiOutputs.set(id, output);
  }

  let tracks = song.tracks;
  for(let track of tracks){
    track.setMidiOutput(id, flag);
  }
}



function handleMidiMessageSong(song, midiMessageEvent, input){
  let midiEvent = new MidiEvent(song.ticks, ...midiMessageEvent.data);

  //console.log(midiMessageEvent.data);

  let tracks = song.tracks;
  for(let track of tracks){
    //console.log(track.midiInputs, input);


    //if(midiEvent.channel === track.channel || track.channel === 0 || track.channel === 'any'){
    //  handleMidiMessageTrack(midiEvent, track);
    //}


    // like in Cubase, midi events from all devices, sent on any midi channel are forwarded to all tracks
    // set track.monitor to false if you don't want to receive midi events on a certain track
    // note that track.monitor is by default set to false and that track.monitor is automatically set to true
    // if you are recording on that track
    //console.log(track.monitor, track.id, input.id);
    if(track.monitor === true && track.midiInputs.get(input.id) !== undefined){
      handleMidiMessageTrack(midiEvent, track, input);
    }
  }

  let listeners = song.midiEventListeners.get(midiEvent.type);
  if(listeners !== undefined){
    for(let listener of listeners){
      listener(midiEvent, input);
    }
  }
}


function handleMidiMessageTrack(track, midiEvent, input){
  let song = track.song,
    note, listeners, channel;
    //data = midiMessageEvent.data,
    //midiEvent = createMidiEvent(song.ticks, data[0], data[1], data[2]);

  //midiEvent.source = midiMessageEvent.srcElement.name;
  //console.log(midiMessageEvent)
  //console.log('---->', midiEvent.type);

  // add the exact time of this event so we can calculate its ticks position
  midiEvent.recordMillis = context.currentTime * 1000; // millis
  midiEvent.state = 'recorded';

  if(midiEvent.type === 144){
    note = createMidiNote(midiEvent);
    track.recordingNotes[midiEvent.data1] = note;
    //track.song.recordingNotes[note.id] = note;
  }else if(midiEvent.type === 128){
    note = track.recordingNotes[midiEvent.data1];
    // check if the note exists: if the user plays notes on her keyboard before the midi system has
    // been fully initialized, it can happen that the first incoming midi event is a NOTE OFF event
    if(note === undefined){
      return;
    }
    note.addNoteOff(midiEvent);
    delete track.recordingNotes[midiEvent.data1];
    //delete track.song.recordingNotes[note.id];
  }

  //console.log(song.preroll, song.recording, track.recordEnabled);

  if((song.prerolling || song.recording) && track.recordEnabled === 'midi'){
    if(midiEvent.type === 144){
      track.song.recordedNotes.push(note);
    }
    track.recordPart.addEvent(midiEvent);
    // song.recordedEvents is used in the key editor
    track.song.recordedEvents.push(midiEvent);
  }else if(track.enableRetrospectiveRecording){
    track.retrospectiveRecording.push(midiEvent);
  }

  // call all midi event listeners
  listeners = track.midiEventListeners[midiEvent.type];
  if(listeners !== undefined){
    objectForEach(listeners, function(listener){
      listener(midiEvent, input);
    });
  }

  channel = track.channel;
  if(channel === 'any' || channel === undefined || isNaN(channel) === true){
    channel = 0;
  }

  objectForEach(track.midiOutputs, function(output){
    //console.log('midi out', output, midiEvent.type);
    if(midiEvent.type === 128 || midiEvent.type === 144 || midiEvent.type === 176){
      //console.log(midiEvent.type, midiEvent.data1, midiEvent.data2);
      output.send([midiEvent.type, midiEvent.data1, midiEvent.data2]);
    // }else if(midiEvent.type === 192){
    //     output.send([midiEvent.type + channel, midiEvent.data1]);
    }
    //output.send([midiEvent.status + channel, midiEvent.data1, midiEvent.data2]);
  });

  // @TODO: maybe a track should be able to send its event to both a midi-out port and an internal heartbeat song?
  //console.log(track.routeToMidiOut);
  if(track.routeToMidiOut === false){
    midiEvent.track = track;
    track.instrument.processEvent(midiEvent);
  }
}


function addMidiEventListener(...args){ // caller can be a track or a song

  let id = midiEventListenerId++;
  let listener;
    types = {},
    ids = [],
    loop;


  // should I inline this?
  loop = function(args){
    for(let arg of args){
      let type = typeString(arg);
      //console.log(type);
      if(type === 'array'){
        loop(arg);
      }else if(type === 'function'){
        listener = arg;
      }else if(isNaN(arg) === false){
        arg = parseInt(arg, 10);
        if(sequencer.checkEventType(arg) !== false){
          types[arg] = arg;
        }
      }else if(type === 'string'){
        if(sequencer.checkEventType(arg) !== false){
          arg = sequencer.midiEventNumberByName(arg);
          types[arg] = arg;
        }
      }
    }
  };

  loop(args, 0, args.length);
  //console.log('types', types, 'listener', listener);

  objectForEach(types, function(type){
    //console.log(type);
    if(obj.midiEventListeners[type] === undefined){
      obj.midiEventListeners[type] = {};
    }
    obj.midiEventListeners[type][id] = listener;
    ids.push(type + '_' + id);
  });

  //console.log(obj.midiEventListeners);
  return ids.length === 1 ? ids[0] : ids;
}


function removeMidiEventListener(id, obj){
  var type;
  id = id.split('_');
  type = id[0];
  id = id[1];
  delete obj.midiEventListeners[type][id];
}


function removeMidiEventListeners(){

}

*/
exports.getMIDIInputById = _getMIDIInputById;

},{"./util":27}],9:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Instrument = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _sample = require('./sample');

var _init_audio = require('./init_audio');

var _note = require('./note');

var _parse_audio = require('./parse_audio');

var _util = require('./util');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ppq = 480;
var bpm = 120;
var playbackSpeed = 1;
var millisPerTick = 1 / playbackSpeed * 60 / bpm / ppq;

var Instrument = exports.Instrument = function () {
  function Instrument(id, type) {
    _classCallCheck(this, Instrument);

    this.id = id;
    this.type = type;
    // create a samples data object for all 128 velocity levels of all 128 notes
    this.samplesData = new Array(128).fill(-1);
    this.samplesData = this.samplesData.map(function () {
      return new Array(128).fill(-1);
    });

    this.scheduledSamples = {};
    this.sustainedSamples = [];
    this.sustainPedalDown = false;
  }

  _createClass(Instrument, [{
    key: 'connect',
    value: function connect(output) {
      this.output = output;
    }
  }, {
    key: 'processMIDIEvent',
    value: function processMIDIEvent(event, time) {
      var _this = this;

      var sample = void 0,
          sampleData = void 0;
      time = time || _init_audio.context.currentTime + event.ticks * millisPerTick;
      //console.log(time)

      if (event.type === 144) {
        //console.log(144, ':', time, context.currentTime, event.millis)

        sampleData = this.samplesData[event.data1][event.data2];
        sample = (0, _sample.createSample)(sampleData, event);
        this.scheduledSamples[event.midiNoteId] = sample;
        sample.output.connect(this.output || _init_audio.context.destination);
        // sample.source.onended = () => {
        //   console.log('    deleting', event.midiNoteId)
        //   delete this.scheduledSamples[event.midiNoteId]
        // }
        sample.start(time);
        //console.log('scheduling', event.id, event.midiNoteId)
        //console.log('start', event.midiNoteId)
      } else if (event.type === 128) {
          //console.log(128, ':', time, context.currentTime, event.millis)
          sample = this.scheduledSamples[event.midiNoteId];
          if (typeof sample === 'undefined') {
            console.info('sample not found for event', event.id, ' midiNote', event.midiNoteId, event);
            return;
          }
          if (this.sustainPedalDown === true) {
            //console.log(event.midiNoteId)
            this.sustainedSamples.push(event.midiNoteId);
          } else {
            sample.stop(time, function () {
              //console.log('stop', event.midiNoteId)
              delete _this.scheduledSamples[event.midiNoteId];
            });
            //sample.stop(time)
          }
        } else if (event.type === 176) {
            // sustain pedal
            if (event.data1 === 64) {
              if (event.data2 === 127) {
                this.sustainPedalDown = true;
                //console.log('sustain pedal down')
                //dispatchEvent(this.track.song, 'sustain_pedal', 'down');
              } else if (event.data2 === 0) {
                  this.sustainPedalDown = false;
                  this.sustainedSamples.forEach(function (midiNoteId) {
                    sample = _this.scheduledSamples[midiNoteId];
                    if (sample) {
                      //sample.stop(time)
                      sample.stop(time, function () {
                        //console.log('stop', midiNoteId)
                        delete _this.scheduledSamples[midiNoteId];
                      });
                    }
                  });
                  //console.log('sustain pedal up', this.sustainedSamples)
                  this.sustainedSamples = [];
                  //dispatchEvent(this.track.song, 'sustain_pedal', 'up');
                  //this.stopSustain(time);
                }

              // panning
            } else if (event.data1 === 10) {
                // panning is *not* exactly timed -> not possible (yet) with WebAudio
                //console.log(data2, remap(data2, 0, 127, -1, 1));
                //track.setPanning(remap(data2, 0, 127, -1, 1));

                // volume
              } else if (event.data1 === 7) {
                  // to be implemented
                }
          }
    }

    // load and parse

  }, {
    key: 'parseSampleData',
    value: function parseSampleData(data) {
      var _this2 = this;

      return new Promise(function (resolve, reject) {
        (0, _parse_audio.parseSamples2)(data).then(function (result) {

          if (typeof data.release !== 'undefined') {
            _this2.setRelease(data.release[0], data.release[1]);
            //console.log(data.release[0], data.release[1])
          }

          result.forEach(function (sample) {
            var sampleData = data[sample.id];
            if (typeof sampleData === 'string') {
              sampleData = {
                buffer: sample.buffer
              };
            } else {
              sampleData.buffer = sample.buffer;
            }
            sampleData.note = sample.id;
            _this2.updateSampleData(sampleData);
          });

          resolve();
        });
      });
    }

    /*
      @param config (optional)
        {
          note: can be note name (C4) or note number (60)
          buffer: AudioBuffer
          sustain: [sustainStart, sustainEnd], // optional, in millis
          release: [releaseDuration, releaseEnvelope], // optional
          pan: panPosition // optional
          velocity: [velocityStart, velocityEnd] // optional, for multi-layered instruments
        }
    */

  }, {
    key: 'updateSampleData',
    value: function updateSampleData() {
      var _this3 = this;

      for (var _len = arguments.length, data = Array(_len), _key = 0; _key < _len; _key++) {
        data[_key] = arguments[_key];
      }

      data.forEach(function (noteData) {
        return _this3._updateSampleData(noteData);
      });
    }
  }, {
    key: '_updateSampleData',
    value: function _updateSampleData() {
      var _this4 = this;

      var data = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
      var note = data.note;
      var _data$buffer = data.buffer;
      var buffer = _data$buffer === undefined ? null : _data$buffer;
      var _data$sustain = data.sustain;
      var sustain = _data$sustain === undefined ? [null, null] : _data$sustain;
      var _data$release = data.release;
      var release = _data$release === undefined ? [null, 'linear'] : _data$release;
      var _data$pan = data.pan;
      var pan = _data$pan === undefined ? null : _data$pan;
      var _data$velocity = data.velocity;
      var velocity = _data$velocity === undefined ? [0, 127] : _data$velocity;


      if (typeof note === 'undefined') {
        console.warn('please provide a notenumber or a notename');
        return;
      }

      // get notenumber from notename and check if the notenumber is valid
      var n = (0, _note.createNote)(note);
      if (n === false) {
        console.warn('not a valid note id');
        return;
      }
      note = n.number;

      var _sustain = _slicedToArray(sustain, 2);

      var sustainStart = _sustain[0];
      var sustainEnd = _sustain[1];

      var _release = _slicedToArray(release, 2);

      var releaseDuration = _release[0];
      var releaseEnvelope = _release[1];

      var _velocity = _slicedToArray(velocity, 2);

      var velocityStart = _velocity[0];
      var velocityEnd = _velocity[1];


      if (sustain.length !== 2) {
        sustainStart = sustainEnd = null;
      }

      if (releaseDuration === null) {
        releaseEnvelope = null;
      }

      // console.log(noteId, buffer);
      // console.log(sustainStart, sustainEnd);
      // console.log(releaseDuration, releaseEnvelope);
      // console.log(pan);
      // console.log(velocityStart, velocityEnd);

      this.samplesData[note].forEach(function (sampleData, i) {
        if (i >= velocityStart && i < velocityEnd) {
          if (sampleData === -1) {
            sampleData = {
              id: note
            };
          }

          sampleData.buffer = buffer || sampleData.buffer;
          sampleData.sustainStart = sustainStart || sampleData.sustainStart;
          sampleData.sustainEnd = sustainEnd || sampleData.sustainEnd;
          sampleData.releaseDuration = releaseDuration || sampleData.releaseDuration;
          sampleData.releaseEnvelope = releaseEnvelope || sampleData.releaseEnvelope;
          sampleData.pan = pan || sampleData.pan;

          if ((0, _util.typeString)(sampleData.releaseEnvelope) === 'array') {
            sampleData.releaseEnvelopeArray = sampleData.releaseEnvelope;
            sampleData.releaseEnvelope = 'array';
          } else {
            delete sampleData.releaseEnvelopeArray;
          }
          _this4.samplesData[note][i] = sampleData;
        }
      });
      //console.log('%O', this.samplesData[note]);
    }

    // stereo spread

  }, {
    key: 'setKeyScalingPanning',
    value: function setKeyScalingPanning() {
      // sets panning based on the key value, e.g. higher notes are panned more to the right and lower notes more to the left
    }
  }, {
    key: 'setKeyScalingRelease',
    value: function setKeyScalingRelease() {}
    // set release based on key value


    /*
      @duration: milliseconds
      @envelope: linear | equal_power | array of int values
    */

  }, {
    key: 'setRelease',
    value: function setRelease(duration, envelope) {
      // set release for all keys, overrules values set by setKeyScalingRelease()
      this.samplesData.forEach(function (samples, i) {
        samples.forEach(function (sample) {
          if (sample === -1) {
            sample = {
              id: i
            };
          }
          sample.releaseDuration = duration;
          sample.releaseEnvelope = envelope;
        });
      });
    }
  }, {
    key: 'allNotesOff',
    value: function allNotesOff() {
      var _this5 = this;

      this.sustainedSamples = [];
      this.sustainPedalDown = false;
      Object.keys(this.scheduledSamples).forEach(function (sampleId) {
        //console.log('  stopping', sampleId)
        _this5.scheduledSamples[sampleId].stop();
      });
      this.scheduledSamples = {};

      //console.log('allNotesOff', this.sustainedSamples.length, this.scheduledSamples)
    }
  }]);

  return Instrument;
}();

},{"./init_audio":7,"./note":14,"./parse_audio":15,"./sample":21,"./util":27}],10:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// @ flow

var midiEventIndex = 0;

var MIDIEvent = exports.MIDIEvent = function () {
  function MIDIEvent(ticks, type, data1) {
    var data2 = arguments.length <= 3 || arguments[3] === undefined ? -1 : arguments[3];

    _classCallCheck(this, MIDIEvent);

    this.id = "ME_" + midiEventIndex++ + "_" + new Date().getTime();
    this.ticks = ticks;
    this.type = type;
    this.data1 = data1;
    this.data2 = data2;
    this.frequency = 440 * Math.pow(2, (data1 - 69) / 12);

    if (data1 === 144 && data2 === 0) {
      this.data1 = 128;
    }

    this._part = null;
    this._track = null;
    this._song = null;
    //@TODO: add all other properties
  }

  _createClass(MIDIEvent, [{
    key: "copy",
    value: function copy() {
      var m = new MIDIEvent(this.ticks, this.type, this.data1, this.data2);
      return m;
    }
  }, {
    key: "transpose",
    value: function transpose(amount) {
      // may be better if not a public method?
      this.data1 += amount;
      this.frequency = 440 * Math.pow(2, (this.data1 - 69) / 12);
    }
  }, {
    key: "move",
    value: function move(ticks) {
      this.ticks += ticks;
      if (this.midiNote) {
        this.midiNote.update();
      }
    }
  }, {
    key: "moveTo",
    value: function moveTo(ticks) {
      this.ticks = ticks;
      if (this.midiNote) {
        this.midiNote.update();
      }
    }
  }]);

  return MIDIEvent;
}();

/*
export function deleteMIDIEvent(event){
  //event.note = null
  event.note = null
  event = null
}
*/

},{}],11:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MIDINote = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _midi_event = require('./midi_event');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var midiNoteIndex = 0;

var MIDINote = exports.MIDINote = function () {
  function MIDINote(noteon, noteoff) {
    _classCallCheck(this, MIDINote);

    if (noteon.type !== 144 || noteoff.type !== 128) {
      console.warn('cannot create MIDINote');
      return;
    }
    this.id = 'MN_' + midiNoteIndex++ + '_' + new Date().getTime();
    this.noteOn = noteon;
    this.noteOff = noteoff;
    noteon.midiNote = this;
    noteoff.midiNote = this;
    noteon.midiNoteId = this.id;
    noteoff.midiNoteId = this.id;
    this.durationTicks = noteoff.ticks - noteon.ticks;
    this.durationMillis = -1;
  }

  _createClass(MIDINote, [{
    key: 'copy',
    value: function copy() {
      return new MIDINote(this.noteOn.copy(), this.noteOff.copy());
    }
  }, {
    key: 'update',
    value: function update() {
      // may use another name for this method
      this.durationTicks = this.noteOff.ticks - this.noteOn.ticks;
    }
  }, {
    key: 'transpose',
    value: function transpose(amount) {
      this.noteOn.transpose(amount);
      this.noteOff.transpose(amount);
    }
  }, {
    key: 'move',
    value: function move(ticks) {
      this.noteOn.move(ticks);
      this.noteOff.move(ticks);
    }
  }, {
    key: 'moveTo',
    value: function moveTo(ticks) {
      this.noteOn.moveTo(ticks);
      this.noteOff.moveTo(ticks);
    }
  }, {
    key: 'unregister',
    value: function unregister() {
      if (this.part) {
        this.part.removeEvents(this);
        this.part = null;
      }
      if (this.track) {
        this.track.removeEvents(this);
        this.track = null;
      }
      if (this.song) {
        this.song.removeEvents(this);
        this.song = null;
      }
    }
  }]);

  return MIDINote;
}();

},{"./midi_event":10}],12:[function(require,module,exports){
/*
  Wrapper for accessing bytes through sequential reads

  based on: https://github.com/gasman/jasmid
  adapted to work with ArrayBuffer -> Uint8Array
*/

'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var fcc = String.fromCharCode;

var MIDIStream = function () {

  // buffer is Uint8Array

  function MIDIStream(buffer) {
    _classCallCheck(this, MIDIStream);

    this.buffer = buffer;
    this.position = 0;
  }

  /* read string or any number of bytes */


  _createClass(MIDIStream, [{
    key: 'read',
    value: function read(length) {
      var toString = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

      var result = void 0;

      if (toString) {
        result = '';
        for (var i = 0; i < length; i++, this.position++) {
          result += fcc(this.buffer[this.position]);
        }
        return result;
      } else {
        result = [];
        for (var _i = 0; _i < length; _i++, this.position++) {
          result.push(this.buffer[this.position]);
        }
        return result;
      }
    }

    /* read a big-endian 32-bit integer */

  }, {
    key: 'readInt32',
    value: function readInt32() {
      var result = (this.buffer[this.position] << 24) + (this.buffer[this.position + 1] << 16) + (this.buffer[this.position + 2] << 8) + this.buffer[this.position + 3];
      this.position += 4;
      return result;
    }

    /* read a big-endian 16-bit integer */

  }, {
    key: 'readInt16',
    value: function readInt16() {
      var result = (this.buffer[this.position] << 8) + this.buffer[this.position + 1];
      this.position += 2;
      return result;
    }

    /* read an 8-bit integer */

  }, {
    key: 'readInt8',
    value: function readInt8(signed) {
      var result = this.buffer[this.position];
      if (signed && result > 127) {
        result -= 256;
      }
      this.position += 1;
      return result;
    }
  }, {
    key: 'eof',
    value: function eof() {
      return this.position >= this.buffer.length;
    }

    /* read a MIDI-style letiable-length integer
      (big-endian value in groups of 7 bits,
      with top bit set to signify that another byte follows)
    */

  }, {
    key: 'readVarInt',
    value: function readVarInt() {
      var result = 0;
      while (true) {
        var b = this.readInt8();
        if (b & 0x80) {
          result += b & 0x7f;
          result <<= 7;
        } else {
          /* b is the last byte */
          return result + b;
        }
      }
    }
  }, {
    key: 'reset',
    value: function reset() {
      this.position = 0;
    }
  }, {
    key: 'setPosition',
    value: function setPosition(p) {
      this.position = p;
    }
  }]);

  return MIDIStream;
}();

exports.default = MIDIStream;

},{}],13:[function(require,module,exports){
/*
  Extracts all midi events from a binary midi file, uses midi_stream.js

  based on: https://github.com/gasman/jasmid
*/

'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseMIDIFile = parseMIDIFile;

var _midi_stream = require('./midi_stream');

var _midi_stream2 = _interopRequireDefault(_midi_stream);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var lastEventTypeByte = void 0,
    trackName = void 0;

function readChunk(stream) {
  var id = stream.read(4, true);
  var length = stream.readInt32();
  //console.log(length);
  return {
    'id': id,
    'length': length,
    'data': stream.read(length, false)
  };
}

function readEvent(stream) {
  var event = {};
  var length;
  event.deltaTime = stream.readVarInt();
  var eventTypeByte = stream.readInt8();
  //console.log(eventTypeByte, eventTypeByte & 0x80, 146 & 0x0f);
  if ((eventTypeByte & 0xf0) == 0xf0) {
    /* system / meta event */
    if (eventTypeByte == 0xff) {
      /* meta event */
      event.type = 'meta';
      var subtypeByte = stream.readInt8();
      length = stream.readVarInt();
      switch (subtypeByte) {
        case 0x00:
          event.subtype = 'sequenceNumber';
          if (length !== 2) {
            throw 'Expected length for sequenceNumber event is 2, got ' + length;
          }
          event.number = stream.readInt16();
          return event;
        case 0x01:
          event.subtype = 'text';
          event.text = stream.read(length);
          return event;
        case 0x02:
          event.subtype = 'copyrightNotice';
          event.text = stream.read(length);
          return event;
        case 0x03:
          event.subtype = 'trackName';
          event.text = stream.read(length);
          trackName = event.text;
          return event;
        case 0x04:
          event.subtype = 'instrumentName';
          event.text = stream.read(length);
          return event;
        case 0x05:
          event.subtype = 'lyrics';
          event.text = stream.read(length);
          return event;
        case 0x06:
          event.subtype = 'marker';
          event.text = stream.read(length);
          return event;
        case 0x07:
          event.subtype = 'cuePoint';
          event.text = stream.read(length);
          return event;
        case 0x20:
          event.subtype = 'midiChannelPrefix';
          if (length !== 1) {
            throw 'Expected length for midiChannelPrefix event is 1, got ' + length;
          }
          event.channel = stream.readInt8();
          return event;
        case 0x2f:
          event.subtype = 'endOfTrack';
          if (length !== 0) {
            throw 'Expected length for endOfTrack event is 0, got ' + length;
          }
          return event;
        case 0x51:
          event.subtype = 'setTempo';
          if (length !== 3) {
            throw 'Expected length for setTempo event is 3, got ' + length;
          }
          event.microsecondsPerBeat = (stream.readInt8() << 16) + (stream.readInt8() << 8) + stream.readInt8();
          return event;
        case 0x54:
          event.subtype = 'smpteOffset';
          if (length !== 5) {
            throw 'Expected length for smpteOffset event is 5, got ' + length;
          }
          var hourByte = stream.readInt8();
          event.frameRate = {
            0x00: 24, 0x20: 25, 0x40: 29, 0x60: 30
          }[hourByte & 0x60];
          event.hour = hourByte & 0x1f;
          event.min = stream.readInt8();
          event.sec = stream.readInt8();
          event.frame = stream.readInt8();
          event.subframe = stream.readInt8();
          return event;
        case 0x58:
          event.subtype = 'timeSignature';
          if (length !== 4) {
            throw 'Expected length for timeSignature event is 4, got ' + length;
          }
          event.numerator = stream.readInt8();
          event.denominator = Math.pow(2, stream.readInt8());
          event.metronome = stream.readInt8();
          event.thirtyseconds = stream.readInt8();
          return event;
        case 0x59:
          event.subtype = 'keySignature';
          if (length !== 2) {
            throw 'Expected length for keySignature event is 2, got ' + length;
          }
          event.key = stream.readInt8(true);
          event.scale = stream.readInt8();
          return event;
        case 0x7f:
          event.subtype = 'sequencerSpecific';
          event.data = stream.read(length);
          return event;
        default:
          //if(sequencer.debug >= 2){
          //    console.warn('Unrecognised meta event subtype: ' + subtypeByte);
          //}
          event.subtype = 'unknown';
          event.data = stream.read(length);
          return event;
      }
      event.data = stream.read(length);
      return event;
    } else if (eventTypeByte == 0xf0) {
      event.type = 'sysEx';
      length = stream.readVarInt();
      event.data = stream.read(length);
      return event;
    } else if (eventTypeByte == 0xf7) {
      event.type = 'dividedSysEx';
      length = stream.readVarInt();
      event.data = stream.read(length);
      return event;
    } else {
      throw 'Unrecognised MIDI event type byte: ' + eventTypeByte;
    }
  } else {
    /* channel event */
    var param1 = void 0;
    if ((eventTypeByte & 0x80) === 0) {
      /* running status - reuse lastEventTypeByte as the event type.
        eventTypeByte is actually the first parameter
      */
      //console.log('running status');
      param1 = eventTypeByte;
      eventTypeByte = lastEventTypeByte;
    } else {
      param1 = stream.readInt8();
      //console.log('last', eventTypeByte);
      lastEventTypeByte = eventTypeByte;
    }
    var eventType = eventTypeByte >> 4;
    event.channel = eventTypeByte & 0x0f;
    event.type = 'channel';
    switch (eventType) {
      case 0x08:
        event.subtype = 'noteOff';
        event.noteNumber = param1;
        event.velocity = stream.readInt8();
        return event;
      case 0x09:
        event.noteNumber = param1;
        event.velocity = stream.readInt8();
        if (event.velocity === 0) {
          event.subtype = 'noteOff';
        } else {
          event.subtype = 'noteOn';
          //console.log('noteOn');
        }
        return event;
      case 0x0a:
        event.subtype = 'noteAftertouch';
        event.noteNumber = param1;
        event.amount = stream.readInt8();
        return event;
      case 0x0b:
        event.subtype = 'controller';
        event.controllerType = param1;
        event.value = stream.readInt8();
        return event;
      case 0x0c:
        event.subtype = 'programChange';
        event.programNumber = param1;
        return event;
      case 0x0d:
        event.subtype = 'channelAftertouch';
        event.amount = param1;
        //if(trackName === 'SH-S1-44-C09 L=SML IN=3'){
        //    console.log('channel pressure', trackName, param1);
        //}
        return event;
      case 0x0e:
        event.subtype = 'pitchBend';
        event.value = param1 + (stream.readInt8() << 7);
        return event;
      default:
        /*
        throw 'Unrecognised MIDI event type: ' + eventType;
        console.log('Unrecognised MIDI event type: ' + eventType);
        */

        event.value = stream.readInt8();
        event.subtype = 'unknown';
        //console.log(event);
        /*
                event.noteNumber = param1;
                event.velocity = stream.readInt8();
                event.subtype = 'noteOn';
                console.log('weirdo', trackName, param1, event.velocity);
        */

        return event;
    }
  }
}

function parseMIDIFile(buffer) {
  if (buffer instanceof Uint8Array === false && buffer instanceof ArrayBuffer === false) {
    console.error('buffer should be an instance of Uint8Array of ArrayBuffer');
    return;
  }
  if (buffer instanceof ArrayBuffer) {
    buffer = new Uint8Array(buffer);
  }
  var tracks = new Map();
  var stream = new _midi_stream2.default(buffer);

  var headerChunk = readChunk(stream);
  if (headerChunk.id !== 'MThd' || headerChunk.length !== 6) {
    throw 'Bad .mid file - header not found';
  }

  var headerStream = new _midi_stream2.default(headerChunk.data);
  var formatType = headerStream.readInt16();
  var trackCount = headerStream.readInt16();
  var timeDivision = headerStream.readInt16();

  if (timeDivision & 0x8000) {
    throw 'Expressing time division in SMTPE frames is not supported yet';
  }

  var header = {
    'formatType': formatType,
    'trackCount': trackCount,
    'ticksPerBeat': timeDivision
  };

  for (var i = 0; i < trackCount; i++) {
    trackName = 'track_' + i;
    var track = [];
    var trackChunk = readChunk(stream);
    if (trackChunk.id !== 'MTrk') {
      throw 'Unexpected chunk - expected MTrk, got ' + trackChunk.id;
    }
    var trackStream = new _midi_stream2.default(trackChunk.data);
    while (!trackStream.eof()) {
      var event = readEvent(trackStream);
      track.push(event);
    }
    tracks.set(trackName, track);
  }

  return {
    'header': header,
    'tracks': tracks
  };
}

},{"./midi_stream":12}],14:[function(require,module,exports){
/*
  Adds a function to create a note object that contains information about a musical note:
    - name, e.g. 'C'
    - octave,  -1 - 9
    - fullName: 'C1'
    - frequency: 234.16, based on the basic pitch
    - number: 60 midi note number

  Adds several utility methods organised around the note object
*/

'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createNote = createNote;
exports.getNoteNumber = getNoteNumber;
exports.getNoteName = getNoteName;
exports.getNoteOctave = getNoteOctave;
exports.getFullNoteName = getFullNoteName;
exports.getFrequency = getFrequency;
exports.isBlackKey = isBlackKey;

var _util = require('./util');

var errorMsg = void 0,
    warningMsg = void 0,
    pow = Math.pow,
    floor = Math.floor;

var noteNames = {
  'sharp': ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'],
  'flat': ['C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B'],
  'enharmonic-sharp': ['B#', 'C#', 'C##', 'D#', 'D##', 'E#', 'F#', 'F##', 'G#', 'G##', 'A#', 'A##'],
  'enharmonic-flat': ['Dbb', 'Db', 'Ebb', 'Eb', 'Fb', 'Gbb', 'Gb', 'Abb', 'Ab', 'Bbb', 'Bb', 'Cb']
};

/*
  arguments
  - noteNumber: 60
  - noteNumber and notename mode: 60, 'sharp'
  - noteName: 'C#4'
  - name and octave: 'C#', 4
  - note name, octave, note name mode: 'D', 4, 'sharp'
  - data object:
    {
      name: 'C',
      octave: 4
    }
    or
    {
      frequency: 234.16
    }
*/

function createNote() {
  var numArgs = arguments.length,
      data = void 0,
      octave = void 0,
      noteName = void 0,
      noteNumber = void 0,
      noteNameMode = void 0,
      arg0 = arguments.length <= 0 ? undefined : arguments[0],
      arg1 = arguments.length <= 1 ? undefined : arguments[1],
      arg2 = arguments.length <= 2 ? undefined : arguments[2],
      type0 = (0, _util.typeString)(arg0),
      type1 = (0, _util.typeString)(arg1),
      type2 = (0, _util.typeString)(arg2);

  errorMsg = '';
  warningMsg = '';

  // argument: note number
  //console.log(numArgs, type0)
  if (numArgs === 1 && type0 === 'number') {
    if (arg0 < 0 || arg0 > 127) {
      errorMsg = 'please provide a note number >= 0 and <= 127 ' + arg0;
    } else {
      noteNumber = arg0;
      data = _getNoteName(noteNumber);
      noteName = data[0];
      octave = data[1];
    }

    // arguments: full note name
  } else if (numArgs === 1 && type0 === 'string') {
      data = _checkNoteName(arg0);
      if (errorMsg === '') {
        noteName = data[0];
        octave = data[1];
        noteNumber = _getNoteNumber(noteName, octave);
      }

      // arguments: note name, octave
    } else if (numArgs === 2 && type0 === 'string' && type1 === 'number') {
        data = _checkNoteName(arg0, arg1);
        if (errorMsg === '') {
          noteName = data[0];
          octave = data[1];
          noteNumber = _getNoteNumber(noteName, octave);
        }

        // arguments: full note name, note name mode -> for converting between note name modes
      } else if (numArgs === 2 && type0 === 'string' && type1 === 'string') {
          data = _checkNoteName(arg0);
          if (errorMsg === '') {
            noteNameMode = _checkNoteNameMode(arg1);
            noteName = data[0];
            octave = data[1];
            noteNumber = _getNoteNumber(noteName, octave);
          }

          // arguments: note number, note name mode
        } else if (numArgs === 2 && (0, _util.typeString)(arg0) === 'number' && (0, _util.typeString)(arg1) === 'string') {
            if (arg0 < 0 || arg0 > 127) {
              errorMsg = 'please provide a note number >= 0 and <= 127 ' + arg0;
            } else {
              noteNameMode = _checkNoteNameMode(arg1);
              noteNumber = arg0;
              data = _getNoteName(noteNumber, noteNameMode);
              noteName = data[0];
              octave = data[1];
            }

            // arguments: note name, octave, note name mode
          } else if (numArgs === 3 && type0 === 'string' && type1 === 'number' && type2 === 'string') {
              data = _checkNoteName(arg0, arg1);
              if (errorMsg === '') {
                noteNameMode = _checkNoteNameMode(arg2);
                noteName = data[0];
                octave = data[1];
                noteNumber = _getNoteNumber(noteName, octave);
              }
            } else {
              errorMsg = 'wrong arguments, please consult documentation';
            }

  if (errorMsg) {
    console.error(errorMsg);
    return false;
  }

  if (warningMsg) {
    console.warn(warningMsg);
  }

  var note = {
    name: noteName,
    octave: octave,
    fullName: noteName + octave,
    number: noteNumber,
    frequency: _getFrequency(noteNumber),
    blackKey: _isBlackKey(noteNumber)
  };
  Object.freeze(note);
  return note;
}

//function _getNoteName(number, mode = config.get('noteNameMode')) {
function _getNoteName(number) {
  var mode = arguments.length <= 1 || arguments[1] === undefined ? 'sharp' : arguments[1];

  //let octave = Math.floor((number / 12) - 2), //  in Cubase central C = C3 instead of C4
  var octave = floor(number / 12 - 1);
  var noteName = noteNames[mode][number % 12];
  return [noteName, octave];
}

function _getNoteNumber(name, octave) {
  var keys = Object.keys(noteNames);
  var index = void 0;

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = keys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var key = _step.value;

      var mode = noteNames[key];
      index = mode.findIndex(function (x) {
        return x === name;
      });
      if (index !== -1) {
        break;
      }
    }

    //number = (index + 12) + (octave * 12) + 12; //  in Cubase central C = C3 instead of C4
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  var number = index + 12 + octave * 12; //  midi standard + scientific naming, see: http://en.wikipedia.org/wiki/Middle_C and http://en.wikipedia.org/wiki/Scientific_pitch_notation

  if (number < 0 || number > 127) {
    errorMsg = 'please provide a note between C0 and G10';
    return;
  }
  return number;
}

function _getFrequency(number) {
  //return config.get('pitch') * pow(2,(number - 69)/12); // midi standard, see: http://en.wikipedia.org/wiki/MIDI_Tuning_Standard
  return 440 * pow(2, (number - 69) / 12); // midi standard, see: http://en.wikipedia.org/wiki/MIDI_Tuning_Standard
}

// TODO: calculate note from frequency
function _getPitch(hertz) {
  //fm  =  2(m69)/12(440 Hz).
}

function _checkNoteNameMode(mode) {
  var keys = Object.keys(noteNames);
  var result = keys.find(function (x) {
    return x === mode;
  }) !== undefined;
  if (result === false) {
    //mode = config.get('noteNameMode');
    mode = 'sharp';
    warningMsg = mode + ' is not a valid note name mode, using "' + mode + '" instead';
  }
  return mode;
}

function _checkNoteName() {
  var numArgs = arguments.length,
      arg0 = arguments.length <= 0 ? undefined : arguments[0],
      arg1 = arguments.length <= 1 ? undefined : arguments[1],
      char = void 0,
      name = '',
      octave = '';

  // extract octave from note name
  if (numArgs === 1) {
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = arg0[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        char = _step2.value;

        if (isNaN(char) && char !== '-') {
          name += char;
        } else {
          octave += char;
        }
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    if (octave === '') {
      octave = 0;
    }
  } else if (numArgs === 2) {
    name = arg0;
    octave = arg1;
  }

  // check if note name is valid
  var keys = Object.keys(noteNames);
  var index = -1;

  var _iteratorNormalCompletion3 = true;
  var _didIteratorError3 = false;
  var _iteratorError3 = undefined;

  try {
    for (var _iterator3 = keys[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
      var key = _step3.value;

      var mode = noteNames[key];
      index = mode.findIndex(function (x) {
        return x === name;
      });
      if (index !== -1) {
        break;
      }
    }
  } catch (err) {
    _didIteratorError3 = true;
    _iteratorError3 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion3 && _iterator3.return) {
        _iterator3.return();
      }
    } finally {
      if (_didIteratorError3) {
        throw _iteratorError3;
      }
    }
  }

  if (index === -1) {
    errorMsg = arg0 + ' is not a valid note name, please use letters A - G and if necessary an accidental like #, ##, b or bb, followed by a number for the octave';
    return;
  }

  if (octave < -1 || octave > 9) {
    errorMsg = 'please provide an octave between -1 and 9';
    return;
  }

  octave = parseInt(octave, 10);
  name = name.substring(0, 1).toUpperCase() + name.substring(1);

  //console.log(name,'|',octave);
  return [name, octave];
}

function _isBlackKey(noteNumber) {
  var black = void 0;

  switch (true) {
    case noteNumber % 12 === 1: //C#
    case noteNumber % 12 === 3: //D#
    case noteNumber % 12 === 6: //F#
    case noteNumber % 12 === 8: //G#
    case noteNumber % 12 === 10:
      //A#
      black = true;
      break;
    default:
      black = false;
  }

  return black;
}

function getNoteNumber() {
  var note = createNote.apply(undefined, arguments);
  if (note) {
    return note.number;
  }
  return errorMsg;
}

function getNoteName() {
  var note = createNote.apply(undefined, arguments);
  if (note) {
    return note.name;
  }
  return false;
}

function getNoteOctave() {
  var note = createNote.apply(undefined, arguments);
  if (note) {
    return note.octave;
  }
  return false;
}

function getFullNoteName() {
  var note = createNote.apply(undefined, arguments);
  if (note) {
    return note.fullName;
  }
  return false;
}

function getFrequency() {
  var note = createNote.apply(undefined, arguments);
  if (note) {
    return note.frequency;
  }
  return false;
}

function isBlackKey() {
  var note = createNote.apply(undefined, arguments);
  if (note) {
    return note.blackKey;
  }
  return false;
}

},{"./util":27}],15:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

exports.decodeSample = decodeSample;
exports.parseSamples2 = parseSamples2;
exports.parseSamples = parseSamples;

var _init_audio = require('./init_audio');

var _util = require('./util');

var _isomorphicFetch = require('isomorphic-fetch');

var _isomorphicFetch2 = _interopRequireDefault(_isomorphicFetch);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function decodeSample(sample, id, every) {
  return new Promise(function (resolve) {
    try {
      _init_audio.context.decodeAudioData(sample, function onSuccess(buffer) {
        //console.log(id, buffer);
        if (typeof id !== 'undefined') {
          resolve({ id: id, buffer: buffer });
          if (every) {
            every({ id: id, buffer: buffer });
          }
        } else {
          resolve(buffer);
          if (every) {
            every(buffer);
          }
        }
      }, function onError(e) {
        console('error decoding audiodata', id, e);
        //reject(e); // don't use reject because we use this as a nested promise and we don't want the parent promise to reject
        if (typeof id !== 'undefined') {
          resolve({ id: id });
        } else {
          resolve();
        }
      });
    } catch (e) {
      console.warn('error decoding audiodata', id, e);
      if (typeof id !== 'undefined') {
        resolve({ id: id });
      } else {
        resolve();
      }
    }
  });
}

function loadAndParseSample(url, id, every) {
  //console.log(id, url)
  var executor = function executor(resolve) {
    (0, _isomorphicFetch2.default)(escape(url), {
      method: 'GET'
    }).then(function (response) {
      if (response.ok) {
        response.arrayBuffer().then(function (data) {
          //console.log(data)
          decodeSample(data, id, every).then(resolve);
        });
      } else if (typeof id !== 'undefined') {
        resolve({ id: id });
      } else {
        resolve();
      }
    });
  };
  return new Promise(executor);
}

function getPromises(promises, sample, key, every) {

  var getSample = function getSample() {

    if (sample instanceof ArrayBuffer) {
      promises.push(decodeSample(sample, key, every));
    } else if (typeof sample === 'string') {
      if ((0, _util.checkIfBase64)(sample)) {
        promises.push(decodeSample((0, _util.base64ToBinary)(sample), key, every));
      } else {
        promises.push(loadAndParseSample(sample, key, every));
      }
    } else if ((typeof sample === 'undefined' ? 'undefined' : _typeof(sample)) === 'object') {
      sample = sample.sample || sample.buffer || sample.base64 || sample.url;
      getSample(promises, sample, key, every);
      //console.log(sample, promises.length)
    }
  };

  getSample();
}

// only for internally use in qambi
function parseSamples2(mapping) {
  var every = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

  var type = (0, _util.typeString)(mapping),
      promises = [];

  every = typeof every === 'function' ? every : false;
  //console.log(type, mapping)
  if (type === 'object') {
    Object.keys(mapping).forEach(function (key) {
      //key = parseInt(key, 10)
      getPromises(promises, mapping[key], key, every);
    });
  } else if (type === 'array') {
    (function () {
      var key = void 0;
      mapping.forEach(function (sample) {
        // key is deliberately undefined
        getPromises(promises, sample, key, every);
      });
    })();
  }

  return new Promise(function (resolve) {
    Promise.all(promises).then(function (values) {
      if (type === 'object') {
        mapping = {};
        values.forEach(function (value) {
          mapping[value.id] = value.buffer;
        });
        resolve(mapping);
      } else if (type === 'array') {
        resolve(values);
      }
    });
  });
}

function parseSamples() {
  for (var _len = arguments.length, data = Array(_len), _key = 0; _key < _len; _key++) {
    data[_key] = arguments[_key];
  }

  if (data.length === 1 && (0, _util.typeString)(data[0]) !== 'string') {
    return parseSamples2(data[0]);
  }
  return parseSamples2(data);
}

},{"./init_audio":7,"./util":27,"isomorphic-fetch":2}],16:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseTimeEvents = parseTimeEvents;
exports.parseEvents = parseEvents;
exports.parseMIDINotes = parseMIDINotes;
exports.filterEvents = filterEvents;

var _util = require('./util');

var _midi_note = require('./midi_note');

var ppq = void 0,
    bpm = void 0,
    factor = void 0,
    nominator = void 0,
    denominator = void 0,
    playbackSpeed = void 0,
    bar = void 0,
    beat = void 0,
    sixteenth = void 0,
    tick = void 0,
    ticks = void 0,
    millis = void 0,
    millisPerTick = void 0,
    secondsPerTick = void 0,
    ticksPerBeat = void 0,
    ticksPerBar = void 0,
    ticksPerSixteenth = void 0,
    numSixteenth = void 0,
    diffTicks = void 0,
    previousEvent = void 0;

function setTickDuration() {
  secondsPerTick = 1 / playbackSpeed * 60 / bpm / ppq;
  millisPerTick = secondsPerTick * 1000;
  //console.log(millisPerTick, bpm, ppq, playbackSpeed, (ppq * millisPerTick));
  //console.log(ppq);
}

function setTicksPerBeat() {
  factor = 4 / denominator;
  numSixteenth = factor * 4;
  ticksPerBeat = ppq * factor;
  ticksPerBar = ticksPerBeat * nominator;
  ticksPerSixteenth = ppq / 4;
  //console.log(denominator, factor, numSixteenth, ticksPerBeat, ticksPerBar, ticksPerSixteenth);
}

function updatePosition(event) {
  var fast = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

  diffTicks = event.ticks - ticks;
  // if(diffTicks < 0){
  //   console.log(diffTicks, event.ticks, previousEvent.ticks, previousEvent.type)
  // }
  tick += diffTicks;
  ticks = event.ticks;
  previousEvent = event;
  //console.log(diffTicks, millisPerTick);
  millis += diffTicks * millisPerTick;

  if (fast === false) {
    while (tick >= ticksPerSixteenth) {
      sixteenth++;
      tick -= ticksPerSixteenth;
      while (sixteenth > numSixteenth) {
        sixteenth -= numSixteenth;
        beat++;
        while (beat > nominator) {
          beat -= nominator;
          bar++;
        }
      }
    }
  }
}

function parseTimeEvents(settings, timeEvents) {
  var isPlaying = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

  //console.log('parse time events')
  var type = void 0;
  var event = void 0;

  ppq = settings.ppq;
  bpm = settings.bpm;
  nominator = settings.nominator;
  denominator = settings.denominator;
  playbackSpeed = settings.playbackSpeed;
  bar = 1;
  beat = 1;
  sixteenth = 1;
  tick = 0;
  ticks = 0;
  millis = 0;

  setTickDuration();
  setTicksPerBeat();

  timeEvents.sort(function (a, b) {
    return a.ticks <= b.ticks ? -1 : 1;
  });
  var e = 0;
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = timeEvents[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      event = _step.value;

      //console.log(e++, event.ticks, event.type)
      //event.song = song;
      type = event.type;
      updatePosition(event, isPlaying);

      switch (type) {

        case 0x51:
          bpm = event.data1;
          //console.log(event)
          setTickDuration();
          break;

        case 0x58:
          nominator = event.data1;
          denominator = event.data2;
          setTicksPerBeat();
          break;

        default:
          continue;
      }

      //time data of time event is valid from (and included) the position of the time event
      updateEvent(event, isPlaying);
      //console.log(event.barsAsString);
    }

    //song.lastEventTmp = event;
    //console.log(event);
    //console.log(timeEvents);
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
}

//export function parseEvents(song, events){
function parseEvents(events) {
  var isPlaying = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

  //console.log('parseEvents')
  var event = void 0;
  var startEvent = 0;
  var lastEventTick = 0;
  var result = [];

  tick = 0;
  ticks = 0;
  diffTicks = 0;

  //let events = [].concat(evts, song._timeEvents);
  var numEvents = events.length;
  //console.log(events)

  // noteoff comes before noteon

  /*
    events.sort(function(a, b){
      return a.sortIndex - b.sortIndex;
    })
  */

  events.sort(function (a, b) {
    if (a.ticks === b.ticks) {
      // if(a.type === 128){
      //   return -1
      // }else if(b.type === 128){
      //   return 1
      // }
      // short:
      var r = a.type - b.type;
      if (a.type === 176 && b.type === 144) {
        r = -1;
      }
      return r;
    }
    return a.ticks - b.ticks;
  });
  event = events[0];
  //console.log(event)

  bpm = event.bpm;
  factor = event.factor;
  nominator = event.nominator;
  denominator = event.denominator;

  ticksPerBar = event.ticksPerBar;
  ticksPerBeat = event.ticksPerBeat;
  ticksPerSixteenth = event.ticksPerSixteenth;

  numSixteenth = event.numSixteenth;

  millisPerTick = event.millisPerTick;
  secondsPerTick = event.secondsPerTick;

  millis = event.millis;

  bar = event.bar;
  beat = event.beat;
  sixteenth = event.sixteenth;
  tick = event.tick;

  for (var i = startEvent; i < numEvents; i++) {

    event = events[i];

    switch (event.type) {

      case 0x51:
        bpm = event.data1;
        millis = event.millis;
        millisPerTick = event.millisPerTick;
        secondsPerTick = event.secondsPerTick;

        diffTicks = event.ticks - ticks;
        tick += diffTicks;
        ticks = event.ticks;
        //console.log(millisPerTick,event.millisPerTick);
        //console.log(event);
        break;

      case 0x58:
        factor = event.factor;
        nominator = event.data1;
        denominator = event.data2;
        numSixteenth = event.numSixteenth;
        ticksPerBar = event.ticksPerBar;
        ticksPerBeat = event.ticksPerBeat;
        ticksPerSixteenth = event.ticksPerSixteenth;
        millis = event.millis;

        diffTicks = event.ticks - ticks;
        tick += diffTicks;
        ticks = event.ticks;
        //console.log(nominator,numSixteenth,ticksPerSixteenth);
        //console.log(event);

        break;

      default:
        //case 128:
        //case 144:
        updatePosition(event, isPlaying);
        updateEvent(event, isPlaying);
        result.push(event);

      // if(event.type === 176 && event.data1 === 64){
      //   console.log(event.data2, event.barsAsString)
      // }

    }

    // if(i < 100 && (event.type === 81 || event.type === 144 || event.type === 128)){
    //   //console.log(i, ticks, diffTicks, millis, millisPerTick)
    //   console.log(event.type, event.millis, 'note', event.data1, 'velo', event.data2)
    // }

    lastEventTick = event.ticks;
  }
  parseMIDINotes(result);
  return result;
  //song.lastEventTmp = event;
}

function updateEvent(event) {
  var fast = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

  //console.log(bar, beat, ticks)
  //console.log(event, bpm, millisPerTick, ticks, millis);

  event.bpm = bpm;
  event.nominator = nominator;
  event.denominator = denominator;

  event.ticksPerBar = ticksPerBar;
  event.ticksPerBeat = ticksPerBeat;
  event.ticksPerSixteenth = ticksPerSixteenth;

  event.factor = factor;
  event.numSixteenth = numSixteenth;
  event.secondsPerTick = secondsPerTick;
  event.millisPerTick = millisPerTick;

  event.ticks = ticks;

  event.millis = millis;
  event.seconds = millis / 1000;

  if (fast) {
    return;
  }

  event.bar = bar;
  event.beat = beat;
  event.sixteenth = sixteenth;
  event.tick = tick;
  //event.barsAsString = (bar + 1) + ':' + (beat + 1) + ':' + (sixteenth + 1) + ':' + tick;
  var tickAsString = tick === 0 ? '000' : tick < 10 ? '00' + tick : tick < 100 ? '0' + tick : tick;
  event.barsAsString = bar + ':' + beat + ':' + sixteenth + ':' + tickAsString;
  event.barsAsArray = [bar, beat, sixteenth, tick];

  var timeData = (0, _util.getNiceTime)(millis);

  event.hour = timeData.hour;
  event.minute = timeData.minute;
  event.second = timeData.second;
  event.millisecond = timeData.millisecond;
  event.timeAsString = timeData.timeAsString;
  event.timeAsArray = timeData.timeAsArray;

  // if(millis < 0){
  //   console.log(event)
  // }
}

var midiNoteIndex = 0;

function parseMIDINotes(events) {
  var notes = {};
  var notesInTrack = void 0;
  var n = 0;
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = events[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var event = _step2.value;

      if (typeof event._part === 'undefined' || typeof event._track === 'undefined') {
        console.log('no part and/or track set');
        continue;
      }
      if (event.type === 144) {
        notesInTrack = notes[event._track.id];
        if (typeof notesInTrack === 'undefined') {
          notesInTrack = notes[event._track.id] = {};
        }
        notesInTrack[event.data1] = event;
      } else if (event.type === 128) {
        notesInTrack = notes[event._track.id];
        if (typeof notesInTrack === 'undefined') {
          //console.info(n++, 'no corresponding noteon event found for event', event.id)
          continue;
        }
        var noteOn = notesInTrack[event.data1];
        var noteOff = event;
        if (typeof noteOn === 'undefined') {
          //console.info(n++, 'no noteon event for event', event.id)
          delete notes[event._track.id][event.data1];
          continue;
        }
        var note = new _midi_note.MIDINote(noteOn, noteOff);
        // let id = `MN_${midiNoteIndex++}_${new Date().getTime()}`
        // noteOn.midiNoteId = id
        // noteOn.off = noteOff.id
        // noteOff.midiNoteId = id
        // noteOff.on = noteOn.id
        delete notes[event._track.id][event.data1];
      }
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  Object.keys(notes).forEach(function (key) {
    delete notes[key];
  });
  //console.log(notes, notesInTrack)
}

// not in use!
function filterEvents(events) {
  var sustain = {};
  var tmpResult = {};
  var result = [];
  var _iteratorNormalCompletion3 = true;
  var _didIteratorError3 = false;
  var _iteratorError3 = undefined;

  try {
    for (var _iterator3 = events[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
      var event = _step3.value;

      if (event.type === 176 && event.data1 === 64) {
        if (event.data2 === 0) {
          if (typeof sustain[event.trackId] === 'undefined') {
            continue;
          } else if (sustain[event.trackId] === event.ticks) {
            delete tmpResult[event.ticks];
            continue;
          }
          tmpResult[event.ticks] = event;
          delete sustain[event.trackId];
        } else if (event.data2 === 127) {
          sustain[event.trackId] = event.ticks;
          tmpResult[event.ticks] = event;
        }
      } else {
        result.push(event);
      }
    }
  } catch (err) {
    _didIteratorError3 = true;
    _iteratorError3 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion3 && _iterator3.return) {
        _iterator3.return();
      }
    } finally {
      if (_didIteratorError3) {
        throw _iteratorError3;
      }
    }
  }

  console.log(sustain);
  Object.keys(tmpResult).forEach(function (key) {
    var sustainEvent = tmpResult[key];
    console.log(sustainEvent);
    result.push(sustainEvent);
  });
  return result;
}

},{"./midi_note":11,"./util":27}],17:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Part = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // @ flow

var _util = require('./util');

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var partIndex = 0;

var Part = exports.Part = function () {
  function Part() {
    var name = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];

    _classCallCheck(this, Part);

    this.id = 'MP_' + partIndex++ + '_' + new Date().getTime();
    this.name = name || this.id;
    this.muted = false;
    this._track = null;
    this._song = null;
    this._events = [];
    this._eventsById = new Map();
    this._needsUpdate = false;
    this._createEventArray = false;
    this._start = { millis: 0, ticks: 0 };
    this._end = { millis: 0, ticks: 0 };
  }

  _createClass(Part, [{
    key: 'copy',
    value: function copy() {
      var p = new Part(this.name + '_copy'); // implement getNameOfCopy() in util (see heartbeat)
      var events = [];
      this._events.forEach(function (event) {
        var copy = event.copy();
        console.log(copy);
        events.push(copy);
      });
      p.addEvents.apply(p, events);
      p.update();
      return p;
    }
  }, {
    key: 'transpose',
    value: function transpose(amount) {
      this._events.forEach(function (event) {
        event.transpose(amount);
      });
      this._needsUpdate = true;
    }
  }, {
    key: 'move',
    value: function move(ticks) {
      this._events.forEach(function (event) {
        event.move(ticks);
      });
      if (this._song) {
        var _song$_movedEvents;

        (_song$_movedEvents = this._song._movedEvents).push.apply(_song$_movedEvents, _toConsumableArray(this._events));
      }
      this._needsUpdate = true;
    }
  }, {
    key: 'moveTo',
    value: function moveTo(ticks) {
      this._events.forEach(function (event) {
        event.moveTo(ticks);
      });
      if (this._song) {
        var _song$_movedEvents2;

        (_song$_movedEvents2 = this._song._movedEvents).push.apply(_song$_movedEvents2, _toConsumableArray(this._events));
      }
      this._needsUpdate = true;
    }
  }, {
    key: 'addEvents',
    value: function addEvents() {
      var _this = this;

      var track = this._track;

      for (var _len = arguments.length, events = Array(_len), _key = 0; _key < _len; _key++) {
        events[_key] = arguments[_key];
      }

      events.forEach(function (event) {
        event._part = _this;
        _this._eventsById.set(event.id, event);
        _this._events.push(event);
        if (track) {
          event._track = track;
        }
      });
      if (track) {
        var _track$_events;

        (_track$_events = track._events).push.apply(_track$_events, events);
        track._needsUpdate = true;
      }
      if (this._song) {
        var _song$_newEvents;

        (_song$_newEvents = this._song._newEvents).push.apply(_song$_newEvents, events);
      }
      this._needsUpdate = true;
    }
  }, {
    key: 'removeEvents',
    value: function removeEvents() {
      var _this2 = this;

      var track = this._track;

      for (var _len2 = arguments.length, events = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        events[_key2] = arguments[_key2];
      }

      events.forEach(function (event) {
        event._part = null;
        _this2._eventsById.delete(event.id);
        if (track) {
          event._track = null;
          track._eventsById.delete(event.id);
        }
      });
      if (track) {
        track._needsUpdate = true;
        track._createEventArray = true;
      }
      if (this._song) {
        var _song$_removedEvents;

        (_song$_removedEvents = this._song._removedEvents).push.apply(_song$_removedEvents, events);
      }
      this._createEventArray = true;
      this._needsUpdate = true;
    }
  }, {
    key: 'moveEvents',
    value: function moveEvents(ticks) {
      for (var _len3 = arguments.length, events = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        events[_key3 - 1] = arguments[_key3];
      }

      events.forEach(function (event) {
        event.move(ticks);
      });
      if (this._song) {
        var _song$_movedEvents3;

        (_song$_movedEvents3 = this._song._movedEvents).push.apply(_song$_movedEvents3, _toConsumableArray(this._events));
      }
      this._needsUpdate = true;
    }
  }, {
    key: 'moveEventsTo',
    value: function moveEventsTo(ticks) {
      for (var _len4 = arguments.length, events = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
        events[_key4 - 1] = arguments[_key4];
      }

      events.forEach(function (event) {
        event.moveTo(ticks);
      });
      if (this._song) {
        var _song$_movedEvents4;

        (_song$_movedEvents4 = this._song._movedEvents).push.apply(_song$_movedEvents4, _toConsumableArray(this._events));
      }
      this._needsUpdate = true;
    }
  }, {
    key: 'getEvents',
    value: function getEvents() {
      var filter = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
      // can be use as findEvents
      if (this._needsUpdate) {
        this.update();
      }
      return [].concat(_toConsumableArray(this._events)); //@TODO implement filter -> filterEvents() should be a utility function (not a class method)
    }
  }, {
    key: 'mute',
    value: function mute() {
      var flag = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];

      if (flag) {
        this.muted = flag;
      } else {
        this.muted = !this.muted;
      }
    }
  }, {
    key: 'update',
    value: function update() {
      if (this._needsUpdate === false) {
        return;
      }
      if (this._createEventArray) {
        this._events = Array.from(this._eventsById.values());
        this._createEventArray = false;
      }
      (0, _util.sortEvents)(this._events);
      this._needsUpdate = false;
      //@TODO: calculate part start and end, and highest and lowest note
    }
  }]);

  return Part;
}();

},{"./util":27}],18:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Playhead = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _position = require('./position.js');

var _eventlistener = require('./eventlistener.js');

var _util = require('./util.js');

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var range = 10; // milliseconds or ticks
var instanceId = 0;

var Playhead = exports.Playhead = function () {
  function Playhead(song) {
    var type = arguments.length <= 1 || arguments[1] === undefined ? 'all' : arguments[1];

    _classCallCheck(this, Playhead);

    this.id = 'POS ' + instanceId++ + ' ' + new Date().getTime();
    this.song = song;
    this.type = type;
    this.lastEvent = null;
    this.data = {};

    this.activeParts = [];
    this.activeNotes = [];
    this.activeEvents = [];
  }

  // unit can be 'millis' or 'ticks'


  _createClass(Playhead, [{
    key: 'set',
    value: function set(unit, value) {
      this.unit = unit;
      this.currentValue = value;
      this.eventIndex = 0;
      this.noteIndex = 0;
      this.partIndex = 0;
      this.calculate();
      return this.data;
    }
  }, {
    key: 'get',
    value: function get() {
      return this.data;
    }
  }, {
    key: 'update',
    value: function update(unit, diff) {
      if (diff === 0) {
        return this.data;
      }
      this.unit = unit;
      this.currentValue += diff;
      this.calculate();
      return this.data;
    }
  }, {
    key: 'updateSong',
    value: function updateSong() {
      this.events = [].concat(_toConsumableArray(this.song._events), _toConsumableArray(this.song._timeEvents));
      (0, _util.sortEvents)(this.events);
      console.log('events %O', this.events);
      this.notes = this.song._notes;
      this.parts = this.song._parts;
      this.numEvents = this.events.length;
      this.numNotes = this.notes.length;
      this.numParts = this.parts.length;
      this.set('millis', this.song._millis);
    }
  }, {
    key: 'calculate',
    value: function calculate() {
      var i = void 0;
      var value = void 0;
      var event = void 0;
      var note = void 0;
      var part = void 0;
      var position = void 0;
      var stillActiveNotes = [];
      var stillActiveParts = [];
      var collectedParts = new Set();
      var collectedNotes = new Set();

      this.data = {};
      this.activeEvents = [];

      for (i = this.eventIndex; i < this.numEvents; i++) {
        event = this.events[i];
        value = event[this.unit];
        if (value <= this.currentValue) {
          // if the playhead is set to a position of say 3000 millis, we don't want to add events more that 10 units before the playhead
          if (value === 0 || value > this.currentValue - range) {
            this.activeEvents.push(event);
            (0, _eventlistener.dispatchEvent)({
              type: 'event',
              data: event
            });
          }
          this.lastEvent = event;
          this.eventIndex++;
        } else {
          break;
        }
      }
      this.data.activeEvents = this.activeEvents;

      // if a song has no events yet, use the first time event as reference
      if (this.lastEvent === null) {
        this.lastEvent = this.song._timeEvents[0];
      }

      position = (0, _position.getPosition2)(this.song, this.unit, this.currentValue, 'all', this.lastEvent);
      this.data.eventIndex = this.eventIndex;
      this.data.millis = position.millis;
      this.data.ticks = position.ticks;
      this.data.position = position;
      (0, _eventlistener.dispatchEvent)({
        type: 'position',
        data: position
      });

      if (this.type.indexOf('all') !== -1) {
        var data = this.data;
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = Object.keys(position)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var key = _step.value;

            data[key] = position[key];
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      } else if (this.type.indexOf('barsbeats') !== -1) {
        this.data.bar = position.bar;
        this.data.beat = position.beat;
        this.data.sixteenth = position.sixteenth;
        this.data.tick = position.tick;
        this.data.barsAsString = position.barsAsString;

        this.data.ticksPerBar = position.ticksPerBar;
        this.data.ticksPerBeat = position.ticksPerBeat;
        this.data.ticksPerSixteenth = position.ticksPerSixteenth;
        this.data.numSixteenth = position.numSixteenth;
      } else if (this.type.indexOf('time') !== -1) {
        this.data.hour = position.hour;
        this.data.minute = position.minute;
        this.data.second = position.second;
        this.data.millisecond = position.millisecond;
        this.data.timeAsString = position.timeAsString;
      } else if (this.type.indexOf('percentage') !== -1) {
        this.data.percentage = position.percentage;
      }

      // get active notes
      if (this.type.indexOf('notes') !== -1 || this.type.indexOf('all') !== -1) {

        // get all notes between the noteIndex and the current playhead position
        for (i = this.noteIndex; i < this.numNotes; i++) {
          note = this.notes[i];
          value = note.noteOn[this.unit];
          if (value <= this.currentValue) {
            this.noteIndex++;
            if (typeof note.noteOff === 'undefined') {
              continue;
            }
            // if the playhead is set to a position of say 3000 millis, we don't want to add notes before the playhead
            if (this.currentValue === 0 || note.noteOff[this.unit] > this.currentValue) {
              collectedNotes.add(note);
              (0, _eventlistener.dispatchEvent)({
                type: 'noteOn',
                data: note
              });
            }
          } else {
            break;
          }
        }

        // filter notes that are no longer active
        for (i = this.activeNotes.length - 1; i >= 0; i--) {
          note = this.activeNotes[i];
          //if(note.noteOn.state.indexOf('removed') === 0 || this.song._notesById.get(note.id) === false){
          if (this.song._notesById.get(note.id) === false) {
            //console.log('skipping removed note', note.id);
            continue;
          }

          if (typeof note.noteOff === 'undefined') {
            console.warn('note with id', note.id, 'has no noteOff event');
            continue;
          }

          //if(note.noteOff[this.unit] > this.currentValue && collectedNotes.has(note) === false){
          if (note.noteOff[this.unit] > this.currentValue) {
            stillActiveNotes.push(note);
          } else {
            (0, _eventlistener.dispatchEvent)({
              type: 'noteOff',
              data: note
            });
          }
        }

        // add the still active notes and the newly active events to the active notes array
        this.activeNotes = [].concat(_toConsumableArray(collectedNotes.values()), stillActiveNotes);
        this.data.activeNotes = this.activeNotes;
      }

      // get active parts
      if (this.type.indexOf('parts') !== -1 || this.type.indexOf('all') !== -1) {

        for (i = this.partIndex; i < this.numParts; i++) {
          part = this.parts[i];
          //console.log(part, this.unit, this.currentValue);
          if (part._start[this.unit] <= this.currentValue) {
            collectedParts.add(part);
            (0, _eventlistener.dispatchEvent)({
              type: 'partOn',
              data: part
            });
            this.partIndex++;
          } else {
            break;
          }
        }

        // filter parts that are no longer active
        for (i = this.activeParts.length - 1; i >= 0; i--) {
          part = this.activeParts[i];
          //if(part.state.indexOf('removed') === 0 || this.song._partsById.get(part.id) === false){
          if (this.song._partsById.get(part.id) === false) {
            //console.log('skipping removed part', part.id);
            continue;
          }

          //if(part._end[this.unit] > this.currentValue && collectedParts.has(part) === false){
          if (part._end[this.unit] > this.currentValue) {
            stillActiveParts.push(note);
          } else {
            (0, _eventlistener.dispatchEvent)({
              type: 'partOff',
              data: part
            });
          }
        }

        this.activeParts = [].concat(_toConsumableArray(collectedParts.values()), stillActiveParts);
        this.data.activeParts = this.activeParts;
      }

      (0, _eventlistener.dispatchEvent)({
        type: 'playhead',
        data: this.data
      });
    }

    /*
      setType(t){
        this.type = t;
        this.set(this.unit, this.currentValue);
        //console.log(type,activeParts);
      }
    
    
      addType(t){
        this.type += ' ' + t;
        this.set(this.unit, this.currentValue);
        //console.log(type,activeParts);
      }
    
      removeType(t){
        var arr = this.type.split(' ');
        this.type = '';
        arr.forEach(function(type){
          if(type !== t){
            this.type += t + ' ';
          }
        });
        this.type.trim();
        this.set(this.currentValue);
        //console.log(type,activeParts);
      }
    */

  }]);

  return Playhead;
}();

},{"./eventlistener.js":4,"./position.js":19,"./util.js":27}],19:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.millisToTicks = millisToTicks;
exports.ticksToMillis = ticksToMillis;
exports.barsToMillis = barsToMillis;
exports.barsToTicks = barsToTicks;
exports.ticksToBars = ticksToBars;
exports.millisToBars = millisToBars;
exports.getPosition2 = getPosition2;
exports.calculatePosition = calculatePosition;

var _util = require('./util');

var supportedTypes = 'barsandbeats barsbeats time millis ticks perc percentage',
    supportedReturnTypes = 'barsandbeats barsbeats time millis ticks all',
    floor = Math.floor,
    round = Math.round;

var
//local
bpm = void 0,
    nominator = void 0,
    denominator = void 0,
    ticksPerBeat = void 0,
    ticksPerBar = void 0,
    ticksPerSixteenth = void 0,
    millisPerTick = void 0,
    secondsPerTick = void 0,
    numSixteenth = void 0,
    ticks = void 0,
    millis = void 0,
    diffTicks = void 0,
    diffMillis = void 0,
    bar = void 0,
    beat = void 0,
    sixteenth = void 0,
    tick = void 0,


//  type,
index = void 0,
    returnType = 'all',
    beyondEndOfSong = true;

function getTimeEvent(song, unit, target) {
  // finds the time event that comes the closest before the target position
  var timeEvents = song._timeEvents;

  for (var i = timeEvents.length - 1; i >= 0; i--) {
    var event = timeEvents[i];
    if (event[unit] <= target) {
      index = i;
      return event;
    }
  }
  return null;
}

function millisToTicks(song, targetMillis) {
  var beos = arguments.length <= 2 || arguments[2] === undefined ? true : arguments[2];

  beyondEndOfSong = beos;
  fromMillis(song, targetMillis);
  //return round(ticks);
  return ticks;
}

function ticksToMillis(song, targetTicks) {
  var beos = arguments.length <= 2 || arguments[2] === undefined ? true : arguments[2];

  beyondEndOfSong = beos;
  fromTicks(song, targetTicks);
  return millis;
}

function barsToMillis(song, position, beos) {
  // beos = beyondEndOfSong
  calculatePosition(song, {
    type: 'barsbeat',
    position: position,
    result: 'millis',
    beos: beos
  });
  return millis;
}

function barsToTicks(song, position, beos) {
  // beos = beyondEndOfSong
  calculatePosition(song, {
    type: 'barsbeats',
    position: position,
    result: 'ticks',
    beos: beos
  });
  //return round(ticks);
  return ticks;
}

function ticksToBars(song, target) {
  var beos = arguments.length <= 2 || arguments[2] === undefined ? true : arguments[2];

  beyondEndOfSong = beos;
  fromTicks(song, target);
  calculateBarsAndBeats();
  returnType = 'barsandbeats';
  return getPositionData();
}

function millisToBars(song, target) {
  var beos = arguments.length <= 2 || arguments[2] === undefined ? true : arguments[2];

  beyondEndOfSong = beos;
  fromMillis(song, target);
  calculateBarsAndBeats();
  returnType = 'barsandbeats';
  return getPositionData();
}

// main calculation function for millis position
function fromMillis(song, targetMillis, event) {
  var lastEvent = song._lastEvent;

  if (beyondEndOfSong === false) {
    if (targetMillis > lastEvent.millis) {
      targetMillis = lastEvent.millis;
    }
  }

  if (typeof event === 'undefined') {
    event = getTimeEvent(song, 'millis', targetMillis);
  }
  getDataFromEvent(event);

  // if the event is not exactly at target millis, calculate the diff
  if (event.millis === targetMillis) {
    diffMillis = 0;
    diffTicks = 0;
  } else {
    diffMillis = targetMillis - event.millis;
    diffTicks = diffMillis / millisPerTick;
  }

  millis += diffMillis;
  ticks += diffTicks;

  return ticks;
}

// main calculation function for ticks position
function fromTicks(song, targetTicks, event) {
  var lastEvent = song._lastEvent;

  if (beyondEndOfSong === false) {
    if (targetTicks > lastEvent.ticks) {
      targetTicks = lastEvent.ticks;
    }
  }

  if (typeof event === 'undefined') {
    event = getTimeEvent(song, 'ticks', targetTicks);
  }
  getDataFromEvent(event);

  // if the event is not exactly at target ticks, calculate the diff
  if (event.ticks === targetTicks) {
    diffTicks = 0;
    diffMillis = 0;
  } else {
    diffTicks = targetTicks - ticks;
    diffMillis = diffTicks * millisPerTick;
  }

  ticks += diffTicks;
  millis += diffMillis;

  return millis;
}

// main calculation function for bars and beats position
function fromBars(song, targetBar, targetBeat, targetSixteenth, targetTick) {
  var event = arguments.length <= 5 || arguments[5] === undefined ? null : arguments[5];

  //console.time('fromBars');
  var i = 0,
      diffBars = void 0,
      diffBeats = void 0,
      diffSixteenth = void 0,
      diffTick = void 0,
      lastEvent = song._lastEvent;

  if (beyondEndOfSong === false) {
    if (targetBar > lastEvent.bar) {
      targetBar = lastEvent.bar;
    }
  }

  if (event === null) {
    event = getTimeEvent(song, 'bar', targetBar);
  }
  //console.log(event)
  getDataFromEvent(event);

  //correct wrong position data, for instance: '3,3,2,788' becomes '3,4,4,068' in a 4/4 measure at PPQ 480
  while (targetTick >= ticksPerSixteenth) {
    targetSixteenth++;
    targetTick -= ticksPerSixteenth;
  }

  while (targetSixteenth > numSixteenth) {
    targetBeat++;
    targetSixteenth -= numSixteenth;
  }

  while (targetBeat > nominator) {
    targetBar++;
    targetBeat -= nominator;
  }

  event = getTimeEvent(song, 'bar', targetBar, index);
  for (i = index; i >= 0; i--) {
    event = song._timeEvents[i];
    if (event.bar <= targetBar) {
      getDataFromEvent(event);
      break;
    }
  }

  // get the differences
  diffTick = targetTick - tick;
  diffSixteenth = targetSixteenth - sixteenth;
  diffBeats = targetBeat - beat;
  diffBars = targetBar - bar; //bar is always less then or equal to targetBar, so diffBars is always >= 0

  //console.log('diff',diffBars,diffBeats,diffSixteenth,diffTick);
  //console.log('millis',millis,ticksPerBar,ticksPerBeat,ticksPerSixteenth,millisPerTick);

  // convert differences to milliseconds and ticks
  diffMillis = diffBars * ticksPerBar * millisPerTick;
  diffMillis += diffBeats * ticksPerBeat * millisPerTick;
  diffMillis += diffSixteenth * ticksPerSixteenth * millisPerTick;
  diffMillis += diffTick * millisPerTick;
  diffTicks = diffMillis / millisPerTick;
  //console.log(diffBars, ticksPerBar, millisPerTick, diffMillis, diffTicks);

  // set all current position data
  bar = targetBar;
  beat = targetBeat;
  sixteenth = targetSixteenth;
  tick = targetTick;
  //console.log(tick, targetTick)

  millis += diffMillis;
  //console.log(targetBar, targetBeat, targetSixteenth, targetTick, ' -> ', millis);
  ticks += diffTicks;

  //console.timeEnd('fromBars');
}

function calculateBarsAndBeats() {
  // spread the difference in tick over bars, beats and sixteenth
  var tmp = round(diffTicks);
  while (tmp >= ticksPerSixteenth) {
    sixteenth++;
    tmp -= ticksPerSixteenth;
    while (sixteenth > numSixteenth) {
      sixteenth -= numSixteenth;
      beat++;
      while (beat > nominator) {
        beat -= nominator;
        bar++;
      }
    }
  }
  tick = round(tmp);
}

// store properties of event in local scope
function getDataFromEvent(event) {

  bpm = event.bpm;
  nominator = event.nominator;
  denominator = event.denominator;

  ticksPerBar = event.ticksPerBar;
  ticksPerBeat = event.ticksPerBeat;
  ticksPerSixteenth = event.ticksPerSixteenth;
  numSixteenth = event.numSixteenth;
  millisPerTick = event.millisPerTick;
  secondsPerTick = event.secondsPerTick;

  bar = event.bar;
  beat = event.beat;
  sixteenth = event.sixteenth;
  tick = event.tick;

  ticks = event.ticks;
  millis = event.millis;

  //console.log(bpm, event.type);
  //console.log('ticks', ticks, 'millis', millis, 'bar', bar);
}

function getPositionData(song) {
  var timeData = void 0,
      positionData = {};

  switch (returnType) {

    case 'millis':
      //positionData.millis = millis;
      positionData.millis = round(millis * 1000) / 1000;
      positionData.millisRounded = round(millis);
      break;

    case 'ticks':
      //positionData.ticks = ticks;
      positionData.ticks = round(ticks);
      //positionData.ticksUnrounded = ticks;
      break;

    case 'barsbeats':
    case 'barsandbeats':
      positionData.bar = bar;
      positionData.beat = beat;
      positionData.sixteenth = sixteenth;
      positionData.tick = tick;
      //positionData.barsAsString = (bar + 1) + ':' + (beat + 1) + ':' + (sixteenth + 1) + ':' + tickAsString;
      positionData.barsAsString = bar + ':' + beat + ':' + sixteenth + ':' + getTickAsString(tick);
      break;

    case 'time':
      timeData = (0, _util.getNiceTime)(millis);
      positionData.hour = timeData.hour;
      positionData.minute = timeData.minute;
      positionData.second = timeData.second;
      positionData.millisecond = timeData.millisecond;
      positionData.timeAsString = timeData.timeAsString;
      break;

    case 'all':
      // millis
      //positionData.millis = millis;
      positionData.millis = round(millis * 1000) / 1000;
      positionData.millisRounded = round(millis);

      // ticks
      //positionData.ticks = ticks;
      positionData.ticks = round(ticks);
      //positionData.ticksUnrounded = ticks;

      // barsbeats
      positionData.bar = bar;
      positionData.beat = beat;
      positionData.sixteenth = sixteenth;
      positionData.tick = tick;
      //positionData.barsAsString = (bar + 1) + ':' + (beat + 1) + ':' + (sixteenth + 1) + ':' + tickAsString;
      positionData.barsAsString = bar + ':' + beat + ':' + sixteenth + ':' + getTickAsString(tick);

      // time
      timeData = (0, _util.getNiceTime)(millis);
      positionData.hour = timeData.hour;
      positionData.minute = timeData.minute;
      positionData.second = timeData.second;
      positionData.millisecond = timeData.millisecond;
      positionData.timeAsString = timeData.timeAsString;

      // extra data
      positionData.bpm = round(bpm * song.playbackSpeed, 3);
      positionData.nominator = nominator;
      positionData.denominator = denominator;

      positionData.ticksPerBar = ticksPerBar;
      positionData.ticksPerBeat = ticksPerBeat;
      positionData.ticksPerSixteenth = ticksPerSixteenth;

      positionData.numSixteenth = numSixteenth;
      positionData.millisPerTick = millisPerTick;
      positionData.secondsPerTick = secondsPerTick;

      // use ticks to make tempo changes visible by a faster moving playhead
      positionData.percentage = ticks / song._durationTicks;
      //positionData.percentage = millis / song.durationMillis;
      break;
    default:
      return null;
  }

  return positionData;
}

function getTickAsString(t) {
  if (t === 0) {
    t = '000';
  } else if (t < 10) {
    t = '00' + t;
  } else if (t < 100) {
    t = '0' + t;
  }
  return t;
}

// used by playhead
function getPosition2(song, unit, target, type, event) {
  if (unit === 'millis') {
    fromMillis(song, target, event);
  } else if (unit === 'ticks') {
    fromTicks(song, target, event);
  }
  if (type === 'all') {
    calculateBarsAndBeats();
  }
  return getPositionData(song);
}

// improved version of getPosition
function calculatePosition(song, settings) {
  var type = settings.type;
  var // any of barsandbeats barsbeats time millis ticks perc percentage
  target = settings.target;
  var _settings$result = settings.result;
  var result = _settings$result === undefined ? 'all' : _settings$result;
  var _settings$beos = settings.beos;
  var beos = _settings$beos === undefined ? true : _settings$beos;
  var _settings$snap = settings.snap;
  var snap = _settings$snap === undefined ? -1 : _settings$snap;


  if (supportedReturnTypes.indexOf(result) === -1) {
    console.warn('unsupported return type, \'all\' used instead of \'' + result + '\'');
    result = 'all';
  }

  returnType = result;
  beyondEndOfSong = beos;

  if (supportedTypes.indexOf(type) === -1) {
    console.error('unsupported type ' + type);
    return false;
  }

  switch (type) {

    case 'barsbeats':
    case 'barsandbeats':
      var _target = _slicedToArray(target, 4);

      var _target$ = _target[0];
      var targetbar = _target$ === undefined ? 1 : _target$;
      var _target$2 = _target[1];
      var targetbeat = _target$2 === undefined ? 1 : _target$2;
      var _target$3 = _target[2];
      var targetsixteenth = _target$3 === undefined ? 1 : _target$3;
      var _target$4 = _target[3];
      var targettick = _target$4 === undefined ? 0 : _target$4;
      //console.log(targetbar, targetbeat, targetsixteenth, targettick)

      fromBars(song, targetbar, targetbeat, targetsixteenth, targettick);
      return getPositionData(song);

    case 'time':
      // calculate millis out of time array: hours, minutes, seconds, millis

      var _target2 = _slicedToArray(target, 4);

      var _target2$ = _target2[0];
      var targethour = _target2$ === undefined ? 0 : _target2$;
      var _target2$2 = _target2[1];
      var targetminute = _target2$2 === undefined ? 0 : _target2$2;
      var _target2$3 = _target2[2];
      var targetsecond = _target2$3 === undefined ? 0 : _target2$3;
      var _target2$4 = _target2[3];
      var targetmillisecond = _target2$4 === undefined ? 0 : _target2$4;

      var millis = 0;
      millis += targethour * 60 * 60 * 1000; //hours
      millis += targetminute * 60 * 1000; //minutes
      millis += targetsecond * 1000; //seconds
      millis += targetmillisecond; //milliseconds

      fromMillis(song, millis);
      calculateBarsAndBeats();
      return getPositionData(song);

    case 'millis':
      fromMillis(song, target);
      calculateBarsAndBeats();
      return getPositionData(song);

    case 'ticks':
      fromTicks(song, target);
      calculateBarsAndBeats();
      return getPositionData(song);

    case 'perc':
    case 'percentage':

      //millis = position[1] * song.durationMillis;
      //fromMillis(song, millis);
      //console.log(millis);

      ticks = target * song._durationTicks; // target must be in ticks!
      //console.log(ticks, song._durationTicks)
      if (snap !== -1) {
        ticks = floor(ticks / snap) * snap;
        //fromTicks(song, ticks);
        //console.log(ticks);
      }
      fromTicks(song, ticks);
      calculateBarsAndBeats();
      var tmp = getPositionData(song);
      //console.log('diff', position[1] - tmp.percentage);
      return tmp;

    default:
      return false;
  }
}

/*

//@param: 'millis', 1000, [true]
//@param: 'ticks', 1000, [true]
//@param: 'barsandbeats', 1, ['all', true]
//@param: 'barsandbeats', 60, 4, 3, 120, ['all', true]
//@param: 'barsandbeats', 60, 4, 3, 120, [true, 'all']

function checkPosition(type, args, returnType = 'all'){
  beyondEndOfSong = true;
  console.log('----> checkPosition:', args, typeString(args));

  if(typeString(args) === 'array'){
    let
      numArgs = args.length,
      position,
      i, a, positionLength;

    type = args[0];

    // support for [['millis', 3000]]
    if(typeString(args[0]) === 'array'){
      //console.warn('this shouldn\'t happen!');
      args = args[0];
      type = args[0];
      numArgs = args.length;
    }

    position = [type];

    console.log('check position', args, numArgs, supportedTypes.indexOf(type));

    //console.log('arg', 0, '->', type);

    if(supportedTypes.indexOf(type) !== -1){
      for(i = 1; i < numArgs; i++){
        a = args[i];
        //console.log('arg', i, '->', a);
        if(a === true || a === false){
          beyondEndOfSong = a;
        }else if(isNaN(a)){
          if(supportedReturnTypes.indexOf(a) !== -1){
            returnType = a;
          }else{
            return false;
          }
        }else {
          position.push(a);
        }
      }
      //check number of arguments -> either 1 number or 4 numbers in position, e.g. ['barsbeats', 1] or ['barsbeats', 1, 1, 1, 0],
      // or ['perc', 0.56, numberOfTicksToSnapTo]
      positionLength = position.length;
      if(positionLength !== 2 && positionLength !== 3 && positionLength !== 5){
        return false;
      }
      //console.log(position, returnType, beyondEndOfSong);
      //console.log('------------------------------------')
      return position;
    }
  }
  return false;
}


export function getPosition(song, type, args){
  //console.log('getPosition', args);

  if(typeof args === 'undefined'){
    return {
      millis: 0
    }
  }

  let position = checkPosition(type, args),
    millis, tmp, snap;


  if(position === false){
    error('wrong position data');
    return false;
  }

  switch(type){

    case 'barsbeats':
    case 'barsandbeats':
      fromBars(song, position[1], position[2], position[3], position[4]);
      return getPositionData(song);

    case 'time':
      // calculate millis out of time array: hours, minutes, seconds, millis
      millis = 0;
      tmp = position[1] || 0;
      millis += tmp * 60 * 60 * 1000; //hours
      tmp = position[2] || 0;
      millis += tmp * 60 * 1000; //minutes
      tmp = position[3] || 0;
      millis += tmp * 1000; //seconds
      tmp = position[4] || 0;
      millis += tmp; //milliseconds

      fromMillis(song, millis);
      calculateBarsAndBeats();
      return getPositionData(song);

    case 'millis':
      fromMillis(song, position[1]);
      calculateBarsAndBeats();
      return getPositionData(song);

    case 'ticks':
      fromTicks(song, position[1]);
      calculateBarsAndBeats();
      return getPositionData(song);

    case 'perc':
    case 'percentage':
      snap = position[2];

      //millis = position[1] * song.durationMillis;
      //fromMillis(song, millis);
      //console.log(millis);

      ticks = position[1] * song.durationTicks;
      if(snap !== undefined){
        ticks = floor(ticks/snap) * snap;
        //fromTicks(song, ticks);
        //console.log(ticks);
      }
      fromTicks(song, ticks);
      calculateBarsAndBeats();
      tmp = getPositionData(song);
      //console.log('diff', position[1] - tmp.percentage);
      return tmp;
  }
  return false;
}

*/

},{"./util":27}],20:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseMIDIFile = exports.Instrument = exports.Part = exports.Track = exports.Song = exports.MIDINote = exports.MIDIEvent = exports.parseSamples = exports.getMIDIOutputsById = exports.getMIDIInputsById = exports.getMIDIOutputIds = exports.getMIDIInputIds = exports.getMIDIOutputs = exports.getMIDIInputs = exports.getMIDIAccess = exports.setMasterVolume = exports.getMasterVolume = exports.getAudioContext = exports.init = undefined;

var _midi_event = require('./midi_event');

var _midi_note = require('./midi_note');

var _part = require('./part');

var _track = require('./track');

var _instrument = require('./instrument');

var _song = require('./song');

var _midifile = require('./midifile');

var _init = require('./init');

var _init_audio = require('./init_audio');

var _init_midi = require('./init_midi');

var _parse_audio = require('./parse_audio');

var getAudioContext = function getAudioContext() {
  return _init_audio.context;
};

var qambi = {
  version: '1.0.0-beta2',

  // from ./util
  parseSamples: _parse_audio.parseSamples,

  // from ./init
  init: _init.init,

  // from ./init_audio
  getAudioContext: getAudioContext,
  getMasterVolume: _init_audio.getMasterVolume,
  setMasterVolume: _init_audio.setMasterVolume,

  // ./init_midi
  getMIDIAccess: _init_midi.getMIDIAccess,
  getMIDIInputs: _init_midi.getMIDIInputs,
  getMIDIOutputs: _init_midi.getMIDIOutputs,
  getMIDIInputIds: _init_midi.getMIDIInputIds,
  getMIDIOutputIds: _init_midi.getMIDIOutputIds,
  getMIDIInputsById: _init_midi.getMIDIInputsById,
  getMIDIOutputsById: _init_midi.getMIDIOutputsById,

  // from ./midi_event
  MIDIEvent: _midi_event.MIDIEvent,

  // from ./midi_note
  MIDINote: _midi_note.MIDINote,

  // from ./song
  Song: _song.Song,

  // from ./track
  Track: _track.Track,

  // from ./part
  Part: _part.Part,

  // from ./instrument
  Instrument: _instrument.Instrument,

  parseMIDIFile: _midifile.parseMIDIFile,

  log: function log(id) {
    switch (id) {
      case 'functions':
        console.log('functions:\n          createMIDIEvent\n          moveMIDIEvent\n          moveMIDIEventTo\n          createMIDINote\n          createSong\n          addTracks\n          createTrack\n          addParts\n          createPart\n          addMIDIEvents\n        ');
        break;
      default:
    }
  }
};

// standard MIDI events
//const MIDI = {}
Object.defineProperty(qambi, 'NOTE_OFF', { value: 0x80 }); //128
Object.defineProperty(qambi, 'NOTE_ON', { value: 0x90 }); //144
Object.defineProperty(qambi, 'POLY_PRESSURE', { value: 0xA0 }); //160
Object.defineProperty(qambi, 'CONTROL_CHANGE', { value: 0xB0 }); //176
Object.defineProperty(qambi, 'PROGRAM_CHANGE', { value: 0xC0 }); //192
Object.defineProperty(qambi, 'CHANNEL_PRESSURE', { value: 0xD0 }); //208
Object.defineProperty(qambi, 'PITCH_BEND', { value: 0xE0 }); //224
Object.defineProperty(qambi, 'SYSTEM_EXCLUSIVE', { value: 0xF0 }); //240
Object.defineProperty(qambi, 'MIDI_TIMECODE', { value: 241 });
Object.defineProperty(qambi, 'SONG_POSITION', { value: 242 });
Object.defineProperty(qambi, 'SONG_SELECT', { value: 243 });
Object.defineProperty(qambi, 'TUNE_REQUEST', { value: 246 });
Object.defineProperty(qambi, 'EOX', { value: 247 });
Object.defineProperty(qambi, 'TIMING_CLOCK', { value: 248 });
Object.defineProperty(qambi, 'START', { value: 250 });
Object.defineProperty(qambi, 'CONTINUE', { value: 251 });
Object.defineProperty(qambi, 'STOP', { value: 252 });
Object.defineProperty(qambi, 'ACTIVE_SENSING', { value: 254 });
Object.defineProperty(qambi, 'SYSTEM_RESET', { value: 255 });

Object.defineProperty(qambi, 'TEMPO', { value: 0x51 });
Object.defineProperty(qambi, 'TIME_SIGNATURE', { value: 0x58 });
Object.defineProperty(qambi, 'END_OF_TRACK', { value: 0x2F });

exports.default = qambi;
exports.
// from ./init
init = _init.init;
exports.

// from ./init_audio
getAudioContext = getAudioContext;
exports.getMasterVolume = _init_audio.getMasterVolume;
exports.setMasterVolume = _init_audio.setMasterVolume;
exports.

// ./init_midi
getMIDIAccess = _init_midi.getMIDIAccess;
exports.getMIDIInputs = _init_midi.getMIDIInputs;
exports.getMIDIOutputs = _init_midi.getMIDIOutputs;
exports.getMIDIInputIds = _init_midi.getMIDIInputIds;
exports.getMIDIOutputIds = _init_midi.getMIDIOutputIds;
exports.getMIDIInputsById = _init_midi.getMIDIInputsById;
exports.getMIDIOutputsById = _init_midi.getMIDIOutputsById;
exports.

// from ./util
parseSamples = _parse_audio.parseSamples;
exports.

// from ./midi_event
MIDIEvent = _midi_event.MIDIEvent;
exports.

// from ./midi_note
MIDINote = _midi_note.MIDINote;
exports.

// from ./song
Song = _song.Song;
exports.

// from ./track
Track = _track.Track;
exports.

// from ./part
Part = _part.Part;
exports.

// from ./instrument
Instrument = _instrument.Instrument;
exports.

//  MIDI,

parseMIDIFile = _midifile.parseMIDIFile;

},{"./init":6,"./init_audio":7,"./init_midi":8,"./instrument":9,"./midi_event":10,"./midi_note":11,"./midifile":13,"./parse_audio":15,"./part":17,"./song":24,"./track":26}],21:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.fadeOut = fadeOut;
exports.createSample = createSample;

var _init_audio = require('./init_audio.js');

var _util = require('./util.js');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Sample = function () {
  function Sample(sampleData, event) {
    _classCallCheck(this, Sample);

    this.event = event;
    this.sampleData = sampleData;

    if (this.sampleData === -1 || typeof this.sampleData === 'undefined' || typeof this.sampleData.buffer === 'undefined') {
      if (typeof this.sampleData === 'undefined') {
        console.error('[SAMPLE]', event);
      }
      // create simple synth sample
      this.source = _init_audio.context.createOscillator();
      this.source.type = 'sine';
      this.source.frequency.value = event.frequency;
    } else {
      this.source = _init_audio.context.createBufferSource();
      this.source.buffer = sampleData.buffer;
      //console.log(this.source.buffer)
    }
    this.output = _init_audio.context.createGain();
    this.volume = event.data2 / 127;
    this.output.gain.value = this.volume;
    this.source.connect(this.output);
    //this.output.connect(context.destination)
  }

  _createClass(Sample, [{
    key: 'start',
    value: function start(time) {
      //console.log(this.source);
      this.source.start(time);
    }
  }, {
    key: 'stop',
    value: function stop(time, cb) {
      if (typeof this.sampleData === 'undefined') {
        console.log(this.source);
        console.error('[SAMPLE]', event);
      }

      var _sampleData = this.sampleData;
      var releaseDuration = _sampleData.releaseDuration;
      var releaseEnvelope = _sampleData.releaseEnvelope;
      var releaseEnvelopeArray = _sampleData.releaseEnvelopeArray;

      if (releaseDuration && releaseEnvelope) {
        this.source.stop(time + releaseDuration);
        fadeOut(this.output, {
          releaseDuration: releaseDuration,
          releaseEnvelope: releaseEnvelope,
          releaseEnvelopeArray: releaseEnvelopeArray
        });
      } else {
        this.source.stop(time);
      }

      this.source.onended = cb;
    }
  }]);

  return Sample;
}();

function fadeOut(gainNode, settings) {
  var now = _init_audio.context.currentTime;
  var values = void 0,
      i = void 0,
      maxi = void 0;

  //console.log(settings.releaseEnvelope)
  switch (settings.releaseEnvelope) {

    case 'linear':
      gainNode.gain.linearRampToValueAtTime(gainNode.gain.value, now);
      gainNode.gain.linearRampToValueAtTime(0, now + settings.releaseDuration);
      break;

    case 'equal_power':
      values = (0, _util.getEqualPowerCurve)(100, 'fadeOut', gainNode.gain.value);
      gainNode.gain.setValueCurveAtTime(values, now, settings.releaseDuration);
      break;

    case 'array':
      maxi = settings.releaseEnvelopeArray.length;
      values = new Float32Array(maxi);
      for (i = 0; i < maxi; i++) {
        values[i] = settings.releaseEnvelopeArray[i] * gainNode.gain.value;
      }
      gainNode.gain.setValueCurveAtTime(values, now, settings.releaseDuration);
      break;

    default:
  }
}

function createSample() {
  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return new (Function.prototype.bind.apply(Sample, [null].concat(args)))();
}

},{"./init_audio.js":7,"./util.js":27}],22:[function(require,module,exports){
module.exports={
  "emptyOgg": "T2dnUwACAAAAAAAAAABdxd4XAAAAADaS0jQBHgF2b3JiaXMAAAAAAUSsAAAAAAAAgLsAAAAAAAC4AU9nZ1MAAAAAAAAAAAAAXcXeFwEAAAAaXK+QDz3/////////////////MgN2b3JiaXMtAAAAWGlwaC5PcmcgbGliVm9yYmlzIEkgMjAxMDExMDEgKFNjaGF1ZmVudWdnZXQpAAAAAAEFdm9yYmlzH0JDVgEAAAEAGGNUKUaZUtJKiRlzlDFGmWKSSomlhBZCSJ1zFFOpOdeca6y5tSCEEBpTUCkFmVKOUmkZY5ApBZlSEEtJJXQSOiedYxBbScHWmGuLQbYchA2aUkwpxJRSikIIGVOMKcWUUkpCByV0DjrmHFOOSihBuJxzq7WWlmOLqXSSSuckZExCSCmFkkoHpVNOQkg1ltZSKR1zUlJqQegghBBCtiCEDYLQkFUAAAEAwEAQGrIKAFAAABCKoRiKAoSGrAIAMgAABKAojuIojiM5kmNJFhAasgoAAAIAEAAAwHAUSZEUybEkS9IsS9NEUVV91TZVVfZ1Xdd1Xdd1IDRkFQAAAQBASKeZpRogwgxkGAgNWQUAIAAAAEYowhADQkNWAQAAAQAAYig5iCa05nxzjoNmOWgqxeZ0cCLV5kluKubmnHPOOSebc8Y455xzinJmMWgmtOaccxKDZiloJrTmnHOexOZBa6q05pxzxjmng3FGGOecc5q05kFqNtbmnHMWtKY5ai7F5pxzIuXmSW0u1eacc84555xzzjnnnHOqF6dzcE4455xzovbmWm5CF+eccz4Zp3tzQjjnnHPOOeecc84555xzgtCQVQAAEAAAQRg2hnGnIEifo4EYRYhpyKQH3aPDJGgMcgqpR6OjkVLqIJRUxkkpnSA0ZBUAAAgAACGEFFJIIYUUUkghhRRSiCGGGGLIKaecggoqqaSiijLKLLPMMssss8wy67CzzjrsMMQQQwyttBJLTbXVWGOtueecaw7SWmmttdZKKaWUUkopCA1ZBQCAAAAQCBlkkEFGIYUUUoghppxyyimooAJCQ1YBAIAAAAIAAAA8yXNER3RER3RER3RER3REx3M8R5RESZRESbRMy9RMTxVV1ZVdW9Zl3fZtYRd23fd13/d149eFYVmWZVmWZVmWZVmWZVmWZVmC0JBVAAAIAACAEEIIIYUUUkghpRhjzDHnoJNQQiA0ZBUAAAgAIAAAAMBRHMVxJEdyJMmSLEmTNEuzPM3TPE30RFEUTdNURVd0Rd20RdmUTdd0Tdl0VVm1XVm2bdnWbV+Wbd/3fd/3fd/3fd/3fd/3dR0IDVkFAEgAAOhIjqRIiqRIjuM4kiQBoSGrAAAZAAABACiKoziO40iSJEmWpEme5VmiZmqmZ3qqqAKhIasAAEAAAAEAAAAAACia4imm4imi4jmiI0qiZVqipmquKJuy67qu67qu67qu67qu67qu67qu67qu67qu67qu67qu67qu67ouEBqyCgCQAADQkRzJkRxJkRRJkRzJAUJDVgEAMgAAAgBwDMeQFMmxLEvTPM3TPE30RE/0TE8VXdEFQkNWAQCAAAACAAAAAAAwJMNSLEdzNEmUVEu1VE21VEsVVU9VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVU1TdM0TSA0ZCUAAAQAwGKNweUgISUl5d4QwhCTnjEmIbVeIQSRkt4xBhWDnjKiDHLeQuMQgx4IDVkRAEQBAADGIMcQc8g5R6mTEjnnqHSUGuccpY5SZynFmGLNKJXYUqyNc45SR62jlGIsLXaUUo2pxgIAAAIcAAACLIRCQ1YEAFEAAIQxSCmkFGKMOaecQ4wp55hzhjHmHHOOOeegdFIq55x0TkrEGHOOOaecc1I6J5VzTkonoQAAgAAHAIAAC6HQkBUBQJwAgEGSPE/yNFGUNE8URVN0XVE0XdfyPNX0TFNVPdFUVVNVbdlUVVmWPM80PdNUVc80VdVUVVk2VVWWRVXVbdN1ddt0Vd2Wbdv3XVsWdlFVbd1UXds3Vdf2Xdn2fVnWdWPyPFX1TNN1PdN0ZdV1bVt1XV33TFOWTdeVZdN1bduVZV13Zdn3NdN0XdNVZdl0Xdl2ZVe3XVn2fdN1hd+VZV9XZVkYdl33hVvXleV0Xd1XZVc3Vln2fVvXheHWdWGZPE9VPdN0Xc80XVd1XV9XXdfWNdOUZdN1bdlUXVl2Zdn3XVfWdc80Zdl0Xds2XVeWXVn2fVeWdd10XV9XZVn4VVf2dVnXleHWbeE3Xdf3VVn2hVeWdeHWdWG5dV0YPlX1fVN2heF0Zd/Xhd9Zbl04ltF1fWGVbeFYZVk5fuFYlt33lWV0XV9YbdkYVlkWhl/4neX2feN4dV0Zbt3nzLrvDMfvpPvK09VtY5l93VlmX3eO4Rg6v/Djqaqvm64rDKcsC7/t68az+76yjK7r+6osC78q28Kx677z/L6wLKPs+sJqy8Kw2rYx3L5uLL9wHMtr68ox675RtnV8X3gKw/N0dV15Zl3H9nV040c4fsoAAIABBwCAABPKQKEhKwKAOAEAjySJomRZoihZliiKpui6omi6rqRppqlpnmlammeapmmqsimarixpmmlanmaamqeZpmiarmuapqyKpinLpmrKsmmasuy6sm27rmzbomnKsmmasmyapiy7sqvbruzquqRZpql5nmlqnmeapmrKsmmarqt5nmp6nmiqniiqqmqqqq2qqixbnmeamuippieKqmqqpq2aqirLpqrasmmqtmyqqm27quz6sm3rummqsm2qpi2bqmrbruzqsizbui9pmmlqnmeamueZpmmasmyaqitbnqeaniiqquaJpmqqqiybpqrKlueZqieKquqJnmuaqirLpmraqmmatmyqqi2bpirLrm37vuvKsm6qqmybqmrrpmrKsmzLvu/Kqu6KpinLpqrasmmqsi3bsu/Lsqz7omnKsmmqsm2qqi7Lsm0bs2z7umiasm2qpi2bqirbsi37uizbuu/Krm+rqqzrsi37uu76rnDrujC8smz7qqz6uivbum/rMtv2fUTTlGVTNW3bVFVZdmXZ9mXb9n3RNG1bVVVbNk3VtmVZ9n1Ztm1hNE3ZNlVV1k3VtG1Zlm1htmXhdmXZt2Vb9nXXlXVf133j12Xd5rqy7cuyrfuqq/q27vvCcOuu8AoAABhwAAAIMKEMFBqyEgCIAgAAjGGMMQiNUs45B6FRyjnnIGTOQQghlcw5CCGUkjkHoZSUMucglJJSCKGUlFoLIZSUUmsFAAAUOAAABNigKbE4QKEhKwGAVAAAg+NYlueZomrasmNJnieKqqmqtu1IlueJommqqm1bnieKpqmqruvrmueJommqquvqumiapqmqruu6ui6aoqmqquu6sq6bpqqqriu7suzrpqqqquvKriz7wqq6rivLsm3rwrCqruvKsmzbtm/cuq7rvu/7wpGt67ou/MIxDEcBAOAJDgBABTasjnBSNBZYaMhKACADAIAwBiGDEEIGIYSQUkohpZQSAAAw4AAAEGBCGSg0ZEUAECcAABhDKaSUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJIKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKqaSUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKZVSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUgoAkIpwAJB6MKEMFBqyEgBIBQAAjFFKKcacgxAx5hhj0EkoKWLMOcYclJJS5RyEEFJpLbfKOQghpNRSbZlzUlqLMeYYM+ekpBRbzTmHUlKLseaaa+6ktFZrrjXnWlqrNdecc825tBZrrjnXnHPLMdecc8455xhzzjnnnHPOBQDgNDgAgB7YsDrCSdFYYKEhKwGAVAAAAhmlGHPOOegQUow55xyEECKFGHPOOQghVIw55xx0EEKoGHPMOQghhJA55xyEEEIIIXMOOugghBBCBx2EEEIIoZTOQQghhBBKKCGEEEIIIYQQOgghhBBCCCGEEEIIIYRSSgghhBBCCaGUUAAAYIEDAECADasjnBSNBRYashIAAAIAgByWoFLOhEGOQY8NQcpRMw1CTDnRmWJOajMVU5A5EJ10EhlqQdleMgsAAIAgACDABBAYICj4QgiIMQAAQYjMEAmFVbDAoAwaHOYBwANEhEQAkJigSLu4gC4DXNDFXQdCCEIQglgcQAEJODjhhife8IQbnKBTVOogAAAAAAAMAOABAOCgACIimquwuMDI0Njg6PAIAAAAAAAWAPgAADg+gIiI5iosLjAyNDY4OjwCAAAAAAAAAACAgIAAAAAAAEAAAACAgE9nZ1MABAEAAAAAAAAAXcXeFwIAAABq2npxAgEBAAo=",
  "emptyMp3": "//sQxAADwAABpAAAACAAADSAAAAETEFNRTMuOTkuNVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVU=",
  "hightick": "UklGRkQFAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YSAFAACx/xf/dADOACwBsP3p+6H+zAGoBOkCCwBX/EH5OvxlA4kJ2wcSArT9E/ut+HT2evUx98n6OAF5CCUMwQvfCOsJxAx0DSIMEAq9BiAB3vhz7mLkT9sR133YxN2s5QLv0vrUBnwRnxuQJeEsSDCiMd8yFS8aKFIhohUsCKj64u625OraA9HuyPnElcP+wxvJWtW25637VQ0jHPgnBTDDM1o0CzKLK+8hzhgFDOz8Se4J47DYVtG0z5fQq9LB12rfA+j99roHAhelIyMwIjdTOuU8mjwIOGoxhCb5E53/j+3k3/fTY8pTw4y/Tr+ew8DMvdsk8RcHRRkSKO4yGTkHPkU/rzzyNcgsrR94Dp/5r+Zs17zOncoDxhfE38WLyn/TeOMi9r0IRxlRKIQzyTlOPKo9yjmWMcokDRLc/Y7rudtdzu/D2L1Iu+27JcG3yYrVLujl+3UOZx1UK5Q0qzmNPDk8ZjeeMPojzhH+/jLtPd5m0hHLHsYIw5TEMMnA0jvj8fSOBiwXASZgMzM8dUBGQbI+rzjpKkIZygZT9QflcdaRyqXCz7+VwUPH784r3K7s+v0KDu8bvyeLMb43NjrhOIo0dSvQHi0PnP6i7ovg3NTxy4/Gf8X8yH/QBtvX55P2Ygb0FcUjsy4LNmI5ejiXM38r7iC8FJwHPvok7dDgQdaJzlTKIsoFzsrVkuA87d/6qAi7FQ0h9ClKMLEz3TOrMBcqYSD8E9AFd/dS6kTf6dbU0XnQv9IH2MXfZ+ln9DEAFwwdFy8giib6KawqeChgI/UbHBOTCZj/vvXe7InlFuDN3P3b0d1F4gzpifG2+u4D7Qw1FfwbnCD+IlgjWyHLHPMVog2mBL37qvP+7NvnYuTv4rvjfubN6k3wpPZ0/WkEOwtiEUsWcxm+Gl4aOhhiFDAPIwmbAtn7TPVy77zqcefr5YHmHull7enyfPmcAHgHew1REr8Vhhd/F+AV1RJ0DikJWQNc/ZP3efKd7hvs2ur46rHs5u8e9N/48/0hA/8HFgwuD04RSBIREqsQOg7mCssGMAJW/Xn4G/TK8Lbuzu0I7qTvnPJy9sX6bP84BLYIbAwdD84QYxG7EOcODAxwCFMEAQC9+7P3SvTX8XHw+u9R8KTxIvSo9+X7VQCUBJ0IMwziDj4QLhAGD9UMrgnTBZcBRv1v+Xv2UfS+8tfx+vES87z0+vb3+Zf9ZgEQBSEIUArWC8kM2QyzC5EJEAdvBHgBXP5n++r4Avd89Wj07fMw9D31Jvfp+Uj9xQD9A8QG5QhXClELrAsvC9wJ7gd6BWIC3v6O+7T4PPZN9EHzWvNf9Pz1Fvit+qL9rQCHAwEG/weCCZUKFwvDCnIJcAcQBWcCaf8Z/CD55vaB9dD0wPSP9UL3m/k7/Mz+JwEyAw8FzAY7CBsJaQk5CWkI2gatBCICYf+j/Fr6vfiV9872sfZP91z4p/lR+3H9zf89AroEFAfjCP0Jcwo8CjAJdQdgBSEDkgDQ/Vj7ZfnR95T28fUd9v32Vvg2+nb8+/6xAWoE4AbDCP4JpAqbCqQJ0weEBfgCTACT/R37M/m+9672IPY69gb3afhW+tT8qf+MAj0FggcuCScKXAriCcMIEAfyBJYCFwCP/Rz7A/l793z2F/Zn9mH37fjd+i39yf9pAt0EFAfRCNkJGAqrCZYIvgZPBJ8B6P4//M350vdz9q/1lfUq9mz3RPmi+3H+bgFVBOQG3wgHCkwK0Am7CCAHCgWmAjAA",
  "lowtick": "UklGRlQFAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YTAFAAB0/5v+U/4T/3gA0wFTAuUB+f8d/nT90f1q/ub+tf46/mb/8wFQA9gC7wCd/mr+FAGRA3cE6wJf/h36evmv+8v/NwRHBZUC2/60+//5EvuZ/aX/bgFOAp8Azvzh9wfzLPF68zT4y/2BAygIfQwaEjYY0x31Irwl8SOWHVESOgPh9NfpReFt22nYHddD2BXcZeDa5InqgPDx9nP+6gS4CBYLnw0zES0WXxv4HkcgLh/1G+EX1RNpD4wKigXH/6r5/fNu7lTpj+Zu5hHoXOtL71byr/Qp91L64v6OBO4JoQ5zEskU+hU1FiQVeRP7EWgP4Qr0BIT+tPid9C3y1vCh8FDxJvK28vvyy/LA8pLzU/XP95v6xvw4/uD/RAK2BSkKcg6BEScTZBMeEqkPTQxjCKEEVwFi/nv7h/hp9aDyAvHP8MfxLvM+9PX0uPW19g/4Lfr7/C4AKgNaBXQGywb0BhIHWQfWB1oIzAjtCF8IHwdtBakDVwKLAeYA8v9w/kj81/nQ94v29/XX9bz1bPUY9Uz1Z/aH+Hr7yP4MAi4F+wcfCnYLNgyfDPsMSw0sDUAMfgrcB5IEMwFb/iX8T/pT+O/1X/Mf8cbvrO+18MLyvfVP+Rf9wgAoBCEHpwnIC5EN4Q5AD3wO1Ay0CpsIvwbvBNcCbQAr/nX8Ofsf+vb4mvda9rj1z/WX9pL3a/hH+ZX6R/wn/vP/eQESA/AE+wYDCcwKFAyPDCkMFQuSCe4HVQbSBHQDCwI8ANL9JPuY+HX28vTq82PzdPMV9Az1MfZ49zD5gftx/sQBBQXLB8cJ/gqpCw8MigwWDXENXQ2rDDUL7QgDBswCdv8S/K74WPVk8hXwou4P7mvu1+9T8pz1Uvli/ZoBwgWRCcsMPg/CEEQR4RDADwoO9wusCVMH4ARSApn/ufzd+Wj3bvX78xzzx/L68qzz1vSD9qX4Gfvd/c0AhwO/BWwHmghvCQEKVQonClsJCwiIBh0F0gOgAm0BOwAx/03+XP0g/Lb6cPmX+F/4vfh++TH6s/os+7/7cvwL/Zz9XP5O/3IA3AF9AzsF9gaUCAAKHgueCzcL9wntB3sF4wIzAI396fp1+Gv2IvWn9N30p/Xi9m74G/ru+9P9k/8aAYEC1AMTBSIG0wYuB1gHkgcACGEISAhTBzEFWAKt/5L92fuU+vX50fmf+SP5i/gb+Bf4mviv+Sr7kvyb/Uj+r/4X/8r/+gCiAo0EUAaRBzwISwjqB3IHGQfCBv8FpgTMApQAKf67+5n5/vfn9jz2yPVn9SL1RPXq9SP3Dvmr+6f+sQGKBAcH+whOCh0Laws3C28KLAmDB5AFfQNoAVP/Zv3e+7P6sfnL+Cv4vPeM95b37feV+Jn51Poq/LL9mv+YAVYD3gQuBmcHSAikCIEI7Af+BuEFngQXA1sBv/9v/pf9MP3W/Fj8q/sR+6H6U/o3+mP6y/pN+/f7xvye/WH+Jf9mAD4CQAQJBisHtgf6Bw0I8QdsB1sGywT4AggBCP/o/KX6mPg19572jfaz9uf2S/cM+E35E/tW/af/5wH1A8AFKgfkB/AHgwfxBlAGgQVIBMMCJwGs/43+vP0i/Zr8Lfzl+9H76fvi+9f75fsf/In8BP10/ej9cf4O/7f/dAAcAaUBEgKMAhgDpAMEBCEEDwTfA3IDxQL8ASoBUwCG/87+J/6h/Rr9pPxk/Gb8oPwJ/XH9w/39/UD+qP41/9D/WwDeAGsBAgKdAhEDQQNAA0sDbwOVA5YDVwPOAhgCVAGRAA==",
}
},{}],23:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _init_midi = require('./init_midi');

var _init_audio = require('./init_audio');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var BUFFER_TIME = 200; // millis

var Scheduler = function () {
  function Scheduler(song) {
    _classCallCheck(this, Scheduler);

    this.song = song;
  }

  _createClass(Scheduler, [{
    key: 'init',
    value: function init(millis) {
      this.songStartMillis = millis;
      this.events = this.song._events;
      this.numEvents = this.events.length;
      this.index = 0;
      this.setIndex(this.songStartMillis);
    }
  }, {
    key: 'setTimeStamp',
    value: function setTimeStamp(timeStamp) {
      this.timeStamp = timeStamp;
    }

    // get the index of the event that has its millis value at or right after the provided millis value

  }, {
    key: 'setIndex',
    value: function setIndex(millis) {
      var i = 0;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.events[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var event = _step.value;

          if (event.millis >= millis) {
            this.index = i;
            break;
          }
          i++;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }, {
    key: 'getEvents',
    value: function getEvents() {
      var events = [];
      // main loop
      for (var i = this.index; i < this.numEvents; i++) {
        var event = this.events[i];
        //console.log(event.millis, this.maxtime)
        if (event.millis < this.maxtime) {

          //event.time = this.timeStamp + event.millis - this.songStartMillis;

          if (event.type === 'audio') {
            // to be implemented
          } else {
              events.push(event);
            }
          this.index++;
        } else {
          break;
        }
      }
      return events;
    }
  }, {
    key: 'update',
    value: function update(millis) {
      var i, event, numEvents, track, events, instrument, scheduledTime;

      //console.log(position, this.maxtime)
      events = this.getEvents();
      numEvents = events.length;
      this.maxtime = millis + BUFFER_TIME;

      //console.log('update', this.maxtime, numEvents)

      for (i = 0; i < numEvents; i++) {
        event = events[i];
        track = event._track;
        instrument = track._instrument;

        //console.log(event.ticks)

        // if(typeof instrument === 'undefined'){
        //   continue
        // }

        if (event._part.muted === true || track.muted === true || event.muted === true) {
          continue;
        }

        if ((event.type === 144 || event.type === 128) && typeof event.midiNote === 'undefined') {
          // this is usually caused by the same note on the same ticks value, which is probably a bug in the midi file
          //console.info('no midiNoteId', event)
          continue;
        }

        // debug minute_waltz double events
        // if(event.ticks > 40300){
        //   console.info(event)
        // }

        scheduledTime = this.timeStamp + event.millis - this.songStartMillis;
        //console.log('scheduled', scheduledTime, 'current', context.currentTime * 1000)

        if (event.type === 'audio') {
          // to be implemented
        } else {

            // send to javascript instrument
            if (typeof instrument !== 'undefined') {
              // convert to seconds because the audio context uses seconds for scheduling
              instrument.processMIDIEvent(event, scheduledTime / 1000, track._output);
            }

            // send to external hardware or software instrument
            var channel = track.channel;
            var offset = BUFFER_TIME * 2; // why does this work?

            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
              for (var _iterator2 = track._midiOutputIds[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var portId = _step2.value;

                var port = (0, _init_midi.getMIDIOutputById)(portId);
                if (port) {
                  if (event.type === 128 || event.type === 144 || event.type === 176) {
                    port.send([event.type + channel, event.data1, event.data2], scheduledTime + offset);
                  } else if (event.type === 192 || event.type === 224) {
                    port.send([event.type + channel, event.data1], scheduledTime + offset);
                  }
                }
              }
            } catch (err) {
              _didIteratorError2 = true;
              _iteratorError2 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion2 && _iterator2.return) {
                  _iterator2.return();
                }
              } finally {
                if (_didIteratorError2) {
                  throw _iteratorError2;
                }
              }
            }
          }
      }
      //console.log(this.index, this.numEvents)
      //return this.index >= 10
      return this.index >= this.numEvents; // end of song
    }
  }, {
    key: 'allNotesOff',
    value: function allNotesOff() {
      //console.log('STOP')
      ///*
      var timeStamp = _init_audio.context.currentTime * 1000;
      var outputs = (0, _init_midi.getMIDIOutputs)();
      outputs.forEach(function (output) {
        output.send([0xB0, 0x7B, 0x00], timeStamp + BUFFER_TIME * 2); // stop all notes
        output.send([0xB0, 0x79, 0x00], timeStamp + BUFFER_TIME * 2); // reset all controllers
      });
      //*/
      var tracks = this.song._tracks;
      tracks.forEach(function (track) {
        //let instrument = track._instrument
        //if(typeof instrument !== 'undefined'){
        //  instrument.allNotesOff()
        //}
        track._instrument.allNotesOff();
      });
    }
  }]);

  return Scheduler;
}();

exports.default = Scheduler;

},{"./init_audio":7,"./init_midi":8}],24:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Song = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); //@ flow

//import {addTask, removeTask} from './heartbeat'


var _parse_events = require('./parse_events');

var _init_audio = require('./init_audio');

var _scheduler = require('./scheduler');

var _scheduler2 = _interopRequireDefault(_scheduler);

var _midi_event = require('./midi_event');

var _song_from_midifile = require('./song_from_midifile');

var _qambi = require('./qambi');

var _qambi2 = _interopRequireDefault(_qambi);

var _util = require('./util');

var _position = require('./position');

var _playhead = require('./playhead');

var _eventlistener = require('./eventlistener');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var songIndex = 0;

var defaultSong = {
  ppq: 960,
  bpm: 120,
  bars: 30,
  lowestNote: 0,
  highestNote: 127,
  nominator: 4,
  denominator: 4,
  quantizeValue: 8,
  fixedLengthValue: false,
  positionType: 'all',
  useMetronome: false,
  autoSize: true,
  loop: false,
  playbackSpeed: 1,
  autoQuantize: false
};
/*
type songSettings = {
  name: string,
  ppq: number,
  bpm: number,
  bars: number,
  lowestNote: number,
  highestNote: number,
  nominator: number,
  denominator: number,
  quantizeValue: number,
  fixedLengthValue: number,
  positionType: string,
  useMetronome: boolean,
  autoSize: boolean,
  loop: boolean,
  playbackSpeed: number,
  autoQuantize: boolean
}
*/

var Song = exports.Song = function () {
  _createClass(Song, null, [{
    key: 'fromMIDIFile',
    value: function fromMIDIFile(data) {
      return (0, _song_from_midifile.songFromMIDIFile)(data);
    }
  }, {
    key: 'fromMIDIFileAsync',
    value: function fromMIDIFileAsync(data) {
      return (0, _song_from_midifile.songFromMIDIFileAsync)(data);
    }
  }]);

  function Song() {
    var settings = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, Song);

    this.id = 'S_' + songIndex++ + '_' + new Date().getTime();

    var _settings$name = settings.name;
    this.name = _settings$name === undefined ? this.id : _settings$name;
    var _settings$ppq = settings.ppq;
    this.ppq = _settings$ppq === undefined ? defaultSong.ppq : _settings$ppq;
    var _settings$bpm = settings.bpm;
    this.bpm = _settings$bpm === undefined ? defaultSong.bpm : _settings$bpm;
    var _settings$bars = settings.bars;
    this.bars = _settings$bars === undefined ? defaultSong.bars : _settings$bars;
    var _settings$nominator = settings.nominator;
    this.nominator = _settings$nominator === undefined ? defaultSong.nominator : _settings$nominator;
    var _settings$denominator = settings.denominator;
    this.denominator = _settings$denominator === undefined ? defaultSong.denominator : _settings$denominator;
    var _settings$quantizeVal = settings.quantizeValue;
    this.quantizeValue = _settings$quantizeVal === undefined ? defaultSong.quantizeValue : _settings$quantizeVal;
    var _settings$fixedLength = settings.fixedLengthValue;
    this.fixedLengthValue = _settings$fixedLength === undefined ? defaultSong.fixedLengthValue : _settings$fixedLength;
    var _settings$useMetronom = settings.useMetronome;
    this.useMetronome = _settings$useMetronom === undefined ? defaultSong.useMetronome : _settings$useMetronom;
    var _settings$autoSize = settings.autoSize;
    this.autoSize = _settings$autoSize === undefined ? defaultSong.autoSize : _settings$autoSize;
    var _settings$loop = settings.loop;
    this.loop = _settings$loop === undefined ? defaultSong.loop : _settings$loop;
    var _settings$playbackSpe = settings.playbackSpeed;
    this.playbackSpeed = _settings$playbackSpe === undefined ? defaultSong.playbackSpeed : _settings$playbackSpe;
    var _settings$autoQuantiz = settings.autoQuantize;
    this.autoQuantize = _settings$autoQuantiz === undefined ? defaultSong.autoQuantize : _settings$autoQuantiz;


    this._timeEvents = [new _midi_event.MIDIEvent(0, _qambi2.default.TEMPO, this.bpm), new _midi_event.MIDIEvent(0, _qambi2.default.TIME_SIGNATURE, this.nominator, this.denominator)];

    //this._timeEvents = []
    this._updateTimeEvents = true;
    this._lastEvent = new _midi_event.MIDIEvent(0, _qambi2.default.END_OF_TRACK);

    this._tracks = [];
    this._tracksById = new Map();

    this._parts = [];
    this._partsById = new Map();

    this._events = [];
    this._eventsById = new Map();

    this._notes = [];
    this._notesById = new Map();

    this._newEvents = [];
    this._movedEvents = [];
    this._removedEvents = [];
    this._transposedEvents = [];

    this._newParts = [];
    this._changedParts = [];
    this._removedParts = [];

    this._scheduler = new _scheduler2.default(this);
    this._playhead = new _playhead.Playhead(this);
    this._millis = 0;

    this._playing = false;
    this._paused = false;
  }

  _createClass(Song, [{
    key: 'addTimeEvents',
    value: function addTimeEvents() {
      var _timeEvents;

      //@TODO: filter time events on the same tick -> use the lastly added events
      (_timeEvents = this._timeEvents).push.apply(_timeEvents, arguments);
      this._updateTimeEvents = true;
    }
  }, {
    key: 'addTracks',
    value: function addTracks() {
      var _this = this;

      for (var _len = arguments.length, tracks = Array(_len), _key = 0; _key < _len; _key++) {
        tracks[_key] = arguments[_key];
      }

      tracks.forEach(function (track) {
        var _newEvents, _newParts;

        track._song = _this;
        _this._tracks.push(track);
        _this._tracksById.set(track.id, track);
        (_newEvents = _this._newEvents).push.apply(_newEvents, _toConsumableArray(track._events));
        (_newParts = _this._newParts).push.apply(_newParts, _toConsumableArray(track._parts));
      });
    }

    // prepare song events for playback

  }, {
    key: 'update',
    value: function update() {
      var _this2 = this;

      var createEventArray = false;

      if (this._updateTimeEvents === false && this._removedEvents.length === 0 && this._newEvents.length === 0 && this._movedEvents.length === 0) {
        return;
      }
      //debug
      //this.isPlaying = true

      console.group('update song');
      console.time('total');

      // check if time events are updated
      if (this._updateTimeEvents === true) {
        //console.log('updateTimeEvents', this._timeEvents.length)
        (0, _parse_events.parseTimeEvents)(this, this._timeEvents, this.isPlaying);
        this._updateTimeEvents = false;
        console.log('time events %O', this._timeEvents);
      }

      // only parse new and moved events
      var tobeParsed = [];

      // filter removed parts
      console.log('removed parts %O', this._removedParts);
      this._removedParts.forEach(function (part) {
        var _removedEvents;

        _this2.partsById.delete(part.id);
        (_removedEvents = _this2._removedEvents).push.apply(_removedEvents, _toConsumableArray(part._events));
      });

      // add new parts
      console.log('new parts %O', this._newParts);
      this._newParts.forEach(function (part) {
        var _tobeParsed;

        part._song = _this2;
        _this2._partsById.set(part.id, part);
        (_tobeParsed = tobeParsed).push.apply(_tobeParsed, _toConsumableArray(part._events));
        part.update();
      });

      // update changed parts
      console.log('changed parts %O', this._changedParts);
      this._changedParts.forEach(function (part) {
        part.update();
      });

      // filter removed events
      console.log('removed events %O', this._removedEvents);
      this._removedEvents.forEach(function (event) {
        _this2._notesById.delete(event.midiNote.id);
        _this2._eventsById.delete(event.id);
      });

      createEventArray = this._removedEvents.length > 0;

      // add new events
      console.log('new events %O', this._newEvents);
      this._newEvents.forEach(function (event) {
        _this2._eventsById.set(event.id, event);
        _this2._events.push(event);
        tobeParsed.push(event);
        //console.log(event.id)
      });

      // moved events need to be parsed
      console.log('moved %O', this._movedEvents);
      this._movedEvents.forEach(function (event) {
        tobeParsed.push(event);
      });

      //tobeParsed = [...tobeParsed, ...Array.from(song.movedEvents.values())]

      console.time('parse');
      if (tobeParsed.length > 0) {
        //console.log('tobeParsed %O', tobeParsed)
        tobeParsed = [].concat(_toConsumableArray(tobeParsed), _toConsumableArray(this._timeEvents));
        console.log('parseEvents', tobeParsed.length - this._timeEvents.length);
        (0, _parse_events.parseEvents)(tobeParsed, this.isPlaying);
        tobeParsed.forEach(function (event) {
          //console.log(event.id, event.type)
          if (event.type === _qambi2.default.NOTE_ON) {
            if (event.midiNote) {
              _this2._notesById.set(event.midiNoteId, event.midiNote);
              //console.log(event.midiNoteId, event.type)
              //this._notes.push(event.midiNote)
            }
          }
        });
        this._notes = Array.from(this._notesById.values());
      }
      console.timeEnd('parse');

      if (createEventArray) {
        console.time('to array');
        this._events = Array.from(this._eventsById.values());
        this._notes = Array.from(this._notesById.values());
        console.timeEnd('to array');
      }

      console.time('sorting ' + this._events.length + ' events');
      (0, _util.sortEvents)(this._events);
      this._notes.sort(function (a, b) {
        return a.noteOn.ticks - b.noteOn.ticks;
      });
      console.timeEnd('sorting ' + this._events.length + ' events');

      console.log('notes %O', this._notes);

      console.timeEnd('total');
      console.groupEnd('update song');
      console.timeEnd('update song');

      var lastEvent = this._events[this._events.length - 1];
      var lastTimeEvent = this._timeEvents[this._timeEvents.length - 1];
      if (lastTimeEvent.ticks > lastTimeEvent.ticks) {
        lastTimeEvent = lastTimeEvent;
      }

      //console.log('last tick', lastTicks)
      this._lastEvent.bar = lastEvent.bar;
      this._lastEvent.beat = lastEvent.beat;
      this._lastEvent.sixteenth = lastEvent.sixteenth;
      this._lastEvent.tick = lastEvent.tick;
      this._lastEvent.ticks = lastEvent.ticks;
      this._lastEvent.millis = lastEvent.millis;
      this._durationTicks = this._lastEvent.ticks;
      this._durationMillis = this._lastEvent.millis;

      this._playhead.updateSong();
    }
  }, {
    key: 'play',
    value: function play(type) {
      for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      this._play.apply(this, [type].concat(args));
      (0, _eventlistener.dispatchEvent)({ type: 'play', data: this._millis });
    }
  }, {
    key: '_play',
    value: function _play(type) {
      if (typeof type !== 'undefined') {
        for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
          args[_key3 - 1] = arguments[_key3];
        }

        this.setPosition.apply(this, [type].concat(args));
      }
      if (this._playing) {
        return;
      }

      this._timeStamp = _init_audio.context.currentTime * 1000;
      this._scheduler.setTimeStamp(this._timeStamp);

      if (this._paused) {
        this._paused = false;
      }

      this._playing = true;
      this._scheduler.init(this._millis);
      this._playhead.set('millis', this._millis);
      this._pulse();
    }
  }, {
    key: 'pause',
    value: function pause() {
      this._paused = !this._paused;
      if (this._paused) {
        this._playing = false;
        this._scheduler.allNotesOff();
        (0, _eventlistener.dispatchEvent)({ type: 'pause', data: this._paused });
      } else {
        this.play();
        (0, _eventlistener.dispatchEvent)({ type: 'pause', data: this._paused });
      }
    }
  }, {
    key: 'stop',
    value: function stop() {
      this._scheduler.allNotesOff();
      if (this._playing || this._paused) {
        this._playing = false;
        this._paused = false;
      }
      if (this._millis !== 0) {
        this._millis = 0;
        this._playhead.set('millis', this._millis);
        (0, _eventlistener.dispatchEvent)({ type: 'stop' });
      }
    }
  }, {
    key: 'allNotesOff',
    value: function allNotesOff() {
      this._scheduler.allNotesOff();
    }
  }, {
    key: 'getTracks',
    value: function getTracks() {
      return [].concat(_toConsumableArray(this._tracks));
    }
  }, {
    key: 'getParts',
    value: function getParts() {
      return [].concat(_toConsumableArray(this._parts));
    }
  }, {
    key: 'getEvents',
    value: function getEvents() {
      return [].concat(_toConsumableArray(this._events));
    }
  }, {
    key: 'getNotes',
    value: function getNotes() {
      return [].concat(_toConsumableArray(this._notes));
    }
  }, {
    key: 'calculatePosition',
    value: function calculatePosition(args) {
      return (0, _position.calculatePosition)(this, args);
    }

    /*
      position:
        - 'ticks', 96000
        - 'millis', 1234
        - 'percentage', 55
        - 'barsbeats', 1, 4, 0, 25 -> bar, beat, sixteenth, tick
        - 'time', 0, 3, 49, 566 -> hours, minutes, seconds, millis
    */

  }, {
    key: 'setPosition',
    value: function setPosition(type) {

      var wasPlaying = this._playing;
      if (this._playing) {
        this._playing = false;
        this._scheduler.allNotesOff();
      }

      var target = void 0;
      var position = void 0;

      for (var _len4 = arguments.length, args = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
        args[_key4 - 1] = arguments[_key4];
      }

      switch (type) {
        case 'ticks':
        case 'millis':
        case 'percentage':
          target = args[0] || 0;
          break;

        case 'time':
        case 'barsbeats':
        case 'barsandbeats':
          target = args;
          break;

        default:
          console.log('unsupported type');
          return;
      }

      // millis = calculatePosition(this, {
      //   type,
      //   target,
      //   result: 'millis'
      // }).millis

      position = (0, _position.calculatePosition)(this, {
        type: type,
        target: target,
        result: 'all'
      });

      this._millis = position.millis;

      (0, _eventlistener.dispatchEvent)({
        type: 'position',
        data: position
      });

      if (wasPlaying) {
        this._play();
      }
      //console.log('setPosition', this._millis)
    }
  }, {
    key: 'getPosition',
    value: function getPosition() {
      return this._playhead.get().position;
    }
  }, {
    key: 'getPlayhead',
    value: function getPlayhead() {
      return this._playhead.get();
    }
  }, {
    key: '_pulse',
    value: function _pulse() {
      if (this._playing === false) {
        return;
      }
      var now = _init_audio.context.currentTime * 1000;
      var diff = now - this._timeStamp;
      this._millis += diff;
      this._timeStamp = now;
      //console.log(diff, this.millis)

      this._playhead.update('millis', diff);

      if (this._millis >= this._durationMillis) {
        this.stop();
        return;
      }

      this._scheduler.update(this._millis);

      //console.log('pulse', diff)
      requestAnimationFrame(this._pulse.bind(this));
    }
  }, {
    key: 'addEventListener',
    value: function addEventListener(type, callback) {
      return (0, _eventlistener.addEventListener)(type, callback);
    }
  }, {
    key: 'removeEventListener',
    value: function removeEventListener(type, id) {
      (0, _eventlistener.removeEventListener)(type, id);
    }
  }]);

  return Song;
}();

},{"./eventlistener":4,"./init_audio":7,"./midi_event":10,"./parse_events":16,"./playhead":18,"./position":19,"./qambi":20,"./scheduler":23,"./song_from_midifile":25,"./util":27}],25:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.songFromMIDIFile = songFromMIDIFile;
exports.songFromMIDIFileAsync = songFromMIDIFileAsync;

var _isomorphicFetch = require('isomorphic-fetch');

var _isomorphicFetch2 = _interopRequireDefault(_isomorphicFetch);

var _midifile = require('./midifile');

var _midi_event = require('./midi_event');

var _part = require('./part');

var _track = require('./track');

var _song = require('./song');

var _util = require('./util');

var _fetch_helpers = require('./fetch_helpers');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var PPQ = 960;

function toSong(parsed) {
  var tracks = parsed.tracks;
  var ppq = parsed.header.ticksPerBeat;
  var ppqFactor = PPQ / ppq; //@TODO: get ppq from config -> only necessary if you want to change the ppq of the MIDI file !
  var timeEvents = [];
  var bpm = -1;
  var nominator = -1;
  var denominator = -1;
  var newTracks = [];

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = tracks.values()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var track = _step.value;

      var lastTicks = void 0,
          lastType = void 0;
      var ticks = 0;
      var type = void 0;
      var channel = -1;
      var trackName = void 0;
      var trackInstrumentName = void 0;
      var events = [];

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = track[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var event = _step2.value;

          ticks += event.deltaTime * ppqFactor;

          if (channel === -1 && typeof event.channel !== 'undefined') {
            channel = event.channel;
          }
          type = event.subtype;
          //console.log(event.deltaTime, ticks, type);

          switch (event.subtype) {

            case 'trackName':
              trackName = event.text;
              break;

            case 'instrumentName':
              if (event.text) {
                trackInstrumentName = event.text;
              }
              break;

            case 'noteOn':
              events.push(new _midi_event.MIDIEvent(ticks, 0x90, event.noteNumber, event.velocity));
              break;

            case 'noteOff':
              events.push(new _midi_event.MIDIEvent(ticks, 0x80, event.noteNumber, event.velocity));
              break;

            case 'setTempo':
              // sometimes 2 tempo events have the same position in ticks
              // we use the last in these cases (same as Cubase)
              var tmp = 60000000 / event.microsecondsPerBeat;

              if (ticks === lastTicks && type === lastType) {
                //console.info('tempo events on the same tick', ticks, tmp);
                timeEvents.pop();
              }

              if (bpm === -1) {
                bpm = tmp;
              }
              timeEvents.push(new _midi_event.MIDIEvent(ticks, 0x51, tmp));
              break;

            case 'timeSignature':
              // sometimes 2 time signature events have the same position in ticks
              // we use the last in these cases (same as Cubase)
              if (lastTicks === ticks && lastType === type) {
                console.info('time signature events on the same tick', ticks, event.numerator, event.denominator);
                timeEvents.pop();
              }

              if (nominator === -1) {
                nominator = event.numerator;
                denominator = event.denominator;
              }
              timeEvents.push(new _midi_event.MIDIEvent(ticks, 0x58, event.numerator, event.denominator));
              break;

            case 'controller':
              events.push(new _midi_event.MIDIEvent(ticks, 0xB0, event.controllerType, event.value));
              break;

            case 'programChange':
              events.push(new _midi_event.MIDIEvent(ticks, 0xC0, event.programNumber));
              break;

            case 'pitchBend':
              events.push(new _midi_event.MIDIEvent(ticks, 0xE0, event.value));
              break;

            default:
            //console.log(track.name, event.type);
          }

          lastType = type;
          lastTicks = ticks;
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      if (events.length > 0) {
        //console.count(events.length)
        var newTrack = new _track.Track(trackName);
        var part = new _part.Part();
        newTrack.addParts(part);
        part.addEvents.apply(part, events);
        newTracks.push(newTrack);
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  var song = new _song.Song({
    ppq: PPQ,
    playbackSpeed: 1,
    //ppq,
    bpm: bpm,
    nominator: nominator,
    denominator: denominator
  });
  song.addTracks.apply(song, newTracks);
  song.addTimeEvents.apply(song, timeEvents);
  song.update();
  return song;
}

function songFromMIDIFile(data) {
  var settings = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

  var song = null;

  if (data instanceof ArrayBuffer === true) {
    var buffer = new Uint8Array(data);
    song = toSong((0, _midifile.parseMIDIFile)(buffer));
  } else if (typeof data.header !== 'undefined' && typeof data.tracks !== 'undefined') {
    song = toSong(data);
  } else {
    data = (0, _util.base64ToBinary)(data);
    if (data instanceof ArrayBuffer === true) {
      var _buffer = new Uint8Array(data);
      song = toSong((0, _midifile.parseMIDIFile)(_buffer));
    } else {
      console.error('wrong data');
    }
  }

  return song;
  // {
  //   ppq = newPPQ,
  //   bpm = newBPM,
  //   playbackSpeed = newPlaybackSpeed,
  // } = settings
}

function songFromMIDIFileAsync(url) {
  return new Promise(function (resolve, reject) {
    (0, _isomorphicFetch2.default)(url).then(_fetch_helpers.status).then(_fetch_helpers.arrayBuffer).then(function (data) {
      resolve(songFromMIDIFile(data));
    }).catch(function (e) {
      reject(e);
    });
  });
}

},{"./fetch_helpers":5,"./midi_event":10,"./midifile":13,"./part":17,"./song":24,"./track":26,"./util":27,"isomorphic-fetch":2}],26:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Track = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _part = require('./part');

var _util = require('./util');

var _init_audio = require('./init_audio');

var _instrument = require('./instrument');

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var trackIndex = 0;

var Track = exports.Track = function () {
  function Track() {
    var name = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];

    _classCallCheck(this, Track);

    this.id = 'TR_' + trackIndex++ + '_' + new Date().getTime();
    this.name = name || this.id;
    this.channel = 0;
    this.muted = false;
    this.volume = 0.5;
    this._output = _init_audio.context.createGain();
    this._output.gain.value = this.volume;
    this._output.connect(_init_audio.masterGain);
    this._midiOutputIds = [];
    this._song = null;
    this._parts = [];
    this._partsById = new Map();
    this._events = [];
    this._eventsById = new Map();
    this._needsUpdate = false;
    this._createEventArray = false;
    this.setInstrument(new _instrument.Instrument());
  }

  _createClass(Track, [{
    key: 'setInstrument',
    value: function setInstrument(instrument) {
      this._instrument = instrument;
      instrument.connect(this._output);
    }
  }, {
    key: 'setMIDIOutputs',
    value: function setMIDIOutputs() {
      var _midiOutputIds;

      //console.log(outputIds)
      (_midiOutputIds = this._midiOutputIds).push.apply(_midiOutputIds, arguments);
    }
  }, {
    key: 'removeMIDIOutputs',
    value: function removeMIDIOutputs() {
      //this._midiOutputs = this._midiOutputs.filter(...outputs)
    }
  }, {
    key: 'copy',
    value: function copy() {
      var t = new Track(this.name + '_copy'); // implement getNameOfCopy() in util (see heartbeat)
      var parts = [];
      this._parts.forEach(function (part) {
        var copy = part.copy();
        console.log(copy);
        parts.push(copy);
      });
      t.addParts.apply(t, parts);
      t.update();
      return t;
    }
  }, {
    key: 'transpose',
    value: function transpose(amount) {
      this._events.forEach(function (event) {
        event.transpose(amount);
      });
    }
  }, {
    key: 'addParts',
    value: function addParts() {
      var _this = this;

      var song = this._song;

      for (var _len = arguments.length, parts = Array(_len), _key = 0; _key < _len; _key++) {
        parts[_key] = arguments[_key];
      }

      parts.forEach(function (part) {
        var _events;

        part._track = _this;
        _this._partsById.set(part.id, part);
        _this._parts.push(part);
        if (song) {
          part._song = song;
          song._newParts.push(part);
        }

        var events = part._events;
        events.forEach(function (event) {
          event._track = _this;
          if (song) {
            event._song = song;
            //song._newEvents.push(event)
          }
          _this._eventsById.set(event.id, event);
        });
        (_events = _this._events).push.apply(_events, _toConsumableArray(events));
      });
      this._needsUpdate = true;
    }
  }, {
    key: 'removeParts',
    value: function removeParts() {
      var _this2 = this;

      var song = this._song;

      for (var _len2 = arguments.length, parts = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        parts[_key2] = arguments[_key2];
      }

      parts.forEach(function (part) {
        part._track = null;
        _this2._partsById.delete(part.id, part);
        if (song) {
          song._deletedParts.push(part);
        }

        var events = part._events;
        events.forEach(function (event) {
          event._track = null;
          if (song) {
            event._song = null;
            //song._deletedEvents.push(event)
          }
          this._eventsById.delete(event.id, event);
        });
      });
      this._needsUpdate = true;
      this._createEventArray = true;
    }
  }, {
    key: 'getParts',
    value: function getParts() {
      if (this._needsUpdate) {
        this._parts = Array.from(this._partsById.values());
        this._events = Array.from(this._eventsById.values());
        this._needsUpdate = false;
      }
      return [].concat(_toConsumableArray(this._parts));
    }
  }, {
    key: 'transposeParts',
    value: function transposeParts(amount) {
      for (var _len3 = arguments.length, parts = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        parts[_key3 - 1] = arguments[_key3];
      }

      parts.forEach(function (part) {
        part.transpose(amount);
      });
    }
  }, {
    key: 'moveParts',
    value: function moveParts(ticks) {
      for (var _len4 = arguments.length, parts = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
        parts[_key4 - 1] = arguments[_key4];
      }

      parts.forEach(function (part) {
        part.move(ticks);
      });
    }
  }, {
    key: 'movePartsTo',
    value: function movePartsTo(ticks) {
      for (var _len5 = arguments.length, parts = Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
        parts[_key5 - 1] = arguments[_key5];
      }

      parts.forEach(function (part) {
        part.moveTo(ticks);
      });
    }
  }, {
    key: 'addEvents',
    value: function addEvents() {
      var p = new _part.Part();
      p.addEvents.apply(p, arguments);
      this.addParts(p);
    }
  }, {
    key: 'removeEvents',
    value: function removeEvents() {
      var _this3 = this;

      var parts = new Set();

      for (var _len6 = arguments.length, events = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        events[_key6] = arguments[_key6];
      }

      events.forEach(function (event) {
        parts.set(event._part);
        event._part = null;
        event._track = null;
        event._song = null;
        _this3._eventsById.delete(event.id);
      });
      if (this._song) {
        var _song$_changedParts, _song$_removedEvents;

        (_song$_changedParts = this._song._changedParts).push.apply(_song$_changedParts, _toConsumableArray(Array.from(parts.entries())));
        (_song$_removedEvents = this._song._removedEvents).push.apply(_song$_removedEvents, events);
      }
      this._needsUpdate = true;
      this._createEventArray = true;
    }
  }, {
    key: 'moveEvents',
    value: function moveEvents(ticks) {
      var parts = new Set();

      for (var _len7 = arguments.length, events = Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {
        events[_key7 - 1] = arguments[_key7];
      }

      events.forEach(function (event) {
        event.move(ticks);
        parts.set(event.part);
      });
      if (this._song) {
        var _song$_changedParts2, _song$_movedEvents;

        (_song$_changedParts2 = this._song._changedParts).push.apply(_song$_changedParts2, _toConsumableArray(Array.from(parts.entries())));
        (_song$_movedEvents = this._song._movedEvents).push.apply(_song$_movedEvents, events);
      }
    }
  }, {
    key: 'moveEventsTo',
    value: function moveEventsTo(ticks) {
      var parts = new Set();

      for (var _len8 = arguments.length, events = Array(_len8 > 1 ? _len8 - 1 : 0), _key8 = 1; _key8 < _len8; _key8++) {
        events[_key8 - 1] = arguments[_key8];
      }

      events.forEach(function (event) {
        event.moveTo(ticks);
        parts.set(event.part);
      });
      if (this._song) {
        var _song$_changedParts3, _song$_movedEvents2;

        (_song$_changedParts3 = this._song._changedParts).push.apply(_song$_changedParts3, _toConsumableArray(Array.from(parts.entries())));
        (_song$_movedEvents2 = this._song._movedEvents).push.apply(_song$_movedEvents2, events);
      }
    }
  }, {
    key: 'getEvents',
    value: function getEvents() {
      var filter = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
      // can be use as findEvents
      if (this._needsUpdate) {
        this.update();
      }
      return [].concat(_toConsumableArray(this._events)); //@TODO implement filter -> filterEvents() should be a utility function (not a class method)
    }
  }, {
    key: 'mute',
    value: function mute() {
      var flag = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];

      if (flag) {
        this._muted = flag;
      } else {
        this._muted = !this._muted;
      }
    }
  }, {
    key: 'update',
    value: function update() {
      // you should only use this in huge songs (>100 tracks)
      if (this._createEventArray) {
        this._events = Array.from(this._eventsById.values());
        this._createEventArray = false;
      }
      (0, _util.sortEvents)(this._events);
      this._needsUpdate = false;
    }
  }]);

  return Track;
}();

},{"./init_audio":7,"./instrument":9,"./part":17,"./util":27}],27:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

exports.getNiceTime = getNiceTime;
exports.base64ToBinary = base64ToBinary;
exports.typeString = typeString;
exports.sortEvents = sortEvents;
exports.checkIfBase64 = checkIfBase64;
exports.getEqualPowerCurve = getEqualPowerCurve;

var _isomorphicFetch = require('isomorphic-fetch');

var _isomorphicFetch2 = _interopRequireDefault(_isomorphicFetch);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var mPI = Math.PI,
    mPow = Math.pow,
    mRound = Math.round,
    mFloor = Math.floor,
    mRandom = Math.random;

function getNiceTime(millis) {
  var h = void 0,
      m = void 0,
      s = void 0,
      ms = void 0,
      seconds = void 0,
      timeAsString = '';

  seconds = millis / 1000; //  millis to seconds
  h = mFloor(seconds / (60 * 60));
  m = mFloor(seconds % (60 * 60) / 60);
  s = mFloor(seconds % 60);
  ms = mRound((seconds - h * 3600 - m * 60 - s) * 1000);

  timeAsString += h + ':';
  timeAsString += m < 10 ? '0' + m : m;
  timeAsString += ':';
  timeAsString += s < 10 ? '0' + s : s;
  timeAsString += ':';
  timeAsString += ms === 0 ? '000' : ms < 10 ? '00' + ms : ms < 100 ? '0' + ms : ms;

  //console.log(h, m, s, ms);
  return {
    hour: h,
    minute: m,
    second: s,
    millisecond: ms,
    timeAsString: timeAsString,
    timeAsArray: [h, m, s, ms]
  };
}

// adapted version of https://github.com/danguer/blog-examples/blob/master/js/base64-binary.js
function base64ToBinary(input) {
  var keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',
      bytes = void 0,
      uarray = void 0,
      buffer = void 0,
      lkey1 = void 0,
      lkey2 = void 0,
      chr1 = void 0,
      chr2 = void 0,
      chr3 = void 0,
      enc1 = void 0,
      enc2 = void 0,
      enc3 = void 0,
      enc4 = void 0,
      i = void 0,
      j = 0;

  bytes = Math.ceil(3 * input.length / 4.0);
  buffer = new ArrayBuffer(bytes);
  uarray = new Uint8Array(buffer);

  lkey1 = keyStr.indexOf(input.charAt(input.length - 1));
  lkey2 = keyStr.indexOf(input.charAt(input.length - 1));
  if (lkey1 == 64) bytes--; //padding chars, so skip
  if (lkey2 == 64) bytes--; //padding chars, so skip

  input = input.replace(/[^A-Za-z0-9\+\/\=]/g, '');

  for (i = 0; i < bytes; i += 3) {
    //get the 3 octects in 4 ascii chars
    enc1 = keyStr.indexOf(input.charAt(j++));
    enc2 = keyStr.indexOf(input.charAt(j++));
    enc3 = keyStr.indexOf(input.charAt(j++));
    enc4 = keyStr.indexOf(input.charAt(j++));

    chr1 = enc1 << 2 | enc2 >> 4;
    chr2 = (enc2 & 15) << 4 | enc3 >> 2;
    chr3 = (enc3 & 3) << 6 | enc4;

    uarray[i] = chr1;
    if (enc3 != 64) uarray[i + 1] = chr2;
    if (enc4 != 64) uarray[i + 2] = chr3;
  }
  //console.log(buffer);
  return buffer;
}

function typeString(o) {
  if ((typeof o === 'undefined' ? 'undefined' : _typeof(o)) != 'object') {
    return typeof o === 'undefined' ? 'undefined' : _typeof(o);
  }

  if (o === null) {
    return 'null';
  }

  //object, array, function, date, regexp, string, number, boolean, error
  var internalClass = Object.prototype.toString.call(o).match(/\[object\s(\w+)\]/)[1];
  return internalClass.toLowerCase();
}

function sortEvents(events) {
  events.sort(function (a, b) {
    if (a.ticks === b.ticks) {
      var r = a.type - b.type;
      if (a.type === 176 && b.type === 144) {
        r = -1;
      }
      return r;
    }
    return a.ticks - b.ticks;
  });
}

function checkIfBase64(data) {
  var passed = true;
  try {
    atob(data);
  } catch (e) {
    passed = false;
  }
  return passed;
}

function getEqualPowerCurve(numSteps, type, maxValue) {
  var i = void 0,
      value = void 0,
      percent = void 0,
      values = new Float32Array(numSteps);

  for (i = 0; i < numSteps; i++) {
    percent = i / numSteps;
    if (type === 'fadeIn') {
      value = Math.cos((1.0 - percent) * 0.5 * mPI) * maxValue;
    } else if (type === 'fadeOut') {
      value = Math.cos(percent * 0.5 * Math.PI) * maxValue;
    }
    values[i] = value;
    if (i === numSteps - 1) {
      values[i] = type === 'fadeIn' ? 1 : 0;
    }
  }
  return values;
}

/*
//old school ajax

export function ajax(config){
  let
    request = new XMLHttpRequest(),
    method = typeof config.method === 'undefined' ? 'GET' : config.method,
    fileSize;

  function executor(resolve, reject){

    reject = reject || function(){};
    resolve = resolve || function(){};

    request.onload = function(){
      if(request.status !== 200){
        reject(request.status);
        return;
      }

      if(config.responseType === 'json'){
        fileSize = request.response.length;
        resolve(JSON.parse(request.response), fileSize);
        request = null;
      }else{
        resolve(request.response);
        request = null;
      }
    };

    request.onerror = function(e){
      config.onError(e);
    };

    request.open(method, config.url, true);

    if(config.overrideMimeType){
      request.overrideMimeType(config.overrideMimeType);
    }

    if(config.responseType){
      if(config.responseType === 'json'){
        request.responseType = 'text';
      }else{
        request.responseType = config.responseType;
      }
    }

    if(method === 'POST') {
      request.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
    }

    if(config.data){
      request.send(config.data);
    }else{
      request.send();
    }
  }

  return new Promise(executor);
}
*/

},{"isomorphic-fetch":2}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJleGFtcGxlcy9taWRpZmlsZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pc29tb3JwaGljLWZldGNoL2ZldGNoLW5wbS1icm93c2VyaWZ5LmpzIiwibm9kZV9tb2R1bGVzL3doYXR3Zy1mZXRjaC9mZXRjaC5qcyIsInNyYy9ldmVudGxpc3RlbmVyLmpzIiwic3JjL2ZldGNoX2hlbHBlcnMuanMiLCJzcmMvaW5pdC5qcyIsInNyYy9pbml0X2F1ZGlvLmpzIiwic3JjL2luaXRfbWlkaS5qcyIsInNyYy9pbnN0cnVtZW50LmpzIiwic3JjL21pZGlfZXZlbnQuanMiLCJzcmMvbWlkaV9ub3RlLmpzIiwic3JjL21pZGlfc3RyZWFtLmpzIiwic3JjL21pZGlmaWxlLmpzIiwic3JjL25vdGUuanMiLCJzcmMvcGFyc2VfYXVkaW8uanMiLCJzcmMvcGFyc2VfZXZlbnRzLmpzIiwic3JjL3BhcnQuanMiLCJzcmMvcGxheWhlYWQuanMiLCJzcmMvcG9zaXRpb24uanMiLCJzcmMvcWFtYmkuanMiLCJzcmMvc2FtcGxlLmpzIiwic3JjL3NhbXBsZXMuanNvbiIsInNyYy9zY2hlZHVsZXIuanMiLCJzcmMvc29uZy5qcyIsInNyYy9zb25nX2Zyb21fbWlkaWZpbGUuanMiLCJzcmMvdHJhY2suanMiLCJzcmMvdXRpbC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7O0FDQUE7Ozs7QUFLQTs7Ozs7O0FBRUEsU0FBUyxnQkFBVCxDQUEwQixrQkFBMUIsRUFBOEMsWUFBVTs7QUFFdEQsTUFBSSxhQUFKLENBRnNEOztBQUl0RCxrQkFBTSxJQUFOLEdBQ0MsSUFERCxDQUNNLFlBQU07O0FBRVYsUUFBSSxPQUFPLENBQVAsQ0FGTTs7QUFJVixRQUFHLFNBQVMsQ0FBVCxFQUFXOzs7QUFHWixxQ0FBTSx5QkFBTixFQUNDLElBREQsQ0FDTSxvQkFBWTtBQUNoQixlQUFPLFNBQVMsV0FBVCxFQUFQLENB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QyxJQUF0QyxFQUE0QyxRQUE1QyxFQUFzRDtBQUMzRCxNQUFJLFVBQUo7TUFBTyxjQUFQO01BQWMsZ0JBQWQ7TUFDRSxTQUFTLElBQUksWUFBSixDQUFpQixRQUFqQixDQUFULENBRnlEOztBQUkzRCxPQUFJLElBQUksQ0FBSixFQUFPLElBQUksUUFBSixFQUFjLEdBQXpCLEVBQTZCO0FBQzNCLGNBQVUsSUFBSSxRQUFKLENBRGlCO0FBRTNCLFFBQUcsU0FBUyxRQUFULEVBQWtCO0FBQ25CLGNBQVEsS0FBSyxHQUFMLENBQVMsQ0FBQyxNQUFNLE9BQU4sQ0FBRCxHQUFrQixHQUFsQixHQUF3QixHQUF4QixDQUFULEdBQXdDLFFBQXhDLENBRFc7S0FBckIsTUFFTSxJQUFHLFNBQVMsU0FBVCxFQUFtQjtBQUMxQixjQUFRLEtBQUssR0FBTCxDQUFTLFVBQVUsR0FBVixHQUFnQixLQUFLLEVBQUwsQ0FBekIsR0FBb0MsUUFBcEMsQ0FEa0I7S0FBdEI7QUFHTixXQUFPLENBQVAsSUFBWSxLQUFaLENBUDJCO0FBUTNCLFFBQUcsTUFBTSxXQUFXLENBQVgsRUFBYTtBQUNwQixhQUFPLENBQVAsSUFBWSxTQUFTLFFBQVQsR0FBb0IsQ0FBcEIsR0FBd0IsQ0FBeEIsQ0FEUTtLQUF0QjtHQVJGO0FBWUEsU0FBTyxNQUFQLENBaEIyRDtDQUF0RCIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCJpbXBvcnQgcWFtYmksIHtcbiAgU29uZyxcbn0gZnJvbSAnLi4vLi4vc3JjL3FhbWJpJ1xuXG5cbmltcG9ydCBmZXRjaCBmcm9tICdpc29tb3JwaGljLWZldGNoJ1xuXG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgZnVuY3Rpb24oKXtcblxuICBsZXQgc29uZ1xuXG4gIHFhbWJpLmluaXQoKVxuICAudGhlbigoKSA9PiB7XG5cbiAgICBsZXQgdGVzdCA9IDJcblxuICAgIGlmKHRlc3QgPT09IDEpe1xuXG4gICAgICAvL2NvbnNvbGUudGltZSgnc29uZycpXG4gICAgICBmZXRjaCgnLi4vLi4vZGF0YS9tb3prNTQ1YS5taWQnKVxuICAgICAgLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuYXJyYXlCdWZmZXIoKVxuICAgICAgfSlcbiAgICAgIC50aGVuKGRhdGEgPT4ge1xuICAgICAgICBzb25nID0gU29uZy5mcm9tTUlESUZpbGUoZGF0YSlcbiAgICAgICAgaW5pdFVJKClcbiAgICAgICAgLy9jb25zb2xlLnRpbWVFbmQoJ3NvbmcnKVxuICAgICAgfSlcblxuICAgIH1lbHNlIGlmKHRlc3QgPT09IDIpe1xuXG4gICAgICAvL2NvbnNvbGUudGltZSgnc29uZycpXG4gICAgICBTb25nLmZyb21NSURJRmlsZUFzeW5jKCcuLi8uLi9kYXRhL21pbnV0ZV93YWx0ei5taWQnKVxuICAgICAgLnRoZW4ocyA9PiB7XG4gICAgICAgIHNvbmcgPSBzXG4gICAgICAgIC8vY29uc29sZS50aW1lRW5kKCdzb25nJylcbiAgICAgICAgaW5pdFVJKClcbiAgICAgIH0sIGUgPT4gY29uc29sZS5sb2coZSkpXG4gICAgfVxuICB9KVxuXG5cbiAgZnVuY3Rpb24gaW5pdFVJKCl7XG5cbiAgICBsZXQgYnRuUGxheSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwbGF5JylcbiAgICBsZXQgYnRuUGF1c2UgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncGF1c2UnKVxuICAgIGxldCBidG5TdG9wID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3N0b3AnKVxuICAgIGxldCBkaXZUZW1wbyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0ZW1wbycpXG4gICAgbGV0IGRpdlBvc2l0aW9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Bvc2l0aW9uJylcbiAgICBsZXQgZGl2UG9zaXRpb25UaW1lID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Bvc2l0aW9uX3RpbWUnKVxuICAgIGxldCByYW5nZVBvc2l0aW9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3BsYXloZWFkJylcbiAgICBsZXQgdXNlckludGVyYWN0aW9uID0gZmFsc2VcblxuICAgIGJ0blBsYXkuZGlzYWJsZWQgPSBmYWxzZVxuICAgIGJ0blBhdXNlLmRpc2FibGVkID0gZmFsc2VcbiAgICBidG5TdG9wLmRpc2FibGVkID0gZmFsc2VcblxuICAgIGJ0blBsYXkuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbigpe1xuICAgICAgLy9zb25nLnBsYXkoJ2JhcnNiZWF0cycsIDQsIDEsIDEsIDApXG4gICAgICAvL3NvbmcucGxheSgndGltZScsIDAsIDAsIDE1KSAvLyBwbGF5IGZyb20gMTUgc2Vjb25kc1xuICAgICAgLy9zb25nLnBsYXkoJ21pbGxpcycsIDM0MDAwKSAvLyBwbGF5IGZyb20gMzQgc2Vjb25kc1xuICAgICAgc29uZy5wbGF5KClcbiAgICB9KTtcblxuICAgIGJ0blBhdXNlLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oKXtcbiAgICAgIHNvbmcucGF1c2UoKVxuICAgIH0pXG5cbiAgICBidG5TdG9wLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oKXtcbiAgICAgIHNvbmcuc3RvcCgpXG4gICAgfSlcblxuICAgIC8vIHNvbmcuYWRkRXZlbnRMaXN0ZW5lcihxYW1iaS5URU1QTywgZXZlbnQgPT4ge1xuICAgIC8vICAgZGl2VGVtcG8uaW5uZXJIVE1MID0gYHRlbXBvOiAke2V2ZW50LmJwbX0gYnBtYFxuICAgIC8vIH0pXG5cblxuICAgIHNvbmcuYWRkRXZlbnRMaXN0ZW5lcignbm90ZU9uJywgZXZlbnQgPT4ge1xuICAgICAgbGV0IG5vdGUgPSBldmVudC5kYXRhXG4gICAgICAvL2NvbnNvbGUubG9nKCdub3RlT24nLCBub3RlLmlkLCBub3RlLm5vdGVPbi5pZCwgbm90ZS5ub3RlT24uZGF0YTEsIG5vdGUubm90ZU9uLnRpY2tzKVxuICAgIH0pXG5cbiAgICBzb25nLmFkZEV2ZW50TGlzdGVuZXIoJ25vdGVPZmYnLCBldmVudCA9PiB7XG4gICAgICBsZXQgbm90ZSA9IGV2ZW50LmRhdGFcbiAgICAgIC8vY29uc29sZS5sb2coJ25vdGVPZmYnLCBub3RlLmlkLCBub3RlLm5vdGVPZmYuaWQsIG5vdGUubm90ZU9mZi5kYXRhMSwgbm90ZS5ub3RlT2ZmLnRpY2tzKVxuICAgIH0pXG5cbiAgICBzb25nLmFkZEV2ZW50TGlzdGVuZXIoJ3BsYXknLCBldmVudCA9PiB7XG4gICAgICBjb25zb2xlLmxvZygnc3RhcnRlZCBwbGF5aW5nIGF0IHBvc2l0aW9uOicsIGV2ZW50LmRhdGEpXG4gICAgfSlcblxuICAgIHNvbmcuYWRkRXZlbnRMaXN0ZW5lcignc3RvcCcsICgpID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKCdzdG9wJylcbiAgICAgIHJhbmdlUG9zaXRpb24udmFsdWUgPSAwXG4gICAgfSlcblxuICAgIHNvbmcuYWRkRXZlbnRMaXN0ZW5lcigncGF1c2UnLCBldmVudCA9PiB7XG4gICAgICBjb25zb2xlLmxvZygncGF1c2VkOicsIGV2ZW50LmRhdGEpXG4gICAgfSlcblxuICAgIGxldCBwb3NpdGlvbiA9IHNvbmcuZ2V0UG9zaXRpb24oKVxuICAgIGRpdlBvc2l0aW9uLmlubmVySFRNTCA9IHBvc2l0aW9uLmJhcnNBc1N0cmluZ1xuICAgIGRpdlBvc2l0aW9uVGltZS5pbm5lckhUTUwgPSBwb3NpdGlvbi50aW1lQXNTdHJpbmdcbiAgICBkaXZUZW1wby5pbm5lckhUTUwgPSBgdGVtcG86ICR7cG9zaXRpb24uYnBtfSBicG1gXG5cbiAgICBzb25nLmFkZEV2ZW50TGlzdGVuZXIoJ3Bvc2l0aW9uJywgZXZlbnQgPT4ge1xuICAgICAgZGl2UG9zaXRpb24uaW5uZXJIVE1MID0gZXZlbnQuZGF0YS5iYXJzQXNTdHJpbmdcbiAgICAgIGRpdlBvc2l0aW9uVGltZS5pbm5lckhUTUwgPSBldmVudC5kYXRhLnRpbWVBc1N0cmluZ1xuICAgICAgZGl2VGVtcG8uaW5uZXJIVE1MID0gYHRlbXBvOiAke2V2ZW50LmRhdGEuYnBtfSBicG1gXG4gICAgICBpZighdXNlckludGVyYWN0aW9uKXtcbiAgICAgICAgcmFuZ2VQb3NpdGlvbi52YWx1ZSA9IGV2ZW50LmRhdGEucGVyY2VudGFnZVxuICAgICAgfVxuICAgIH0pXG5cbiAgICByYW5nZVBvc2l0aW9uLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBlID0+IHtcbiAgICAgIHJhbmdlUG9zaXRpb24ucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgcmFuZ2VMaXN0ZW5lcilcbiAgICAgIHVzZXJJbnRlcmFjdGlvbiA9IGZhbHNlXG4gICAgfSlcblxuICAgIHJhbmdlUG9zaXRpb24uYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgZSA9PiB7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgIHNvbmcuc2V0UG9zaXRpb24oJ3BlcmNlbnRhZ2UnLCBlLnRhcmdldC52YWx1ZUFzTnVtYmVyKVxuICAgICAgfSwgMClcbiAgICAgIHJhbmdlUG9zaXRpb24uYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgcmFuZ2VMaXN0ZW5lcilcbiAgICAgIHVzZXJJbnRlcmFjdGlvbiA9IHRydWVcbiAgICB9KVxuXG4gICAgY29uc3QgcmFuZ2VMaXN0ZW5lciA9IGZ1bmN0aW9uKGUpe1xuICAgICAgc29uZy5zZXRQb3NpdGlvbigncGVyY2VudGFnZScsIGUudGFyZ2V0LnZhbHVlQXNOdW1iZXIpXG4gICAgfVxuICB9XG5cbn0pXG4iLCIvLyB0aGUgd2hhdHdnLWZldGNoIHBvbHlmaWxsIGluc3RhbGxzIHRoZSBmZXRjaCgpIGZ1bmN0aW9uXG4vLyBvbiB0aGUgZ2xvYmFsIG9iamVjdCAod2luZG93IG9yIHNlbGYpXG4vL1xuLy8gUmV0dXJuIHRoYXQgYXMgdGhlIGV4cG9ydCBmb3IgdXNlIGluIFdlYnBhY2ssIEJyb3dzZXJpZnkgZXRjLlxucmVxdWlyZSgnd2hhdHdnLWZldGNoJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHNlbGYuZmV0Y2guYmluZChzZWxmKTtcbiIsIihmdW5jdGlvbihzZWxmKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBpZiAoc2VsZi5mZXRjaCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplTmFtZShuYW1lKSB7XG4gICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgbmFtZSA9IFN0cmluZyhuYW1lKVxuICAgIH1cbiAgICBpZiAoL1teYS16MC05XFwtIyQlJicqKy5cXF5fYHx+XS9pLnRlc3QobmFtZSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgY2hhcmFjdGVyIGluIGhlYWRlciBmaWVsZCBuYW1lJylcbiAgICB9XG4gICAgcmV0dXJuIG5hbWUudG9Mb3dlckNhc2UoKVxuICB9XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgdmFsdWUgPSBTdHJpbmcodmFsdWUpXG4gICAgfVxuICAgIHJldHVybiB2YWx1ZVxuICB9XG5cbiAgZnVuY3Rpb24gSGVhZGVycyhoZWFkZXJzKSB7XG4gICAgdGhpcy5tYXAgPSB7fVxuXG4gICAgaWYgKGhlYWRlcnMgaW5zdGFuY2VvZiBIZWFkZXJzKSB7XG4gICAgICBoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgICAgdGhpcy5hcHBlbmQobmFtZSwgdmFsdWUpXG4gICAgICB9LCB0aGlzKVxuXG4gICAgfSBlbHNlIGlmIChoZWFkZXJzKSB7XG4gICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhoZWFkZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdGhpcy5hcHBlbmQobmFtZSwgaGVhZGVyc1tuYW1lXSlcbiAgICAgIH0sIHRoaXMpXG4gICAgfVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICBuYW1lID0gbm9ybWFsaXplTmFtZShuYW1lKVxuICAgIHZhbHVlID0gbm9ybWFsaXplVmFsdWUodmFsdWUpXG4gICAgdmFyIGxpc3QgPSB0aGlzLm1hcFtuYW1lXVxuICAgIGlmICghbGlzdCkge1xuICAgICAgbGlzdCA9IFtdXG4gICAgICB0aGlzLm1hcFtuYW1lXSA9IGxpc3RcbiAgICB9XG4gICAgbGlzdC5wdXNoKHZhbHVlKVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGVbJ2RlbGV0ZSddID0gZnVuY3Rpb24obmFtZSkge1xuICAgIGRlbGV0ZSB0aGlzLm1hcFtub3JtYWxpemVOYW1lKG5hbWUpXVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciB2YWx1ZXMgPSB0aGlzLm1hcFtub3JtYWxpemVOYW1lKG5hbWUpXVxuICAgIHJldHVybiB2YWx1ZXMgPyB2YWx1ZXNbMF0gOiBudWxsXG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5nZXRBbGwgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwW25vcm1hbGl6ZU5hbWUobmFtZSldIHx8IFtdXG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwLmhhc093blByb3BlcnR5KG5vcm1hbGl6ZU5hbWUobmFtZSkpXG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIHRoaXMubWFwW25vcm1hbGl6ZU5hbWUobmFtZSldID0gW25vcm1hbGl6ZVZhbHVlKHZhbHVlKV1cbiAgfVxuXG4gIEhlYWRlcnMucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbihjYWxsYmFjaywgdGhpc0FyZykge1xuICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMubWFwKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHRoaXMubWFwW25hbWVdLmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB2YWx1ZSwgbmFtZSwgdGhpcylcbiAgICAgIH0sIHRoaXMpXG4gICAgfSwgdGhpcylcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbnN1bWVkKGJvZHkpIHtcbiAgICBpZiAoYm9keS5ib2R5VXNlZCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBUeXBlRXJyb3IoJ0FscmVhZHkgcmVhZCcpKVxuICAgIH1cbiAgICBib2R5LmJvZHlVc2VkID0gdHJ1ZVxuICB9XG5cbiAgZnVuY3Rpb24gZmlsZVJlYWRlclJlYWR5KHJlYWRlcikge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVzb2x2ZShyZWFkZXIucmVzdWx0KVxuICAgICAgfVxuICAgICAgcmVhZGVyLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVqZWN0KHJlYWRlci5lcnJvcilcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZEJsb2JBc0FycmF5QnVmZmVyKGJsb2IpIHtcbiAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKVxuICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihibG9iKVxuICAgIHJldHVybiBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZEJsb2JBc1RleHQoYmxvYikge1xuICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpXG4gICAgcmVhZGVyLnJlYWRBc1RleHQoYmxvYilcbiAgICByZXR1cm4gZmlsZVJlYWRlclJlYWR5KHJlYWRlcilcbiAgfVxuXG4gIHZhciBzdXBwb3J0ID0ge1xuICAgIGJsb2I6ICdGaWxlUmVhZGVyJyBpbiBzZWxmICYmICdCbG9iJyBpbiBzZWxmICYmIChmdW5jdGlvbigpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG5ldyBCbG9iKCk7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfSkoKSxcbiAgICBmb3JtRGF0YTogJ0Zvcm1EYXRhJyBpbiBzZWxmLFxuICAgIGFycmF5QnVmZmVyOiAnQXJyYXlCdWZmZXInIGluIHNlbGZcbiAgfVxuXG4gIGZ1bmN0aW9uIEJvZHkoKSB7XG4gICAgdGhpcy5ib2R5VXNlZCA9IGZhbHNlXG5cblxuICAgIHRoaXMuX2luaXRCb2R5ID0gZnVuY3Rpb24oYm9keSkge1xuICAgICAgdGhpcy5fYm9keUluaXQgPSBib2R5XG4gICAgICBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMuX2JvZHlUZXh0ID0gYm9keVxuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmJsb2IgJiYgQmxvYi5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICB0aGlzLl9ib2R5QmxvYiA9IGJvZHlcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5mb3JtRGF0YSAmJiBGb3JtRGF0YS5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICB0aGlzLl9ib2R5Rm9ybURhdGEgPSBib2R5XG4gICAgICB9IGVsc2UgaWYgKCFib2R5KSB7XG4gICAgICAgIHRoaXMuX2JvZHlUZXh0ID0gJydcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5hcnJheUJ1ZmZlciAmJiBBcnJheUJ1ZmZlci5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICAvLyBPbmx5IHN1cHBvcnQgQXJyYXlCdWZmZXJzIGZvciBQT1NUIG1ldGhvZC5cbiAgICAgICAgLy8gUmVjZWl2aW5nIEFycmF5QnVmZmVycyBoYXBwZW5zIHZpYSBCbG9icywgaW5zdGVhZC5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5zdXBwb3J0ZWQgQm9keUluaXQgdHlwZScpXG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJykpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsICd0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLTgnKVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlCbG9iICYmIHRoaXMuX2JvZHlCbG9iLnR5cGUpIHtcbiAgICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCdjb250ZW50LXR5cGUnLCB0aGlzLl9ib2R5QmxvYi50eXBlKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN1cHBvcnQuYmxvYikge1xuICAgICAgdGhpcy5ibG9iID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZWplY3RlZCA9IGNvbnN1bWVkKHRoaXMpXG4gICAgICAgIGlmIChyZWplY3RlZCkge1xuICAgICAgICAgIHJldHVybiByZWplY3RlZFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2JvZHlCbG9iKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5QmxvYilcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5Rm9ybURhdGEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkIG5vdCByZWFkIEZvcm1EYXRhIGJvZHkgYXMgYmxvYicpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgQmxvYihbdGhpcy5fYm9keVRleHRdKSlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmFycmF5QnVmZmVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJsb2IoKS50aGVuKHJlYWRCbG9iQXNBcnJheUJ1ZmZlcilcbiAgICAgIH1cblxuICAgICAgdGhpcy50ZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZWplY3RlZCA9IGNvbnN1bWVkKHRoaXMpXG4gICAgICAgIGlmIChyZWplY3RlZCkge1xuICAgICAgICAgIHJldHVybiByZWplY3RlZFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2JvZHlCbG9iKSB7XG4gICAgICAgICAgcmV0dXJuIHJlYWRCbG9iQXNUZXh0KHRoaXMuX2JvZHlCbG9iKVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlGb3JtRGF0YSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHJlYWQgRm9ybURhdGEgYm9keSBhcyB0ZXh0JylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2JvZHlUZXh0KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVqZWN0ZWQgPSBjb25zdW1lZCh0aGlzKVxuICAgICAgICByZXR1cm4gcmVqZWN0ZWQgPyByZWplY3RlZCA6IFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5VGV4dClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3VwcG9ydC5mb3JtRGF0YSkge1xuICAgICAgdGhpcy5mb3JtRGF0YSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXh0KCkudGhlbihkZWNvZGUpXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5qc29uID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZXh0KCkudGhlbihKU09OLnBhcnNlKVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvLyBIVFRQIG1ldGhvZHMgd2hvc2UgY2FwaXRhbGl6YXRpb24gc2hvdWxkIGJlIG5vcm1hbGl6ZWRcbiAgdmFyIG1ldGhvZHMgPSBbJ0RFTEVURScsICdHRVQnLCAnSEVBRCcsICdPUFRJT05TJywgJ1BPU1QnLCAnUFVUJ11cblxuICBmdW5jdGlvbiBub3JtYWxpemVNZXRob2QobWV0aG9kKSB7XG4gICAgdmFyIHVwY2FzZWQgPSBtZXRob2QudG9VcHBlckNhc2UoKVxuICAgIHJldHVybiAobWV0aG9kcy5pbmRleE9mKHVwY2FzZWQpID4gLTEpID8gdXBjYXNlZCA6IG1ldGhvZFxuICB9XG5cbiAgZnVuY3Rpb24gUmVxdWVzdChpbnB1dCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gICAgdmFyIGJvZHkgPSBvcHRpb25zLmJvZHlcbiAgICBpZiAoUmVxdWVzdC5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihpbnB1dCkpIHtcbiAgICAgIGlmIChpbnB1dC5ib2R5VXNlZCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBbHJlYWR5IHJlYWQnKVxuICAgICAgfVxuICAgICAgdGhpcy51cmwgPSBpbnB1dC51cmxcbiAgICAgIHRoaXMuY3JlZGVudGlhbHMgPSBpbnB1dC5jcmVkZW50aWFsc1xuICAgICAgaWYgKCFvcHRpb25zLmhlYWRlcnMpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMoaW5wdXQuaGVhZGVycylcbiAgICAgIH1cbiAgICAgIHRoaXMubWV0aG9kID0gaW5wdXQubWV0aG9kXG4gICAgICB0aGlzLm1vZGUgPSBpbnB1dC5tb2RlXG4gICAgICBpZiAoIWJvZHkpIHtcbiAgICAgICAgYm9keSA9IGlucHV0Ll9ib2R5SW5pdFxuICAgICAgICBpbnB1dC5ib2R5VXNlZCA9IHRydWVcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51cmwgPSBpbnB1dFxuICAgIH1cblxuICAgIHRoaXMuY3JlZGVudGlhbHMgPSBvcHRpb25zLmNyZWRlbnRpYWxzIHx8IHRoaXMuY3JlZGVudGlhbHMgfHwgJ29taXQnXG4gICAgaWYgKG9wdGlvbnMuaGVhZGVycyB8fCAhdGhpcy5oZWFkZXJzKSB7XG4gICAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhvcHRpb25zLmhlYWRlcnMpXG4gICAgfVxuICAgIHRoaXMubWV0aG9kID0gbm9ybWFsaXplTWV0aG9kKG9wdGlvbnMubWV0aG9kIHx8IHRoaXMubWV0aG9kIHx8ICdHRVQnKVxuICAgIHRoaXMubW9kZSA9IG9wdGlvbnMubW9kZSB8fCB0aGlzLm1vZGUgfHwgbnVsbFxuICAgIHRoaXMucmVmZXJyZXIgPSBudWxsXG5cbiAgICBpZiAoKHRoaXMubWV0aG9kID09PSAnR0VUJyB8fCB0aGlzLm1ldGhvZCA9PT0gJ0hFQUQnKSAmJiBib2R5KSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCb2R5IG5vdCBhbGxvd2VkIGZvciBHRVQgb3IgSEVBRCByZXF1ZXN0cycpXG4gICAgfVxuICAgIHRoaXMuX2luaXRCb2R5KGJvZHkpXG4gIH1cblxuICBSZXF1ZXN0LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgUmVxdWVzdCh0aGlzKVxuICB9XG5cbiAgZnVuY3Rpb24gZGVjb2RlKGJvZHkpIHtcbiAgICB2YXIgZm9ybSA9IG5ldyBGb3JtRGF0YSgpXG4gICAgYm9keS50cmltKCkuc3BsaXQoJyYnKS5mb3JFYWNoKGZ1bmN0aW9uKGJ5dGVzKSB7XG4gICAgICBpZiAoYnl0ZXMpIHtcbiAgICAgICAgdmFyIHNwbGl0ID0gYnl0ZXMuc3BsaXQoJz0nKVxuICAgICAgICB2YXIgbmFtZSA9IHNwbGl0LnNoaWZ0KCkucmVwbGFjZSgvXFwrL2csICcgJylcbiAgICAgICAgdmFyIHZhbHVlID0gc3BsaXQuam9pbignPScpLnJlcGxhY2UoL1xcKy9nLCAnICcpXG4gICAgICAgIGZvcm0uYXBwZW5kKGRlY29kZVVSSUNvbXBvbmVudChuYW1lKSwgZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKSlcbiAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiBmb3JtXG4gIH1cblxuICBmdW5jdGlvbiBoZWFkZXJzKHhocikge1xuICAgIHZhciBoZWFkID0gbmV3IEhlYWRlcnMoKVxuICAgIHZhciBwYWlycyA9IHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKS50cmltKCkuc3BsaXQoJ1xcbicpXG4gICAgcGFpcnMuZm9yRWFjaChmdW5jdGlvbihoZWFkZXIpIHtcbiAgICAgIHZhciBzcGxpdCA9IGhlYWRlci50cmltKCkuc3BsaXQoJzonKVxuICAgICAgdmFyIGtleSA9IHNwbGl0LnNoaWZ0KCkudHJpbSgpXG4gICAgICB2YXIgdmFsdWUgPSBzcGxpdC5qb2luKCc6JykudHJpbSgpXG4gICAgICBoZWFkLmFwcGVuZChrZXksIHZhbHVlKVxuICAgIH0pXG4gICAgcmV0dXJuIGhlYWRcbiAgfVxuXG4gIEJvZHkuY2FsbChSZXF1ZXN0LnByb3RvdHlwZSlcblxuICBmdW5jdGlvbiBSZXNwb25zZShib2R5SW5pdCwgb3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IHt9XG4gICAgfVxuXG4gICAgdGhpcy50eXBlID0gJ2RlZmF1bHQnXG4gICAgdGhpcy5zdGF0dXMgPSBvcHRpb25zLnN0YXR1c1xuICAgIHRoaXMub2sgPSB0aGlzLnN0YXR1cyA+PSAyMDAgJiYgdGhpcy5zdGF0dXMgPCAzMDBcbiAgICB0aGlzLnN0YXR1c1RleHQgPSBvcHRpb25zLnN0YXR1c1RleHRcbiAgICB0aGlzLmhlYWRlcnMgPSBvcHRpb25zLmhlYWRlcnMgaW5zdGFuY2VvZiBIZWFkZXJzID8gb3B0aW9ucy5oZWFkZXJzIDogbmV3IEhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKVxuICAgIHRoaXMudXJsID0gb3B0aW9ucy51cmwgfHwgJydcbiAgICB0aGlzLl9pbml0Qm9keShib2R5SW5pdClcbiAgfVxuXG4gIEJvZHkuY2FsbChSZXNwb25zZS5wcm90b3R5cGUpXG5cbiAgUmVzcG9uc2UucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZSh0aGlzLl9ib2R5SW5pdCwge1xuICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICAgIHN0YXR1c1RleHQ6IHRoaXMuc3RhdHVzVGV4dCxcbiAgICAgIGhlYWRlcnM6IG5ldyBIZWFkZXJzKHRoaXMuaGVhZGVycyksXG4gICAgICB1cmw6IHRoaXMudXJsXG4gICAgfSlcbiAgfVxuXG4gIFJlc3BvbnNlLmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKG51bGwsIHtzdGF0dXM6IDAsIHN0YXR1c1RleHQ6ICcnfSlcbiAgICByZXNwb25zZS50eXBlID0gJ2Vycm9yJ1xuICAgIHJldHVybiByZXNwb25zZVxuICB9XG5cbiAgdmFyIHJlZGlyZWN0U3RhdHVzZXMgPSBbMzAxLCAzMDIsIDMwMywgMzA3LCAzMDhdXG5cbiAgUmVzcG9uc2UucmVkaXJlY3QgPSBmdW5jdGlvbih1cmwsIHN0YXR1cykge1xuICAgIGlmIChyZWRpcmVjdFN0YXR1c2VzLmluZGV4T2Yoc3RhdHVzKSA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHN0YXR1cyBjb2RlJylcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKG51bGwsIHtzdGF0dXM6IHN0YXR1cywgaGVhZGVyczoge2xvY2F0aW9uOiB1cmx9fSlcbiAgfVxuXG4gIHNlbGYuSGVhZGVycyA9IEhlYWRlcnM7XG4gIHNlbGYuUmVxdWVzdCA9IFJlcXVlc3Q7XG4gIHNlbGYuUmVzcG9uc2UgPSBSZXNwb25zZTtcblxuICBzZWxmLmZldGNoID0gZnVuY3Rpb24oaW5wdXQsIGluaXQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVxdWVzdFxuICAgICAgaWYgKFJlcXVlc3QucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoaW5wdXQpICYmICFpbml0KSB7XG4gICAgICAgIHJlcXVlc3QgPSBpbnB1dFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KGlucHV0LCBpbml0KVxuICAgICAgfVxuXG4gICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KClcblxuICAgICAgZnVuY3Rpb24gcmVzcG9uc2VVUkwoKSB7XG4gICAgICAgIGlmICgncmVzcG9uc2VVUkwnIGluIHhocikge1xuICAgICAgICAgIHJldHVybiB4aHIucmVzcG9uc2VVUkxcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEF2b2lkIHNlY3VyaXR5IHdhcm5pbmdzIG9uIGdldFJlc3BvbnNlSGVhZGVyIHdoZW4gbm90IGFsbG93ZWQgYnkgQ09SU1xuICAgICAgICBpZiAoL15YLVJlcXVlc3QtVVJMOi9tLnRlc3QoeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpKSkge1xuICAgICAgICAgIHJldHVybiB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ1gtUmVxdWVzdC1VUkwnKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB4aHIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdGF0dXMgPSAoeGhyLnN0YXR1cyA9PT0gMTIyMykgPyAyMDQgOiB4aHIuc3RhdHVzXG4gICAgICAgIGlmIChzdGF0dXMgPCAxMDAgfHwgc3RhdHVzID4gNTk5KSB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBUeXBlRXJyb3IoJ05ldHdvcmsgcmVxdWVzdCBmYWlsZWQnKSlcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICBzdGF0dXM6IHN0YXR1cyxcbiAgICAgICAgICBzdGF0dXNUZXh0OiB4aHIuc3RhdHVzVGV4dCxcbiAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJzKHhociksXG4gICAgICAgICAgdXJsOiByZXNwb25zZVVSTCgpXG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJvZHkgPSAncmVzcG9uc2UnIGluIHhociA/IHhoci5yZXNwb25zZSA6IHhoci5yZXNwb25zZVRleHQ7XG4gICAgICAgIHJlc29sdmUobmV3IFJlc3BvbnNlKGJvZHksIG9wdGlvbnMpKVxuICAgICAgfVxuXG4gICAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QobmV3IFR5cGVFcnJvcignTmV0d29yayByZXF1ZXN0IGZhaWxlZCcpKVxuICAgICAgfVxuXG4gICAgICB4aHIub3BlbihyZXF1ZXN0Lm1ldGhvZCwgcmVxdWVzdC51cmwsIHRydWUpXG5cbiAgICAgIGlmIChyZXF1ZXN0LmNyZWRlbnRpYWxzID09PSAnaW5jbHVkZScpIHtcbiAgICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWVcbiAgICAgIH1cblxuICAgICAgaWYgKCdyZXNwb25zZVR5cGUnIGluIHhociAmJiBzdXBwb3J0LmJsb2IpIHtcbiAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdibG9iJ1xuICAgICAgfVxuXG4gICAgICByZXF1ZXN0LmhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihuYW1lLCB2YWx1ZSlcbiAgICAgIH0pXG5cbiAgICAgIHhoci5zZW5kKHR5cGVvZiByZXF1ZXN0Ll9ib2R5SW5pdCA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogcmVxdWVzdC5fYm9keUluaXQpXG4gICAgfSlcbiAgfVxuICBzZWxmLmZldGNoLnBvbHlmaWxsID0gdHJ1ZVxufSkodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHRoaXMpO1xuIiwibGV0IGV2ZW50TGlzdGVuZXJzID0gbmV3IE1hcCgpO1xuXG5cbmV4cG9ydCBmdW5jdGlvbiBkaXNwYXRjaEV2ZW50KGV2ZW50KXtcbiAgLy9jb25zb2xlLmxvZyhldmVudC50eXBlKVxuICBsZXQgbWFwXG5cbiAgaWYoZXZlbnQudHlwZSA9PT0gJ2V2ZW50Jyl7XG4gICAgbGV0IG1pZGlFdmVudCA9IGV2ZW50LmRhdGFcbiAgICBsZXQgbWlkaUV2ZW50VHlwZSA9IG1pZGlFdmVudC50eXBlXG4gICAgLy9jb25zb2xlLmxvZyhtaWRpRXZlbnRUeXBlKVxuICAgIGlmKGV2ZW50TGlzdGVuZXJzLmhhcyhtaWRpRXZlbnRUeXBlKSl7XG4gICAgICBtYXAgPSBldmVudExpc3RlbmVycy5nZXQobWlkaUV2ZW50VHlwZSlcbiAgICAgIGZvcihsZXQgY2Igb2YgbWFwLnZhbHVlcygpKXtcbiAgICAgICAgY2IobWlkaUV2ZW50KVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG5cbiAgaWYoZXZlbnRMaXN0ZW5lcnMuaGFzKGV2ZW50LnR5cGUpID09PSBmYWxzZSl7XG4gICAgcmV0dXJuXG4gIH1cblxuICBtYXAgPSBldmVudExpc3RlbmVycy5nZXQoZXZlbnQudHlwZSlcbiAgZm9yKGxldCBjYiBvZiBtYXAudmFsdWVzKCkpe1xuICAgIGNiKGV2ZW50KVxuICB9XG5cblxuICAvLyBAdG9kbzogcnVuIGZpbHRlcnMgaGVyZSwgZm9yIGluc3RhbmNlIGlmIGFuIGV2ZW50bGlzdGVuZXIgaGFzIGJlZW4gYWRkZWQgdG8gYWxsIE5PVEVfT04gZXZlbnRzLCBjaGVjayB0aGUgdHlwZSBvZiB0aGUgaW5jb21pbmcgZXZlbnRcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcih0eXBlOiBzdHJpbmcsIGNhbGxiYWNrKXtcblxuICBsZXQgbWFwXG4gIGxldCBpZCA9IGAke3R5cGV9XyR7bmV3IERhdGUoKS5nZXRUaW1lKCl9YFxuXG4gIGlmKGV2ZW50TGlzdGVuZXJzLmhhcyh0eXBlKSA9PT0gZmFsc2Upe1xuICAgIG1hcCA9IG5ldyBNYXAoKVxuICAgIGV2ZW50TGlzdGVuZXJzLnNldCh0eXBlLCBtYXApXG4gIH1lbHNle1xuICAgIG1hcCA9IGV2ZW50TGlzdGVuZXJzLmdldCh0eXBlKVxuICB9XG5cbiAgbWFwLnNldChpZCwgY2FsbGJhY2spXG4gIC8vY29uc29sZS5sb2coZXZlbnRMaXN0ZW5lcnMpXG4gIHJldHVybiBpZFxufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGlkKXtcblxuICBpZihldmVudExpc3RlbmVycy5oYXModHlwZSkgPT09IGZhbHNlKXtcbiAgICBjb25zb2xlLmxvZygnbm8gZXZlbnRsaXN0ZW5lcnMgb2YgdHlwZScgKyB0eXBlKVxuICAgIHJldHVyblxuICB9XG5cbiAgbGV0IG1hcCA9IGV2ZW50TGlzdGVuZXJzLmdldCh0eXBlKVxuXG4gIGlmKHR5cGVvZiBpZCA9PT0gJ2Z1bmN0aW9uJyl7XG4gICAgZm9yKGxldCBba2V5LCB2YWx1ZV0gb2YgbWFwLmVudHJpZXMoKSkge1xuICAgICAgY29uc29sZS5sb2coa2V5LCB2YWx1ZSlcbiAgICAgIGlmKHZhbHVlID09PSBpZCl7XG4gICAgICAgIGNvbnNvbGUubG9nKGtleSlcbiAgICAgICAgaWQgPSBrZXlcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYodHlwZW9mIGlkID09PSAnc3RyaW5nJyl7XG4gICAgICBtYXAuZGVsZXRlKGlkKVxuICAgIH1cbiAgfWVsc2UgaWYodHlwZW9mIGlkID09PSAnc3RyaW5nJyl7XG4gICAgbWFwLmRlbGV0ZShpZClcbiAgfWVsc2V7XG4gICAgY29uc29sZS5sb2coJ2NvdWxkIG5vdCByZW1vdmUgZXZlbnRsaXN0ZW5lcicpXG4gIH1cbn1cblxuIiwiLy8gZmV0Y2ggaGVscGVyc1xuXG5leHBvcnQgZnVuY3Rpb24gc3RhdHVzKHJlc3BvbnNlKSB7XG4gIGlmKHJlc3BvbnNlLnN0YXR1cyA+PSAyMDAgJiYgcmVzcG9uc2Uuc3RhdHVzIDwgMzAwKXtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3BvbnNlKVxuICB9XG4gIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IocmVzcG9uc2Uuc3RhdHVzVGV4dCkpXG5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGpzb24ocmVzcG9uc2Upe1xuICByZXR1cm4gcmVzcG9uc2UuanNvbigpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcnJheUJ1ZmZlcihyZXNwb25zZSl7XG4gIHJldHVybiByZXNwb25zZS5hcnJheUJ1ZmZlcigpXG59XG4iLCJpbXBvcnQge2luaXRBdWRpb30gZnJvbSAnLi9pbml0X2F1ZGlvJ1xuaW1wb3J0IHtpbml0TUlESX0gZnJvbSAnLi9pbml0X21pZGknXG5cbmV4cG9ydCBsZXQgZ2V0VXNlck1lZGlhID0gKCgpID0+IHtcbiAgaWYodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcpe1xuICAgIHJldHVybiBuYXZpZ2F0b3IuZ2V0VXNlck1lZGlhIHx8IG5hdmlnYXRvci53ZWJraXRHZXRVc2VyTWVkaWEgfHwgbmF2aWdhdG9yLm1vekdldFVzZXJNZWRpYSB8fCBuYXZpZ2F0b3IubXNHZXRVc2VyTWVkaWFcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICBjb25zb2xlLndhcm4oJ2dldFVzZXJNZWRpYSBpcyBub3QgYXZhaWxhYmxlJylcbiAgfVxufSkoKVxuXG5cbmV4cG9ydCBsZXQgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gKCgpID0+IHtcbiAgaWYodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcpe1xuICAgIHJldHVybiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICBjb25zb2xlLndhcm4oJ3JlcXVlc3RBbmltYXRpb25GcmFtZSBpcyBub3QgYXZhaWxhYmxlJylcbiAgfVxufSkoKVxuXG5cbmV4cG9ydCBsZXQgQmxvYiA9ICgoKSA9PiB7XG4gIGlmKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnKXtcbiAgICByZXR1cm4gd2luZG93LkJsb2IgfHwgd2luZG93LndlYmtpdEJsb2JcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICBjb25zb2xlLndhcm4oJ0Jsb2IgaXMgbm90IGF2YWlsYWJsZScpXG4gIH1cbn0pKClcblxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdChzZXR0aW5ncyA9IHt9KTogdm9pZHtcblxuICAvLyBsb2FkIHNldHRpbmdzLmluc3RydW1lbnRzIChhcnJheSBvciBvYmplY3QpXG4gIC8vIGxvYWQgc2V0dGluZ3MubWlkaWZpbGVzIChhcnJheSBvciBvYmplY3QpXG4gIC8qXG5cbiAgICBxYW1iaS5pbml0KHtcbiAgICAgIGluc3RydW1lbnRzOiBbJy4uL2luc3RydW1lbnRzL3BpYW5vJywgJy4uL2luc3RydW1lbnRzL3Zpb2xpbiddLFxuICAgICAgbWlkaWZpbGVzOiBbJy4uL21pZGkvbW96YXJ0Lm1pZCddXG4gICAgfSlcbiAgICAudGhlbigobG9hZGVkKSA9PiB7XG4gICAgICBsZXQgW3BpYW5vLCB2aW9saW5dID0gbG9hZGVkLmluc3RydW1lbnRzXG4gICAgICBsZXQgW21vemFydF0gPSBsb2FkZWQubWlkaWZpbGVzXG4gICAgfSlcblxuICAqL1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cbiAgICBQcm9taXNlLmFsbChbaW5pdEF1ZGlvKCksIGluaXRNSURJKCldKVxuICAgIC50aGVuKFxuICAgIChkYXRhKSA9PiB7XG4gICAgICAvLyBwYXJzZUF1ZGlvXG4gICAgICBsZXQgZGF0YUF1ZGlvID0gZGF0YVswXVxuXG4gICAgICAvLyBwYXJzZU1JRElcbiAgICAgIGxldCBkYXRhTWlkaSA9IGRhdGFbMV1cblxuICAgICAgcmVzb2x2ZSh7XG4gICAgICAgIGxlZ2FjeTogZGF0YUF1ZGlvLmxlZ2FjeSxcbiAgICAgICAgbXAzOiBkYXRhQXVkaW8ubXAzLFxuICAgICAgICBvZ2c6IGRhdGFBdWRpby5vZ2csXG4gICAgICAgIG1pZGk6IGRhdGFNaWRpLm1pZGksXG4gICAgICAgIHdlYm1pZGk6IGRhdGFNaWRpLndlYm1pZGksXG4gICAgICB9KVxuICAgIH0sXG4gICAgKGVycm9yKSA9PiB7XG4gICAgICByZWplY3QoZXJyb3IpXG4gICAgfSlcbiAgfSlcbn1cbiIsIi8qXG4gIFNldHMgdXAgdGhlIGJhc2ljIGF1ZGlvIHJvdXRpbmcsIHRlc3RzIHdoaWNoIGF1ZGlvIGZvcm1hdHMgYXJlIHN1cHBvcnRlZCBhbmQgcGFyc2VzIHRoZSBzYW1wbGVzIGZvciB0aGUgbWV0cm9ub21lIHRpY2tzLlxuKi9cblxuaW1wb3J0IHNhbXBsZXMgZnJvbSAnLi9zYW1wbGVzJ1xuaW1wb3J0IHtwYXJzZVNhbXBsZXN9IGZyb20gJy4vcGFyc2VfYXVkaW8nXG5cbmxldFxuICBtYXN0ZXJHYWluLFxuICBjb21wcmVzc29yLFxuICBpbml0aWFsaXplZCA9IGZhbHNlXG5cbmV4cG9ydCBsZXQgY29udGV4dCA9IChmdW5jdGlvbigpe1xuICBjb25zb2xlLmxvZygnaW5pdCBBdWRpb0NvbnRleHQnKVxuICBsZXQgY3R4XG4gIGlmKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnKXtcbiAgICBsZXQgQXVkaW9Db250ZXh0ID0gd2luZG93LkF1ZGlvQ29udGV4dCB8fCB3aW5kb3cud2Via2l0QXVkaW9Db250ZXh0XG4gICAgaWYoQXVkaW9Db250ZXh0ICE9PSAndW5kZWZpbmVkJyl7XG4gICAgICBjdHggPSBuZXcgQXVkaW9Db250ZXh0KClcbiAgICB9XG4gIH1cbiAgaWYodHlwZW9mIGN0eCA9PT0gJ3VuZGVmaW5lZCcpe1xuICAgIC8vQFRPRE86IGNyZWF0ZSBkdW1teSBBdWRpb0NvbnRleHQgZm9yIHVzZSBpbiBub2RlLCBzZWU6IGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL2F1ZGlvLWNvbnRleHRcbiAgICBjb250ZXh0ID0ge1xuICAgICAgY3JlYXRlR2FpbjogZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBnYWluOiAxXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjcmVhdGVPc2NpbGxhdG9yOiBmdW5jdGlvbigpe30sXG4gICAgfVxuICB9XG4gIHJldHVybiBjdHhcbn0oKSlcblxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdEF1ZGlvKCl7XG5cbiAgaWYodHlwZW9mIGNvbnRleHQuY3JlYXRlR2Fpbk5vZGUgPT09ICd1bmRlZmluZWQnKXtcbiAgICBjb250ZXh0LmNyZWF0ZUdhaW5Ob2RlID0gY29udGV4dC5jcmVhdGVHYWluXG4gIH1cbiAgLy8gY2hlY2sgZm9yIG9sZGVyIGltcGxlbWVudGF0aW9ucyBvZiBXZWJBdWRpb1xuICBsZXQgZGF0YSA9IHt9XG4gIGxldCBzb3VyY2UgPSBjb250ZXh0LmNyZWF0ZUJ1ZmZlclNvdXJjZSgpXG4gIGRhdGEubGVnYWN5ID0gZmFsc2VcbiAgaWYodHlwZW9mIHNvdXJjZS5zdGFydCA9PT0gJ3VuZGVmaW5lZCcpe1xuICAgIGRhdGEubGVnYWN5ID0gdHJ1ZVxuICB9XG5cbiAgLy8gc2V0IHVwIHRoZSBlbGVtZW50YXJ5IGF1ZGlvIG5vZGVzXG4gIGNvbXByZXNzb3IgPSBjb250ZXh0LmNyZWF0ZUR5bmFtaWNzQ29tcHJlc3NvcigpXG4gIGNvbXByZXNzb3IuY29ubmVjdChjb250ZXh0LmRlc3RpbmF0aW9uKVxuICBtYXN0ZXJHYWluID0gY29udGV4dC5jcmVhdGVHYWluTm9kZSgpXG4gIG1hc3RlckdhaW4uY29ubmVjdChjb250ZXh0LmRlc3RpbmF0aW9uKVxuICBtYXN0ZXJHYWluLmdhaW4udmFsdWUgPSAwLjVcbiAgaW5pdGlhbGl6ZWQgPSB0cnVlXG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblxuICAgIHBhcnNlU2FtcGxlcyhzYW1wbGVzKS50aGVuKFxuICAgICAgZnVuY3Rpb24gb25GdWxmaWxsZWQoYnVmZmVycyl7XG4gICAgICAgIC8vY29uc29sZS5sb2coYnVmZmVycylcbiAgICAgICAgZGF0YS5vZ2cgPSB0eXBlb2YgYnVmZmVycy5lbXB0eU9nZyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgZGF0YS5tcDMgPSB0eXBlb2YgYnVmZmVycy5lbXB0eU1wMyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgZGF0YS5sb3d0aWNrID0gYnVmZmVycy5sb3d0aWNrXG4gICAgICAgIGRhdGEuaGlnaHRpY2sgPSBidWZmZXJzLmhpZ2h0aWNrXG4gICAgICAgIGlmKGRhdGEub2dnID09PSBmYWxzZSAmJiBkYXRhLm1wMyA9PT0gZmFsc2Upe1xuICAgICAgICAgIHJlamVjdCgnTm8gc3VwcG9ydCBmb3Igb2dnIG5vciBtcDMhJylcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgcmVzb2x2ZShkYXRhKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZnVuY3Rpb24gb25SZWplY3RlZCgpe1xuICAgICAgICByZWplY3QoJ1NvbWV0aGluZyB3ZW50IHdyb25nIHdoaWxlIGluaXRpYWxpemluZyBBdWRpbycpXG4gICAgICB9XG4gICAgKVxuICB9KVxufVxuXG5cbmxldCBzZXRNYXN0ZXJWb2x1bWUgPSBmdW5jdGlvbih2YWx1ZTogbnVtYmVyID0gMC41KTogdm9pZHtcbiAgaWYoaW5pdGlhbGl6ZWQgPT09IGZhbHNlKXtcbiAgICBjb25zb2xlLndhcm4oJ3BsZWFzZSBjYWxsIHFhbWJpLmluaXQoKSBmaXJzdCcpXG4gIH1lbHNlIHtcbiAgICBzZXRNYXN0ZXJWb2x1bWUgPSBmdW5jdGlvbih2YWx1ZTogbnVtYmVyID0gMC41KXtcbiAgICAgIGlmKHZhbHVlID4gMSl7XG4gICAgICAgIGNvbnNvbGUuaW5mbygnbWF4aW1hbCB2b2x1bWUgaXMgMS4wLCB2b2x1bWUgaXMgc2V0IHRvIDEuMCcpO1xuICAgICAgfVxuICAgICAgdmFsdWUgPSB2YWx1ZSA8IDAgPyAwIDogdmFsdWUgPiAxID8gMSA6IHZhbHVlXG4gICAgICBtYXN0ZXJHYWluLmdhaW4udmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgc2V0TWFzdGVyVm9sdW1lKHZhbHVlKVxuICB9XG59XG5cblxubGV0IGdldE1hc3RlclZvbHVtZSA9IGZ1bmN0aW9uKCk6IHZvaWR7XG4gIGlmKGluaXRpYWxpemVkID09PSBmYWxzZSl7XG4gICAgY29uc29sZS53YXJuKCdwbGVhc2UgY2FsbCBxYW1iaS5pbml0KCkgZmlyc3QnKVxuICB9ZWxzZSB7XG4gICAgZ2V0TWFzdGVyVm9sdW1lID0gZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiBtYXN0ZXJHYWluLmdhaW4udmFsdWVcbiAgICB9XG4gICAgcmV0dXJuIGdldE1hc3RlclZvbHVtZSgpXG4gIH1cbn1cblxuXG5sZXQgZ2V0Q29tcHJlc3Npb25SZWR1Y3Rpb24gPSBmdW5jdGlvbigpOiB2b2lke1xuICBpZihpbml0aWFsaXplZCA9PT0gZmFsc2Upe1xuICAgIGNvbnNvbGUud2FybigncGxlYXNlIGNhbGwgcWFtYmkuaW5pdCgpIGZpcnN0JylcbiAgfWVsc2Uge1xuICAgIGdldENvbXByZXNzaW9uUmVkdWN0aW9uID0gZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiBjb21wcmVzc29yLnJlZHVjdGlvbi52YWx1ZVxuICAgIH1cbiAgICByZXR1cm4gZ2V0Q29tcHJlc3Npb25SZWR1Y3Rpb24oKVxuICB9XG59XG5cblxubGV0IGVuYWJsZU1hc3RlckNvbXByZXNzb3IgPSBmdW5jdGlvbigpOiB2b2lke1xuICBpZihpbml0aWFsaXplZCA9PT0gZmFsc2Upe1xuICAgIGNvbnNvbGUud2FybigncGxlYXNlIGNhbGwgcWFtYmkuaW5pdCgpIGZpcnN0JylcbiAgfWVsc2Uge1xuICAgIGVuYWJsZU1hc3RlckNvbXByZXNzb3IgPSBmdW5jdGlvbihmbGFnOiBib29sZWFuKXtcbiAgICAgIGlmKGZsYWcpe1xuICAgICAgICBtYXN0ZXJHYWluLmRpc2Nvbm5lY3QoMCk7XG4gICAgICAgIG1hc3RlckdhaW4uY29ubmVjdChjb21wcmVzc29yKTtcbiAgICAgICAgY29tcHJlc3Nvci5kaXNjb25uZWN0KDApO1xuICAgICAgICBjb21wcmVzc29yLmNvbm5lY3QoY29udGV4dC5kZXN0aW5hdGlvbik7XG4gICAgICB9ZWxzZXtcbiAgICAgICAgY29tcHJlc3Nvci5kaXNjb25uZWN0KDApO1xuICAgICAgICBtYXN0ZXJHYWluLmRpc2Nvbm5lY3QoMCk7XG4gICAgICAgIG1hc3RlckdhaW4uY29ubmVjdChjb250ZXh0LmRlc3RpbmF0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZW5hYmxlTWFzdGVyQ29tcHJlc3NvcigpXG4gIH1cbn1cblxuXG5sZXQgY29uZmlndXJlTWFzdGVyQ29tcHJlc3NvciA9IGZ1bmN0aW9uKGNmZyk6IHZvaWR7XG4gIC8qXG4gICAgcmVhZG9ubHkgYXR0cmlidXRlIEF1ZGlvUGFyYW0gYXR0YWNrOyAvLyBpbiBTZWNvbmRzXG4gICAgcmVhZG9ubHkgYXR0cmlidXRlIEF1ZGlvUGFyYW0ga25lZTsgLy8gaW4gRGVjaWJlbHNcbiAgICByZWFkb25seSBhdHRyaWJ1dGUgQXVkaW9QYXJhbSByYXRpbzsgLy8gdW5pdC1sZXNzXG4gICAgcmVhZG9ubHkgYXR0cmlidXRlIEF1ZGlvUGFyYW0gcmVkdWN0aW9uOyAvLyBpbiBEZWNpYmVsc1xuICAgIHJlYWRvbmx5IGF0dHJpYnV0ZSBBdWRpb1BhcmFtIHJlbGVhc2U7IC8vIGluIFNlY29uZHNcbiAgICByZWFkb25seSBhdHRyaWJ1dGUgQXVkaW9QYXJhbSB0aHJlc2hvbGQ7IC8vIGluIERlY2liZWxzXG5cbiAgICBAc2VlOiBodHRwOi8vd2ViYXVkaW8uZ2l0aHViLmlvL3dlYi1hdWRpby1hcGkvI3RoZS1keW5hbWljc2NvbXByZXNzb3Jub2RlLWludGVyZmFjZVxuICAqL1xuICBpZihpbml0aWFsaXplZCA9PT0gZmFsc2Upe1xuICAgIGNvbnNvbGUud2FybigncGxlYXNlIGNhbGwgcWFtYmkuaW5pdCgpIGZpcnN0JylcbiAgfWVsc2Uge1xuICAgIGNvbmZpZ3VyZU1hc3RlckNvbXByZXNzb3IgPSBmdW5jdGlvbihjZmc6IHt9KXtcbiAgICAgICh7XG4gICAgICAgIGF0dGFjazogY29tcHJlc3Nvci5hdHRhY2sgPSAwLjAwMyxcbiAgICAgICAga25lZTogY29tcHJlc3Nvci5rbmVlID0gMzAsXG4gICAgICAgIHJhdGlvOiBjb21wcmVzc29yLnJhdGlvID0gMTIsXG4gICAgICAgIHJlZHVjdGlvbjogY29tcHJlc3Nvci5yZWR1Y3Rpb24gPSAwLFxuICAgICAgICByZWxlYXNlOiBjb21wcmVzc29yLnJlbGVhc2UgPSAwLjI1MCxcbiAgICAgICAgdGhyZXNob2xkOiBjb21wcmVzc29yLnRocmVzaG9sZCA9IC0yNCxcbiAgICAgIH0gPSBjZmcpXG4gICAgfVxuICAgIGNvbmZpZ3VyZU1hc3RlckNvbXByZXNzb3IoY2ZnKVxuICB9XG59XG5cbmV4cG9ydCB7bWFzdGVyR2FpbiwgY29tcHJlc3NvciBhcyBtYXN0ZXJDb21wcmVzc29yLCBzZXRNYXN0ZXJWb2x1bWUsIGdldE1hc3RlclZvbHVtZSwgZ2V0Q29tcHJlc3Npb25SZWR1Y3Rpb24sIGVuYWJsZU1hc3RlckNvbXByZXNzb3IsIGNvbmZpZ3VyZU1hc3RlckNvbXByZXNzb3J9XG4iLCIvKlxuICBSZXF1ZXN0cyBNSURJIGFjY2VzcywgcXVlcmllcyBhbGwgaW5wdXRzIGFuZCBvdXRwdXRzIGFuZCBzdG9yZXMgdGhlbSBpbiBhbHBoYWJldGljYWwgb3JkZXJcbiovXG5cbmltcG9ydCB7dHlwZVN0cmluZ30gZnJvbSAnLi91dGlsJ1xuXG5cbmxldCBNSURJQWNjZXNzXG5sZXQgaW5pdGlhbGl6ZWQgPSBmYWxzZVxubGV0IGlucHV0cyA9IFtdXG5sZXQgb3V0cHV0cyA9IFtdXG5sZXQgaW5wdXRJZHMgPSBbXVxubGV0IG91dHB1dElkcyA9IFtdXG5sZXQgaW5wdXRzQnlJZCA9IG5ldyBNYXAoKVxubGV0IG91dHB1dHNCeUlkID0gbmV3IE1hcCgpXG5cbmxldCBzb25nTWlkaUV2ZW50TGlzdGVuZXJcbmxldCBtaWRpRXZlbnRMaXN0ZW5lcklkID0gMFxuXG5cbmZ1bmN0aW9uIGdldE1JRElwb3J0cygpe1xuICBpbnB1dHMgPSBBcnJheS5mcm9tKE1JRElBY2Nlc3MuaW5wdXRzLnZhbHVlcygpKVxuXG4gIC8vc29ydCBwb3J0cyBieSBuYW1lIGFzY2VuZGluZ1xuICBpbnB1dHMuc29ydCgoYSwgYikgPT4gYS5uYW1lLnRvTG93ZXJDYXNlKCkgPD0gYi5uYW1lLnRvTG93ZXJDYXNlKCkgPyAxIDogLTEpXG5cbiAgZm9yKGxldCBwb3J0IG9mIGlucHV0cyl7XG4gICAgaW5wdXRzQnlJZC5zZXQocG9ydC5pZCwgcG9ydClcbiAgICBpbnB1dElkcy5wdXNoKHBvcnQuaWQpXG4gIH1cblxuICBvdXRwdXRzID0gQXJyYXkuZnJvbShNSURJQWNjZXNzLm91dHB1dHMudmFsdWVzKCkpXG5cbiAgLy9zb3J0IHBvcnRzIGJ5IG5hbWUgYXNjZW5kaW5nXG4gIG91dHB1dHMuc29ydCgoYSwgYikgPT4gYS5uYW1lLnRvTG93ZXJDYXNlKCkgPD0gYi5uYW1lLnRvTG93ZXJDYXNlKCkgPyAxIDogLTEpXG5cbiAgZm9yKGxldCBwb3J0IG9mIG91dHB1dHMpe1xuICAgIG91dHB1dHNCeUlkLnNldChwb3J0LmlkLCBwb3J0KVxuICAgIG91dHB1dElkcy5wdXNoKHBvcnQuaWQpXG4gIH1cbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdE1JREkoKXtcblxuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gZXhlY3V0b3IocmVzb2x2ZSwgcmVqZWN0KXtcblxuICAgIGlmKHR5cGVvZiBuYXZpZ2F0b3IgPT09ICd1bmRlZmluZWQnKXtcbiAgICAgIGluaXRpYWxpemVkID0gdHJ1ZVxuICAgICAgcmVzb2x2ZSh7bWlkaTogZmFsc2V9KVxuICAgIH1lbHNlIGlmKHR5cGVvZiBuYXZpZ2F0b3IucmVxdWVzdE1JRElBY2Nlc3MgIT09ICd1bmRlZmluZWQnKXtcblxuICAgICAgbGV0IGphenosIG1pZGksIHdlYm1pZGlcblxuICAgICAgbmF2aWdhdG9yLnJlcXVlc3RNSURJQWNjZXNzKCkudGhlbihcblxuICAgICAgICBmdW5jdGlvbiBvbkZ1bEZpbGxlZChtaWRpQWNjZXNzKXtcbiAgICAgICAgICBNSURJQWNjZXNzID0gbWlkaUFjY2Vzc1xuICAgICAgICAgIGlmKHR5cGVvZiBtaWRpQWNjZXNzLl9qYXp6SW5zdGFuY2VzICE9PSAndW5kZWZpbmVkJyl7XG4gICAgICAgICAgICBqYXp6ID0gbWlkaUFjY2Vzcy5famF6ekluc3RhbmNlc1swXS5fSmF6ei52ZXJzaW9uXG4gICAgICAgICAgICBtaWRpID0gdHJ1ZVxuICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgd2VibWlkaSA9IHRydWVcbiAgICAgICAgICAgIG1pZGkgPSB0cnVlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZ2V0TUlESXBvcnRzKClcblxuICAgICAgICAgIC8vIG9uY29ubmVjdCBhbmQgb25kaXNjb25uZWN0IGFyZSBub3QgeWV0IGltcGxlbWVudGVkIGluIENocm9tZSBhbmQgQ2hyb21pdW1cbiAgICAgICAgICBtaWRpQWNjZXNzLm9uY29ubmVjdCA9IGZ1bmN0aW9uKGUpe1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ2RldmljZSBjb25uZWN0ZWQnLCBlKVxuICAgICAgICAgICAgZ2V0TUlESXBvcnRzKClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBtaWRpQWNjZXNzLm9uZGlzY29ubmVjdCA9IGZ1bmN0aW9uKGUpe1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ2RldmljZSBkaXNjb25uZWN0ZWQnLCBlKVxuICAgICAgICAgICAgZ2V0TUlESXBvcnRzKClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpbml0aWFsaXplZCA9IHRydWVcbiAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgIGphenosXG4gICAgICAgICAgICBtaWRpLFxuICAgICAgICAgICAgd2VibWlkaSxcbiAgICAgICAgICAgIGlucHV0cyxcbiAgICAgICAgICAgIG91dHB1dHMsXG4gICAgICAgICAgICBpbnB1dHNCeUlkLFxuICAgICAgICAgICAgb3V0cHV0c0J5SWQsXG4gICAgICAgICAgfSlcbiAgICAgICAgfSxcblxuICAgICAgICBmdW5jdGlvbiBvblJlamVjdChlKXtcbiAgICAgICAgICAvL2NvbnNvbGUubG9nKGUpXG4gICAgICAgICAgcmVqZWN0KCdTb21ldGhpbmcgd2VudCB3cm9uZyB3aGlsZSByZXF1ZXN0aW5nIE1JRElBY2Nlc3MnLCBlKVxuICAgICAgICB9XG4gICAgICApXG4gICAgLy8gYnJvd3NlcnMgd2l0aG91dCBXZWJNSURJIEFQSVxuICAgIH1lbHNle1xuICAgICAgaW5pdGlhbGl6ZWQgPSB0cnVlXG4gICAgICByZXNvbHZlKHttaWRpOiBmYWxzZX0pXG4gICAgfVxuICB9KVxufVxuXG5cbmV4cG9ydCBsZXQgZ2V0TUlESUFjY2VzcyA9IGZ1bmN0aW9uKCl7XG4gIGlmKGluaXRpYWxpemVkID09PSBmYWxzZSl7XG4gICAgY29uc29sZS53YXJuKCdwbGVhc2UgY2FsbCBxYW1iaS5pbml0KCkgZmlyc3QnKVxuICB9ZWxzZSB7XG4gICAgZ2V0TUlESUFjY2VzcyA9IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gTUlESUFjY2Vzc1xuICAgIH1cbiAgICByZXR1cm4gZ2V0TUlESUFjY2VzcygpXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cblxuZXhwb3J0IGxldCBnZXRNSURJT3V0cHV0cyA9IGZ1bmN0aW9uKCl7XG4gIGlmKGluaXRpYWxpemVkID09PSBmYWxzZSl7XG4gICAgY29uc29sZS53YXJuKCdwbGVhc2UgY2FsbCBxYW1iaS5pbml0KCkgZmlyc3QnKVxuICB9ZWxzZSB7XG4gICAgZ2V0TUlESU91dHB1dHMgPSBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIG91dHB1dHNcbiAgICB9XG4gICAgcmV0dXJuIGdldE1JRElPdXRwdXRzKClcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuXG5leHBvcnQgbGV0IGdldE1JRElJbnB1dHMgPSBmdW5jdGlvbigpe1xuICBpZihpbml0aWFsaXplZCA9PT0gZmFsc2Upe1xuICAgIGNvbnNvbGUud2FybigncGxlYXNlIGNhbGwgcWFtYmkuaW5pdCgpIGZpcnN0JylcbiAgfWVsc2Uge1xuICAgIGdldE1JRElJbnB1dHMgPSBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIGlucHV0c1xuICAgIH1cbiAgICByZXR1cm4gZ2V0TUlESUlucHV0cygpXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmV4cG9ydCBsZXQgZ2V0TUlESU91dHB1dElkcyA9IGZ1bmN0aW9uKCl7XG4gIGlmKGluaXRpYWxpemVkID09PSBmYWxzZSl7XG4gICAgY29uc29sZS53YXJuKCdwbGVhc2UgY2FsbCBxYW1iaS5pbml0KCkgZmlyc3QnKVxuICB9ZWxzZSB7XG4gICAgZ2V0TUlESU91dHB1dElkcyA9IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gb3V0cHV0SWRzXG4gICAgfVxuICAgIHJldHVybiBnZXRNSURJT3V0cHV0SWRzKClcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuXG5leHBvcnQgbGV0IGdldE1JRElJbnB1dElkcyA9IGZ1bmN0aW9uKCl7XG4gIGlmKGluaXRpYWxpemVkID09PSBmYWxzZSl7XG4gICAgY29uc29sZS53YXJuKCdwbGVhc2UgY2FsbCBxYW1iaS5pbml0KCkgZmlyc3QnKVxuICB9ZWxzZSB7XG4gICAgZ2V0TUlESUlucHV0SWRzID0gZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiBpbnB1dElkc1xuICAgIH1cbiAgICByZXR1cm4gZ2V0TUlESUlucHV0SWRzKClcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuXG5leHBvcnQgbGV0IGdldE1JRElPdXRwdXRCeUlkID0gZnVuY3Rpb24oaWQ6IHN0cmluZyl7XG4gIGlmKGluaXRpYWxpemVkID09PSBmYWxzZSl7XG4gICAgY29uc29sZS53YXJuKCdwbGVhc2UgY2FsbCBxYW1iaS5pbml0KCkgZmlyc3QnKVxuICB9ZWxzZSB7XG4gICAgZ2V0TUlESU91dHB1dEJ5SWQgPSBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIG91dHB1dHNCeUlkLmdldChpZClcbiAgICB9XG4gICAgcmV0dXJuIGdldE1JRElPdXRwdXRCeUlkKGlkKVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5cbmV4cG9ydCBsZXQgZ2V0TUlESUlucHV0QnlJZCA9IGZ1bmN0aW9uKGlkOiBzdHJpbmcpe1xuICBpZihpbml0aWFsaXplZCA9PT0gZmFsc2Upe1xuICAgIGNvbnNvbGUud2FybigncGxlYXNlIGNhbGwgcWFtYmkuaW5pdCgpIGZpcnN0JylcbiAgfWVsc2Uge1xuICAgIGdldE1JRElJbnB1dEJ5SWQgPSBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIG91dHB1dHNCeUlkLmdldChpZClcbiAgICB9XG4gICAgcmV0dXJuIGdldE1JRElJbnB1dEJ5SWQoaWQpXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cblxuLypcbmV4cG9ydCBmdW5jdGlvbiBpbml0TWlkaVNvbmcoc29uZyl7XG5cbiAgc29uZ01pZGlFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZSl7XG4gICAgLy9jb25zb2xlLmxvZyhlKVxuICAgIGhhbmRsZU1pZGlNZXNzYWdlU29uZyhzb25nLCBlLCB0aGlzKTtcbiAgfTtcblxuICAvLyBieSBkZWZhdWx0IGEgc29uZyBsaXN0ZW5zIHRvIGFsbCBhdmFpbGFibGUgbWlkaS1pbiBwb3J0c1xuICBpbnB1dHMuZm9yRWFjaChmdW5jdGlvbihwb3J0KXtcbiAgICBwb3J0LmFkZEV2ZW50TGlzdGVuZXIoJ21pZGltZXNzYWdlJywgc29uZ01pZGlFdmVudExpc3RlbmVyKTtcbiAgICBzb25nLm1pZGlJbnB1dHMuc2V0KHBvcnQuaWQsIHBvcnQpO1xuICB9KTtcblxuICBvdXRwdXRzLmZvckVhY2goZnVuY3Rpb24ocG9ydCl7XG4gICAgc29uZy5taWRpT3V0cHV0cy5zZXQocG9ydC5pZCwgcG9ydCk7XG4gIH0pO1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRNaWRpSW5wdXRTb25nKHNvbmcsIGlkLCBmbGFnKXtcbiAgbGV0IGlucHV0ID0gaW5wdXRzLmdldChpZCk7XG5cbiAgaWYoaW5wdXQgPT09IHVuZGVmaW5lZCl7XG4gICAgd2Fybignbm8gbWlkaSBpbnB1dCB3aXRoIGlkJywgaWQsICdmb3VuZCcpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmKGZsYWcgPT09IGZhbHNlKXtcbiAgICBzb25nLm1pZGlJbnB1dHMuZGVsZXRlKGlkKTtcbiAgICBpbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKCdtaWRpbWVzc2FnZScsIHNvbmdNaWRpRXZlbnRMaXN0ZW5lcik7XG4gIH1lbHNle1xuICAgIHNvbmcubWlkaUlucHV0cy5zZXQoaWQsIGlucHV0KTtcbiAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdtaWRpbWVzc2FnZScsIHNvbmdNaWRpRXZlbnRMaXN0ZW5lcik7XG4gIH1cblxuICBsZXQgdHJhY2tzID0gc29uZy50cmFja3M7XG4gIGZvcihsZXQgdHJhY2sgb2YgdHJhY2tzKXtcbiAgICB0cmFjay5zZXRNaWRpSW5wdXQoaWQsIGZsYWcpO1xuICB9XG59XG5cblxuXG5leHBvcnQgZnVuY3Rpb24gc2V0TWlkaU91dHB1dFNvbmcoc29uZywgaWQsIGZsYWcpe1xuICBsZXQgb3V0cHV0ID0gb3V0cHV0cy5nZXQoaWQpO1xuXG4gIGlmKG91dHB1dCA9PT0gdW5kZWZpbmVkKXtcbiAgICB3YXJuKCdubyBtaWRpIG91dHB1dCB3aXRoIGlkJywgaWQsICdmb3VuZCcpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmKGZsYWcgPT09IGZhbHNlKXtcbiAgICBzb25nLm1pZGlPdXRwdXRzLmRlbGV0ZShpZCk7XG4gICAgbGV0IHRpbWUgPSBzb25nLnNjaGVkdWxlci5sYXN0RXZlbnRUaW1lICsgMTAwO1xuICAgIG91dHB1dC5zZW5kKFsweEIwLCAweDdCLCAweDAwXSwgdGltZSk7IC8vIHN0b3AgYWxsIG5vdGVzXG4gICAgb3V0cHV0LnNlbmQoWzB4QjAsIDB4NzksIDB4MDBdLCB0aW1lKTsgLy8gcmVzZXQgYWxsIGNvbnRyb2xsZXJzXG4gIH1lbHNle1xuICAgIHNvbmcubWlkaU91dHB1dHMuc2V0KGlkLCBvdXRwdXQpO1xuICB9XG5cbiAgbGV0IHRyYWNrcyA9IHNvbmcudHJhY2tzO1xuICBmb3IobGV0IHRyYWNrIG9mIHRyYWNrcyl7XG4gICAgdHJhY2suc2V0TWlkaU91dHB1dChpZCwgZmxhZyk7XG4gIH1cbn1cblxuXG5cbmZ1bmN0aW9uIGhhbmRsZU1pZGlNZXNzYWdlU29uZyhzb25nLCBtaWRpTWVzc2FnZUV2ZW50LCBpbnB1dCl7XG4gIGxldCBtaWRpRXZlbnQgPSBuZXcgTWlkaUV2ZW50KHNvbmcudGlja3MsIC4uLm1pZGlNZXNzYWdlRXZlbnQuZGF0YSk7XG5cbiAgLy9jb25zb2xlLmxvZyhtaWRpTWVzc2FnZUV2ZW50LmRhdGEpO1xuXG4gIGxldCB0cmFja3MgPSBzb25nLnRyYWNrcztcbiAgZm9yKGxldCB0cmFjayBvZiB0cmFja3Mpe1xuICAgIC8vY29uc29sZS5sb2codHJhY2subWlkaUlucHV0cywgaW5wdXQpO1xuXG5cbiAgICAvL2lmKG1pZGlFdmVudC5jaGFubmVsID09PSB0cmFjay5jaGFubmVsIHx8IHRyYWNrLmNoYW5uZWwgPT09IDAgfHwgdHJhY2suY2hhbm5lbCA9PT0gJ2FueScpe1xuICAgIC8vICBoYW5kbGVNaWRpTWVzc2FnZVRyYWNrKG1pZGlFdmVudCwgdHJhY2spO1xuICAgIC8vfVxuXG5cbiAgICAvLyBsaWtlIGluIEN1YmFzZSwgbWlkaSBldmVudHMgZnJvbSBhbGwgZGV2aWNlcywgc2VudCBvbiBhbnkgbWlkaSBjaGFubmVsIGFyZSBmb3J3YXJkZWQgdG8gYWxsIHRyYWNrc1xuICAgIC8vIHNldCB0cmFjay5tb25pdG9yIHRvIGZhbHNlIGlmIHlvdSBkb24ndCB3YW50IHRvIHJlY2VpdmUgbWlkaSBldmVudHMgb24gYSBjZXJ0YWluIHRyYWNrXG4gICAgLy8gbm90ZSB0aGF0IHRyYWNrLm1vbml0b3IgaXMgYnkgZGVmYXVsdCBzZXQgdG8gZmFsc2UgYW5kIHRoYXQgdHJhY2subW9uaXRvciBpcyBhdXRvbWF0aWNhbGx5IHNldCB0byB0cnVlXG4gICAgLy8gaWYgeW91IGFyZSByZWNvcmRpbmcgb24gdGhhdCB0cmFja1xuICAgIC8vY29uc29sZS5sb2codHJhY2subW9uaXRvciwgdHJhY2suaWQsIGlucHV0LmlkKTtcbiAgICBpZih0cmFjay5tb25pdG9yID09PSB0cnVlICYmIHRyYWNrLm1pZGlJbnB1dHMuZ2V0KGlucHV0LmlkKSAhPT0gdW5kZWZpbmVkKXtcbiAgICAgIGhhbmRsZU1pZGlNZXNzYWdlVHJhY2sobWlkaUV2ZW50LCB0cmFjaywgaW5wdXQpO1xuICAgIH1cbiAgfVxuXG4gIGxldCBsaXN0ZW5lcnMgPSBzb25nLm1pZGlFdmVudExpc3RlbmVycy5nZXQobWlkaUV2ZW50LnR5cGUpO1xuICBpZihsaXN0ZW5lcnMgIT09IHVuZGVmaW5lZCl7XG4gICAgZm9yKGxldCBsaXN0ZW5lciBvZiBsaXN0ZW5lcnMpe1xuICAgICAgbGlzdGVuZXIobWlkaUV2ZW50LCBpbnB1dCk7XG4gICAgfVxuICB9XG59XG5cblxuZnVuY3Rpb24gaGFuZGxlTWlkaU1lc3NhZ2VUcmFjayh0cmFjaywgbWlkaUV2ZW50LCBpbnB1dCl7XG4gIGxldCBzb25nID0gdHJhY2suc29uZyxcbiAgICBub3RlLCBsaXN0ZW5lcnMsIGNoYW5uZWw7XG4gICAgLy9kYXRhID0gbWlkaU1lc3NhZ2VFdmVudC5kYXRhLFxuICAgIC8vbWlkaUV2ZW50ID0gY3JlYXRlTWlkaUV2ZW50KHNvbmcudGlja3MsIGRhdGFbMF0sIGRhdGFbMV0sIGRhdGFbMl0pO1xuXG4gIC8vbWlkaUV2ZW50LnNvdXJjZSA9IG1pZGlNZXNzYWdlRXZlbnQuc3JjRWxlbWVudC5uYW1lO1xuICAvL2NvbnNvbGUubG9nKG1pZGlNZXNzYWdlRXZlbnQpXG4gIC8vY29uc29sZS5sb2coJy0tLS0+JywgbWlkaUV2ZW50LnR5cGUpO1xuXG4gIC8vIGFkZCB0aGUgZXhhY3QgdGltZSBvZiB0aGlzIGV2ZW50IHNvIHdlIGNhbiBjYWxjdWxhdGUgaXRzIHRpY2tzIHBvc2l0aW9uXG4gIG1pZGlFdmVudC5yZWNvcmRNaWxsaXMgPSBjb250ZXh0LmN1cnJlbnRUaW1lICogMTAwMDsgLy8gbWlsbGlzXG4gIG1pZGlFdmVudC5zdGF0ZSA9ICdyZWNvcmRlZCc7XG5cbiAgaWYobWlkaUV2ZW50LnR5cGUgPT09IDE0NCl7XG4gICAgbm90ZSA9IGNyZWF0ZU1pZGlOb3RlKG1pZGlFdmVudCk7XG4gICAgdHJhY2sucmVjb3JkaW5nTm90ZXNbbWlkaUV2ZW50LmRhdGExXSA9IG5vdGU7XG4gICAgLy90cmFjay5zb25nLnJlY29yZGluZ05vdGVzW25vdGUuaWRdID0gbm90ZTtcbiAgfWVsc2UgaWYobWlkaUV2ZW50LnR5cGUgPT09IDEyOCl7XG4gICAgbm90ZSA9IHRyYWNrLnJlY29yZGluZ05vdGVzW21pZGlFdmVudC5kYXRhMV07XG4gICAgLy8gY2hlY2sgaWYgdGhlIG5vdGUgZXhpc3RzOiBpZiB0aGUgdXNlciBwbGF5cyBub3RlcyBvbiBoZXIga2V5Ym9hcmQgYmVmb3JlIHRoZSBtaWRpIHN5c3RlbSBoYXNcbiAgICAvLyBiZWVuIGZ1bGx5IGluaXRpYWxpemVkLCBpdCBjYW4gaGFwcGVuIHRoYXQgdGhlIGZpcnN0IGluY29taW5nIG1pZGkgZXZlbnQgaXMgYSBOT1RFIE9GRiBldmVudFxuICAgIGlmKG5vdGUgPT09IHVuZGVmaW5lZCl7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG5vdGUuYWRkTm90ZU9mZihtaWRpRXZlbnQpO1xuICAgIGRlbGV0ZSB0cmFjay5yZWNvcmRpbmdOb3Rlc1ttaWRpRXZlbnQuZGF0YTFdO1xuICAgIC8vZGVsZXRlIHRyYWNrLnNvbmcucmVjb3JkaW5nTm90ZXNbbm90ZS5pZF07XG4gIH1cblxuICAvL2NvbnNvbGUubG9nKHNvbmcucHJlcm9sbCwgc29uZy5yZWNvcmRpbmcsIHRyYWNrLnJlY29yZEVuYWJsZWQpO1xuXG4gIGlmKChzb25nLnByZXJvbGxpbmcgfHwgc29uZy5yZWNvcmRpbmcpICYmIHRyYWNrLnJlY29yZEVuYWJsZWQgPT09ICdtaWRpJyl7XG4gICAgaWYobWlkaUV2ZW50LnR5cGUgPT09IDE0NCl7XG4gICAgICB0cmFjay5zb25nLnJlY29yZGVkTm90ZXMucHVzaChub3RlKTtcbiAgICB9XG4gICAgdHJhY2sucmVjb3JkUGFydC5hZGRFdmVudChtaWRpRXZlbnQpO1xuICAgIC8vIHNvbmcucmVjb3JkZWRFdmVudHMgaXMgdXNlZCBpbiB0aGUga2V5IGVkaXRvclxuICAgIHRyYWNrLnNvbmcucmVjb3JkZWRFdmVudHMucHVzaChtaWRpRXZlbnQpO1xuICB9ZWxzZSBpZih0cmFjay5lbmFibGVSZXRyb3NwZWN0aXZlUmVjb3JkaW5nKXtcbiAgICB0cmFjay5yZXRyb3NwZWN0aXZlUmVjb3JkaW5nLnB1c2gobWlkaUV2ZW50KTtcbiAgfVxuXG4gIC8vIGNhbGwgYWxsIG1pZGkgZXZlbnQgbGlzdGVuZXJzXG4gIGxpc3RlbmVycyA9IHRyYWNrLm1pZGlFdmVudExpc3RlbmVyc1ttaWRpRXZlbnQudHlwZV07XG4gIGlmKGxpc3RlbmVycyAhPT0gdW5kZWZpbmVkKXtcbiAgICBvYmplY3RGb3JFYWNoKGxpc3RlbmVycywgZnVuY3Rpb24obGlzdGVuZXIpe1xuICAgICAgbGlzdGVuZXIobWlkaUV2ZW50LCBpbnB1dCk7XG4gICAgfSk7XG4gIH1cblxuICBjaGFubmVsID0gdHJhY2suY2hhbm5lbDtcbiAgaWYoY2hhbm5lbCA9PT0gJ2FueScgfHwgY2hhbm5lbCA9PT0gdW5kZWZpbmVkIHx8IGlzTmFOKGNoYW5uZWwpID09PSB0cnVlKXtcbiAgICBjaGFubmVsID0gMDtcbiAgfVxuXG4gIG9iamVjdEZvckVhY2godHJhY2subWlkaU91dHB1dHMsIGZ1bmN0aW9uKG91dHB1dCl7XG4gICAgLy9jb25zb2xlLmxvZygnbWlkaSBvdXQnLCBvdXRwdXQsIG1pZGlFdmVudC50eXBlKTtcbiAgICBpZihtaWRpRXZlbnQudHlwZSA9PT0gMTI4IHx8IG1pZGlFdmVudC50eXBlID09PSAxNDQgfHwgbWlkaUV2ZW50LnR5cGUgPT09IDE3Nil7XG4gICAgICAvL2NvbnNvbGUubG9nKG1pZGlFdmVudC50eXBlLCBtaWRpRXZlbnQuZGF0YTEsIG1pZGlFdmVudC5kYXRhMik7XG4gICAgICBvdXRwdXQuc2VuZChbbWlkaUV2ZW50LnR5cGUsIG1pZGlFdmVudC5kYXRhMSwgbWlkaUV2ZW50LmRhdGEyXSk7XG4gICAgLy8gfWVsc2UgaWYobWlkaUV2ZW50LnR5cGUgPT09IDE5Mil7XG4gICAgLy8gICAgIG91dHB1dC5zZW5kKFttaWRpRXZlbnQudHlwZSArIGNoYW5uZWwsIG1pZGlFdmVudC5kYXRhMV0pO1xuICAgIH1cbiAgICAvL291dHB1dC5zZW5kKFttaWRpRXZlbnQuc3RhdHVzICsgY2hhbm5lbCwgbWlkaUV2ZW50LmRhdGExLCBtaWRpRXZlbnQuZGF0YTJdKTtcbiAgfSk7XG5cbiAgLy8gQFRPRE86IG1heWJlIGEgdHJhY2sgc2hvdWxkIGJlIGFibGUgdG8gc2VuZCBpdHMgZXZlbnQgdG8gYm90aCBhIG1pZGktb3V0IHBvcnQgYW5kIGFuIGludGVybmFsIGhlYXJ0YmVhdCBzb25nP1xuICAvL2NvbnNvbGUubG9nKHRyYWNrLnJvdXRlVG9NaWRpT3V0KTtcbiAgaWYodHJhY2sucm91dGVUb01pZGlPdXQgPT09IGZhbHNlKXtcbiAgICBtaWRpRXZlbnQudHJhY2sgPSB0cmFjaztcbiAgICB0cmFjay5pbnN0cnVtZW50LnByb2Nlc3NFdmVudChtaWRpRXZlbnQpO1xuICB9XG59XG5cblxuZnVuY3Rpb24gYWRkTWlkaUV2ZW50TGlzdGVuZXIoLi4uYXJncyl7IC8vIGNhbGxlciBjYW4gYmUgYSB0cmFjayBvciBhIHNvbmdcblxuICBsZXQgaWQgPSBtaWRpRXZlbnRMaXN0ZW5lcklkKys7XG4gIGxldCBsaXN0ZW5lcjtcbiAgICB0eXBlcyA9IHt9LFxuICAgIGlkcyA9IFtdLFxuICAgIGxvb3A7XG5cblxuICAvLyBzaG91bGQgSSBpbmxpbmUgdGhpcz9cbiAgbG9vcCA9IGZ1bmN0aW9uKGFyZ3Mpe1xuICAgIGZvcihsZXQgYXJnIG9mIGFyZ3Mpe1xuICAgICAgbGV0IHR5cGUgPSB0eXBlU3RyaW5nKGFyZyk7XG4gICAgICAvL2NvbnNvbGUubG9nKHR5cGUpO1xuICAgICAgaWYodHlwZSA9PT0gJ2FycmF5Jyl7XG4gICAgICAgIGxvb3AoYXJnKTtcbiAgICAgIH1lbHNlIGlmKHR5cGUgPT09ICdmdW5jdGlvbicpe1xuICAgICAgICBsaXN0ZW5lciA9IGFyZztcbiAgICAgIH1lbHNlIGlmKGlzTmFOKGFyZykgPT09IGZhbHNlKXtcbiAgICAgICAgYXJnID0gcGFyc2VJbnQoYXJnLCAxMCk7XG4gICAgICAgIGlmKHNlcXVlbmNlci5jaGVja0V2ZW50VHlwZShhcmcpICE9PSBmYWxzZSl7XG4gICAgICAgICAgdHlwZXNbYXJnXSA9IGFyZztcbiAgICAgICAgfVxuICAgICAgfWVsc2UgaWYodHlwZSA9PT0gJ3N0cmluZycpe1xuICAgICAgICBpZihzZXF1ZW5jZXIuY2hlY2tFdmVudFR5cGUoYXJnKSAhPT0gZmFsc2Upe1xuICAgICAgICAgIGFyZyA9IHNlcXVlbmNlci5taWRpRXZlbnROdW1iZXJCeU5hbWUoYXJnKTtcbiAgICAgICAgICB0eXBlc1thcmddID0gYXJnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGxvb3AoYXJncywgMCwgYXJncy5sZW5ndGgpO1xuICAvL2NvbnNvbGUubG9nKCd0eXBlcycsIHR5cGVzLCAnbGlzdGVuZXInLCBsaXN0ZW5lcik7XG5cbiAgb2JqZWN0Rm9yRWFjaCh0eXBlcywgZnVuY3Rpb24odHlwZSl7XG4gICAgLy9jb25zb2xlLmxvZyh0eXBlKTtcbiAgICBpZihvYmoubWlkaUV2ZW50TGlzdGVuZXJzW3R5cGVdID09PSB1bmRlZmluZWQpe1xuICAgICAgb2JqLm1pZGlFdmVudExpc3RlbmVyc1t0eXBlXSA9IHt9O1xuICAgIH1cbiAgICBvYmoubWlkaUV2ZW50TGlzdGVuZXJzW3R5cGVdW2lkXSA9IGxpc3RlbmVyO1xuICAgIGlkcy5wdXNoKHR5cGUgKyAnXycgKyBpZCk7XG4gIH0pO1xuXG4gIC8vY29uc29sZS5sb2cob2JqLm1pZGlFdmVudExpc3RlbmVycyk7XG4gIHJldHVybiBpZHMubGVuZ3RoID09PSAxID8gaWRzWzBdIDogaWRzO1xufVxuXG5cbmZ1bmN0aW9uIHJlbW92ZU1pZGlFdmVudExpc3RlbmVyKGlkLCBvYmope1xuICB2YXIgdHlwZTtcbiAgaWQgPSBpZC5zcGxpdCgnXycpO1xuICB0eXBlID0gaWRbMF07XG4gIGlkID0gaWRbMV07XG4gIGRlbGV0ZSBvYmoubWlkaUV2ZW50TGlzdGVuZXJzW3R5cGVdW2lkXTtcbn1cblxuXG5mdW5jdGlvbiByZW1vdmVNaWRpRXZlbnRMaXN0ZW5lcnMoKXtcblxufVxuXG4qL1xuIiwiaW1wb3J0IHtjcmVhdGVTYW1wbGV9IGZyb20gJy4vc2FtcGxlJ1xuaW1wb3J0IHtjb250ZXh0fSBmcm9tICcuL2luaXRfYXVkaW8nXG5pbXBvcnQge2NyZWF0ZU5vdGV9IGZyb20gJy4vbm90ZSdcbmltcG9ydCB7cGFyc2VTYW1wbGVzMn0gZnJvbSAnLi9wYXJzZV9hdWRpbydcbmltcG9ydCB7dHlwZVN0cmluZ30gZnJvbSAnLi91dGlsJ1xuXG5cbmNvbnN0IHBwcSA9IDQ4MFxuY29uc3QgYnBtID0gMTIwXG5jb25zdCBwbGF5YmFja1NwZWVkID0gMVxuY29uc3QgbWlsbGlzUGVyVGljayA9ICgxIC8gcGxheWJhY2tTcGVlZCAqIDYwKSAvIGJwbSAvIHBwcVxuXG5leHBvcnQgY2xhc3MgSW5zdHJ1bWVudHtcblxuICBjb25zdHJ1Y3RvcihpZDogc3RyaW5nLCB0eXBlOiBzdHJpbmcpe1xuICAgIHRoaXMuaWQgPSBpZFxuICAgIHRoaXMudHlwZSA9IHR5cGVcbiAgICAvLyBjcmVhdGUgYSBzYW1wbGVzIGRhdGEgb2JqZWN0IGZvciBhbGwgMTI4IHZlbG9jaXR5IGxldmVscyBvZiBhbGwgMTI4IG5vdGVzXG4gICAgdGhpcy5zYW1wbGVzRGF0YSA9IG5ldyBBcnJheSgxMjgpLmZpbGwoLTEpO1xuICAgIHRoaXMuc2FtcGxlc0RhdGEgPSB0aGlzLnNhbXBsZXNEYXRhLm1hcChmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIG5ldyBBcnJheSgxMjgpLmZpbGwoLTEpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5zY2hlZHVsZWRTYW1wbGVzID0ge31cbiAgICB0aGlzLnN1c3RhaW5lZFNhbXBsZXMgPSBbXVxuICAgIHRoaXMuc3VzdGFpblBlZGFsRG93biA9IGZhbHNlXG4gIH1cblxuICBjb25uZWN0KG91dHB1dCl7XG4gICAgdGhpcy5vdXRwdXQgPSBvdXRwdXRcbiAgfVxuXG4gIHByb2Nlc3NNSURJRXZlbnQoZXZlbnQsIHRpbWUpe1xuICAgIGxldCBzYW1wbGUsIHNhbXBsZURhdGFcbiAgICB0aW1lID0gdGltZSB8fCBjb250ZXh0LmN1cnJlbnRUaW1lICsgKGV2ZW50LnRpY2tzICogbWlsbGlzUGVyVGljaylcbiAgICAvL2NvbnNvbGUubG9nKHRpbWUpXG5cbiAgICBpZihldmVudC50eXBlID09PSAxNDQpe1xuICAgICAgLy9jb25zb2xlLmxvZygxNDQsICc6JywgdGltZSwgY29udGV4dC5jdXJyZW50VGltZSwgZXZlbnQubWlsbGlzKVxuXG4gICAgICBzYW1wbGVEYXRhID0gdGhpcy5zYW1wbGVzRGF0YVtldmVudC5kYXRhMV1bZXZlbnQuZGF0YTJdO1xuICAgICAgc2FtcGxlID0gY3JlYXRlU2FtcGxlKHNhbXBsZURhdGEsIGV2ZW50KVxuICAgICAgdGhpcy5zY2hlZHVsZWRTYW1wbGVzW2V2ZW50Lm1pZGlOb3RlSWRdID0gc2FtcGxlXG4gICAgICBzYW1wbGUub3V0cHV0LmNvbm5lY3QodGhpcy5vdXRwdXQgfHwgY29udGV4dC5kZXN0aW5hdGlvbilcbiAgICAgIC8vIHNhbXBsZS5zb3VyY2Uub25lbmRlZCA9ICgpID0+IHtcbiAgICAgIC8vICAgY29uc29sZS5sb2coJyAgICBkZWxldGluZycsIGV2ZW50Lm1pZGlOb3RlSWQpXG4gICAgICAvLyAgIGRlbGV0ZSB0aGlzLnNjaGVkdWxlZFNhbXBsZXNbZXZlbnQubWlkaU5vdGVJZF1cbiAgICAgIC8vIH1cbiAgICAgIHNhbXBsZS5zdGFydCh0aW1lKVxuICAgICAgLy9jb25zb2xlLmxvZygnc2NoZWR1bGluZycsIGV2ZW50LmlkLCBldmVudC5taWRpTm90ZUlkKVxuICAgICAgLy9jb25zb2xlLmxvZygnc3RhcnQnLCBldmVudC5taWRpTm90ZUlkKVxuICAgIH1lbHNlIGlmKGV2ZW50LnR5cGUgPT09IDEyOCl7XG4gICAgICAvL2NvbnNvbGUubG9nKDEyOCwgJzonLCB0aW1lLCBjb250ZXh0LmN1cnJlbnRUaW1lLCBldmVudC5taWxsaXMpXG4gICAgICBzYW1wbGUgPSB0aGlzLnNjaGVkdWxlZFNhbXBsZXNbZXZlbnQubWlkaU5vdGVJZF1cbiAgICAgIGlmKHR5cGVvZiBzYW1wbGUgPT09ICd1bmRlZmluZWQnKXtcbiAgICAgICAgY29uc29sZS5pbmZvKCdzYW1wbGUgbm90IGZvdW5kIGZvciBldmVudCcsIGV2ZW50LmlkLCAnIG1pZGlOb3RlJywgZXZlbnQubWlkaU5vdGVJZCwgZXZlbnQpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgaWYodGhpcy5zdXN0YWluUGVkYWxEb3duID09PSB0cnVlKXtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhldmVudC5taWRpTm90ZUlkKVxuICAgICAgICB0aGlzLnN1c3RhaW5lZFNhbXBsZXMucHVzaChldmVudC5taWRpTm90ZUlkKVxuICAgICAgfWVsc2V7XG4gICAgICAgIHNhbXBsZS5zdG9wKHRpbWUsICgpID0+IHtcbiAgICAgICAgICAvL2NvbnNvbGUubG9nKCdzdG9wJywgZXZlbnQubWlkaU5vdGVJZClcbiAgICAgICAgICBkZWxldGUgdGhpcy5zY2hlZHVsZWRTYW1wbGVzW2V2ZW50Lm1pZGlOb3RlSWRdXG4gICAgICAgIH0pXG4gICAgICAgIC8vc2FtcGxlLnN0b3AodGltZSlcbiAgICAgIH1cbiAgICB9ZWxzZSBpZihldmVudC50eXBlID09PSAxNzYpe1xuICAgICAgLy8gc3VzdGFpbiBwZWRhbFxuICAgICAgaWYoZXZlbnQuZGF0YTEgPT09IDY0KXtcbiAgICAgICAgaWYoZXZlbnQuZGF0YTIgPT09IDEyNyl7XG4gICAgICAgICAgdGhpcy5zdXN0YWluUGVkYWxEb3duID0gdHJ1ZVxuICAgICAgICAgIC8vY29uc29sZS5sb2coJ3N1c3RhaW4gcGVkYWwgZG93bicpXG4gICAgICAgICAgLy9kaXNwYXRjaEV2ZW50KHRoaXMudHJhY2suc29uZywgJ3N1c3RhaW5fcGVkYWwnLCAnZG93bicpO1xuICAgICAgICB9ZWxzZSBpZihldmVudC5kYXRhMiA9PT0gMCl7XG4gICAgICAgICAgdGhpcy5zdXN0YWluUGVkYWxEb3duID0gZmFsc2VcbiAgICAgICAgICB0aGlzLnN1c3RhaW5lZFNhbXBsZXMuZm9yRWFjaCgobWlkaU5vdGVJZCkgPT4ge1xuICAgICAgICAgICAgc2FtcGxlID0gdGhpcy5zY2hlZHVsZWRTYW1wbGVzW21pZGlOb3RlSWRdXG4gICAgICAgICAgICBpZihzYW1wbGUpe1xuICAgICAgICAgICAgICAvL3NhbXBsZS5zdG9wKHRpbWUpXG4gICAgICAgICAgICAgIHNhbXBsZS5zdG9wKHRpbWUsICgpID0+IHtcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdzdG9wJywgbWlkaU5vdGVJZClcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5zY2hlZHVsZWRTYW1wbGVzW21pZGlOb3RlSWRdXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgICAvL2NvbnNvbGUubG9nKCdzdXN0YWluIHBlZGFsIHVwJywgdGhpcy5zdXN0YWluZWRTYW1wbGVzKVxuICAgICAgICAgIHRoaXMuc3VzdGFpbmVkU2FtcGxlcyA9IFtdXG4gICAgICAgICAgLy9kaXNwYXRjaEV2ZW50KHRoaXMudHJhY2suc29uZywgJ3N1c3RhaW5fcGVkYWwnLCAndXAnKTtcbiAgICAgICAgICAvL3RoaXMuc3RvcFN1c3RhaW4odGltZSk7XG4gICAgICAgIH1cblxuICAgICAgLy8gcGFubmluZ1xuICAgICAgfWVsc2UgaWYoZXZlbnQuZGF0YTEgPT09IDEwKXtcbiAgICAgICAgLy8gcGFubmluZyBpcyAqbm90KiBleGFjdGx5IHRpbWVkIC0+IG5vdCBwb3NzaWJsZSAoeWV0KSB3aXRoIFdlYkF1ZGlvXG4gICAgICAgIC8vY29uc29sZS5sb2coZGF0YTIsIHJlbWFwKGRhdGEyLCAwLCAxMjcsIC0xLCAxKSk7XG4gICAgICAgIC8vdHJhY2suc2V0UGFubmluZyhyZW1hcChkYXRhMiwgMCwgMTI3LCAtMSwgMSkpO1xuXG4gICAgICAvLyB2b2x1bWVcbiAgICAgIH1lbHNlIGlmKGV2ZW50LmRhdGExID09PSA3KXtcbiAgICAgICAgLy8gdG8gYmUgaW1wbGVtZW50ZWRcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBsb2FkIGFuZCBwYXJzZVxuICBwYXJzZVNhbXBsZURhdGEoZGF0YSl7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgcGFyc2VTYW1wbGVzMihkYXRhKVxuICAgICAgLnRoZW4oKHJlc3VsdCkgPT4ge1xuXG4gICAgICAgIGlmKHR5cGVvZiBkYXRhLnJlbGVhc2UgIT09ICd1bmRlZmluZWQnKXtcbiAgICAgICAgICB0aGlzLnNldFJlbGVhc2UoZGF0YS5yZWxlYXNlWzBdLCBkYXRhLnJlbGVhc2VbMV0pXG4gICAgICAgICAgLy9jb25zb2xlLmxvZyhkYXRhLnJlbGVhc2VbMF0sIGRhdGEucmVsZWFzZVsxXSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC5mb3JFYWNoKChzYW1wbGUpID0+IHtcbiAgICAgICAgICBsZXQgc2FtcGxlRGF0YSA9IGRhdGFbc2FtcGxlLmlkXVxuICAgICAgICAgIGlmKHR5cGVvZiBzYW1wbGVEYXRhID09PSAnc3RyaW5nJyl7XG4gICAgICAgICAgICBzYW1wbGVEYXRhID0ge1xuICAgICAgICAgICAgICBidWZmZXI6IHNhbXBsZS5idWZmZXJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIHNhbXBsZURhdGEuYnVmZmVyID0gc2FtcGxlLmJ1ZmZlclxuICAgICAgICAgIH1cbiAgICAgICAgICBzYW1wbGVEYXRhLm5vdGUgPSBzYW1wbGUuaWRcbiAgICAgICAgICB0aGlzLnVwZGF0ZVNhbXBsZURhdGEoc2FtcGxlRGF0YSlcbiAgICAgICAgfSlcblxuICAgICAgICByZXNvbHZlKClcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIC8qXG4gICAgQHBhcmFtIGNvbmZpZyAob3B0aW9uYWwpXG4gICAgICB7XG4gICAgICAgIG5vdGU6IGNhbiBiZSBub3RlIG5hbWUgKEM0KSBvciBub3RlIG51bWJlciAoNjApXG4gICAgICAgIGJ1ZmZlcjogQXVkaW9CdWZmZXJcbiAgICAgICAgc3VzdGFpbjogW3N1c3RhaW5TdGFydCwgc3VzdGFpbkVuZF0sIC8vIG9wdGlvbmFsLCBpbiBtaWxsaXNcbiAgICAgICAgcmVsZWFzZTogW3JlbGVhc2VEdXJhdGlvbiwgcmVsZWFzZUVudmVsb3BlXSwgLy8gb3B0aW9uYWxcbiAgICAgICAgcGFuOiBwYW5Qb3NpdGlvbiAvLyBvcHRpb25hbFxuICAgICAgICB2ZWxvY2l0eTogW3ZlbG9jaXR5U3RhcnQsIHZlbG9jaXR5RW5kXSAvLyBvcHRpb25hbCwgZm9yIG11bHRpLWxheWVyZWQgaW5zdHJ1bWVudHNcbiAgICAgIH1cbiAgKi9cbiAgdXBkYXRlU2FtcGxlRGF0YSguLi5kYXRhKXtcbiAgICBkYXRhLmZvckVhY2gobm90ZURhdGEgPT4gdGhpcy5fdXBkYXRlU2FtcGxlRGF0YShub3RlRGF0YSkpXG4gIH1cblxuICBfdXBkYXRlU2FtcGxlRGF0YShkYXRhID0ge30pe1xuICAgIGxldCB7XG4gICAgICBub3RlLFxuICAgICAgYnVmZmVyID0gbnVsbCxcbiAgICAgIHN1c3RhaW4gPSBbbnVsbCwgbnVsbF0sXG4gICAgICByZWxlYXNlID0gW251bGwsICdsaW5lYXInXSxcbiAgICAgIHBhbiA9IG51bGwsXG4gICAgICB2ZWxvY2l0eSA9IFswLCAxMjddLFxuICAgIH0gPSBkYXRhXG5cbiAgICBpZih0eXBlb2Ygbm90ZSA9PT0gJ3VuZGVmaW5lZCcpe1xuICAgICAgY29uc29sZS53YXJuKCdwbGVhc2UgcHJvdmlkZSBhIG5vdGVudW1iZXIgb3IgYSBub3RlbmFtZScpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBnZXQgbm90ZW51bWJlciBmcm9tIG5vdGVuYW1lIGFuZCBjaGVjayBpZiB0aGUgbm90ZW51bWJlciBpcyB2YWxpZFxuICAgIGxldCBuID0gY3JlYXRlTm90ZShub3RlKVxuICAgIGlmKG4gPT09IGZhbHNlKXtcbiAgICAgIGNvbnNvbGUud2Fybignbm90IGEgdmFsaWQgbm90ZSBpZCcpXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgbm90ZSA9IG4ubnVtYmVyXG5cbiAgICBsZXQgW3N1c3RhaW5TdGFydCwgc3VzdGFpbkVuZF0gPSBzdXN0YWluXG4gICAgbGV0IFtyZWxlYXNlRHVyYXRpb24sIHJlbGVhc2VFbnZlbG9wZV0gPSByZWxlYXNlXG4gICAgbGV0IFt2ZWxvY2l0eVN0YXJ0LCB2ZWxvY2l0eUVuZF0gPSB2ZWxvY2l0eVxuXG4gICAgaWYoc3VzdGFpbi5sZW5ndGggIT09IDIpe1xuICAgICAgc3VzdGFpblN0YXJ0ID0gc3VzdGFpbkVuZCA9IG51bGxcbiAgICB9XG5cbiAgICBpZihyZWxlYXNlRHVyYXRpb24gPT09IG51bGwpe1xuICAgICAgcmVsZWFzZUVudmVsb3BlID0gbnVsbFxuICAgIH1cblxuICAgIC8vIGNvbnNvbGUubG9nKG5vdGVJZCwgYnVmZmVyKTtcbiAgICAvLyBjb25zb2xlLmxvZyhzdXN0YWluU3RhcnQsIHN1c3RhaW5FbmQpO1xuICAgIC8vIGNvbnNvbGUubG9nKHJlbGVhc2VEdXJhdGlvbiwgcmVsZWFzZUVudmVsb3BlKTtcbiAgICAvLyBjb25zb2xlLmxvZyhwYW4pO1xuICAgIC8vIGNvbnNvbGUubG9nKHZlbG9jaXR5U3RhcnQsIHZlbG9jaXR5RW5kKTtcblxuXG4gICAgdGhpcy5zYW1wbGVzRGF0YVtub3RlXS5mb3JFYWNoKChzYW1wbGVEYXRhLCBpKSA9PiB7XG4gICAgICBpZihpID49IHZlbG9jaXR5U3RhcnQgJiYgaSA8IHZlbG9jaXR5RW5kKXtcbiAgICAgICAgaWYoc2FtcGxlRGF0YSA9PT0gLTEpe1xuICAgICAgICAgIHNhbXBsZURhdGEgPSB7XG4gICAgICAgICAgICBpZDogbm90ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNhbXBsZURhdGEuYnVmZmVyID0gYnVmZmVyIHx8IHNhbXBsZURhdGEuYnVmZmVyXG4gICAgICAgIHNhbXBsZURhdGEuc3VzdGFpblN0YXJ0ID0gc3VzdGFpblN0YXJ0IHx8IHNhbXBsZURhdGEuc3VzdGFpblN0YXJ0XG4gICAgICAgIHNhbXBsZURhdGEuc3VzdGFpbkVuZCA9IHN1c3RhaW5FbmQgfHwgc2FtcGxlRGF0YS5zdXN0YWluRW5kXG4gICAgICAgIHNhbXBsZURhdGEucmVsZWFzZUR1cmF0aW9uID0gcmVsZWFzZUR1cmF0aW9uIHx8IHNhbXBsZURhdGEucmVsZWFzZUR1cmF0aW9uXG4gICAgICAgIHNhbXBsZURhdGEucmVsZWFzZUVudmVsb3BlID0gcmVsZWFzZUVudmVsb3BlIHx8IHNhbXBsZURhdGEucmVsZWFzZUVudmVsb3BlXG4gICAgICAgIHNhbXBsZURhdGEucGFuID0gcGFuIHx8IHNhbXBsZURhdGEucGFuXG5cbiAgICAgICAgaWYodHlwZVN0cmluZyhzYW1wbGVEYXRhLnJlbGVhc2VFbnZlbG9wZSkgPT09ICdhcnJheScpe1xuICAgICAgICAgIHNhbXBsZURhdGEucmVsZWFzZUVudmVsb3BlQXJyYXkgPSBzYW1wbGVEYXRhLnJlbGVhc2VFbnZlbG9wZVxuICAgICAgICAgIHNhbXBsZURhdGEucmVsZWFzZUVudmVsb3BlID0gJ2FycmF5J1xuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICBkZWxldGUgc2FtcGxlRGF0YS5yZWxlYXNlRW52ZWxvcGVBcnJheVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2FtcGxlc0RhdGFbbm90ZV1baV0gPSBzYW1wbGVEYXRhXG4gICAgICB9XG4gICAgfSlcbiAgICAvL2NvbnNvbGUubG9nKCclTycsIHRoaXMuc2FtcGxlc0RhdGFbbm90ZV0pO1xuICB9XG5cblxuICAvLyBzdGVyZW8gc3ByZWFkXG4gIHNldEtleVNjYWxpbmdQYW5uaW5nKCl7XG4gICAgLy8gc2V0cyBwYW5uaW5nIGJhc2VkIG9uIHRoZSBrZXkgdmFsdWUsIGUuZy4gaGlnaGVyIG5vdGVzIGFyZSBwYW5uZWQgbW9yZSB0byB0aGUgcmlnaHQgYW5kIGxvd2VyIG5vdGVzIG1vcmUgdG8gdGhlIGxlZnRcbiAgfVxuXG4gIHNldEtleVNjYWxpbmdSZWxlYXNlKCl7XG4gICAgLy8gc2V0IHJlbGVhc2UgYmFzZWQgb24ga2V5IHZhbHVlXG4gIH1cblxuICAvKlxuICAgIEBkdXJhdGlvbjogbWlsbGlzZWNvbmRzXG4gICAgQGVudmVsb3BlOiBsaW5lYXIgfCBlcXVhbF9wb3dlciB8IGFycmF5IG9mIGludCB2YWx1ZXNcbiAgKi9cbiAgc2V0UmVsZWFzZShkdXJhdGlvbjogbnVtYmVyLCBlbnZlbG9wZSl7XG4gICAgLy8gc2V0IHJlbGVhc2UgZm9yIGFsbCBrZXlzLCBvdmVycnVsZXMgdmFsdWVzIHNldCBieSBzZXRLZXlTY2FsaW5nUmVsZWFzZSgpXG4gICAgdGhpcy5zYW1wbGVzRGF0YS5mb3JFYWNoKGZ1bmN0aW9uKHNhbXBsZXMsIGkpe1xuICAgICAgc2FtcGxlcy5mb3JFYWNoKGZ1bmN0aW9uKHNhbXBsZSl7XG4gICAgICAgIGlmKHNhbXBsZSA9PT0gLTEpe1xuICAgICAgICAgIHNhbXBsZSA9IHtcbiAgICAgICAgICAgIGlkOiBpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNhbXBsZS5yZWxlYXNlRHVyYXRpb24gPSBkdXJhdGlvblxuICAgICAgICBzYW1wbGUucmVsZWFzZUVudmVsb3BlID0gZW52ZWxvcGVcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG5cbiAgYWxsTm90ZXNPZmYoKXtcbiAgICB0aGlzLnN1c3RhaW5lZFNhbXBsZXMgPSBbXVxuICAgIHRoaXMuc3VzdGFpblBlZGFsRG93biA9IGZhbHNlXG4gICAgT2JqZWN0LmtleXModGhpcy5zY2hlZHVsZWRTYW1wbGVzKS5mb3JFYWNoKChzYW1wbGVJZCkgPT4ge1xuICAgICAgLy9jb25zb2xlLmxvZygnICBzdG9wcGluZycsIHNhbXBsZUlkKVxuICAgICAgdGhpcy5zY2hlZHVsZWRTYW1wbGVzW3NhbXBsZUlkXS5zdG9wKClcbiAgICB9KVxuICAgIHRoaXMuc2NoZWR1bGVkU2FtcGxlcyA9IHt9XG5cbiAgICAvL2NvbnNvbGUubG9nKCdhbGxOb3Rlc09mZicsIHRoaXMuc3VzdGFpbmVkU2FtcGxlcy5sZW5ndGgsIHRoaXMuc2NoZWR1bGVkU2FtcGxlcylcbiAgfVxufVxuIiwiLy8gQCBmbG93XG5cbmxldCBtaWRpRXZlbnRJbmRleCA9IDBcblxuZXhwb3J0IGNsYXNzIE1JRElFdmVudHtcblxuICBjb25zdHJ1Y3Rvcih0aWNrczogbnVtYmVyLCB0eXBlOiBudW1iZXIsIGRhdGExOiBudW1iZXIsIGRhdGEyOiBudW1iZXIgPSAtMSl7XG4gICAgdGhpcy5pZCA9IGBNRV8ke21pZGlFdmVudEluZGV4Kyt9XyR7bmV3IERhdGUoKS5nZXRUaW1lKCl9YFxuICAgIHRoaXMudGlja3MgPSB0aWNrc1xuICAgIHRoaXMudHlwZSA9IHR5cGVcbiAgICB0aGlzLmRhdGExID0gZGF0YTFcbiAgICB0aGlzLmRhdGEyID0gZGF0YTJcbiAgICB0aGlzLmZyZXF1ZW5jeSA9IDQ0MCAqIE1hdGgucG93KDIsIChkYXRhMSAtIDY5KSAvIDEyKVxuXG4gICAgaWYoZGF0YTEgPT09IDE0NCAmJiBkYXRhMiA9PT0gMCl7XG4gICAgICB0aGlzLmRhdGExID0gMTI4XG4gICAgfVxuXG4gICAgdGhpcy5fcGFydCA9IG51bGxcbiAgICB0aGlzLl90cmFjayA9IG51bGxcbiAgICB0aGlzLl9zb25nID0gbnVsbFxuICAgIC8vQFRPRE86IGFkZCBhbGwgb3RoZXIgcHJvcGVydGllc1xuICB9XG5cbiAgY29weSgpe1xuICAgIGxldCBtID0gbmV3IE1JRElFdmVudCh0aGlzLnRpY2tzLCB0aGlzLnR5cGUsIHRoaXMuZGF0YTEsIHRoaXMuZGF0YTIpXG4gICAgcmV0dXJuIG1cbiAgfVxuXG4gIHRyYW5zcG9zZShhbW91bnQ6IG51bWJlcil7IC8vIG1heSBiZSBiZXR0ZXIgaWYgbm90IGEgcHVibGljIG1ldGhvZD9cbiAgICB0aGlzLmRhdGExICs9IGFtb3VudFxuICAgIHRoaXMuZnJlcXVlbmN5ID0gNDQwICogTWF0aC5wb3coMiwgKHRoaXMuZGF0YTEgLSA2OSkgLyAxMilcbiAgfVxuXG4gIG1vdmUodGlja3M6IG51bWJlcil7XG4gICAgdGhpcy50aWNrcyArPSB0aWNrc1xuICAgIGlmKHRoaXMubWlkaU5vdGUpe1xuICAgICAgdGhpcy5taWRpTm90ZS51cGRhdGUoKVxuICAgIH1cbiAgfVxuXG4gIG1vdmVUbyh0aWNrczogbnVtYmVyKXtcbiAgICB0aGlzLnRpY2tzID0gdGlja3NcbiAgICBpZih0aGlzLm1pZGlOb3RlKXtcbiAgICAgIHRoaXMubWlkaU5vdGUudXBkYXRlKClcbiAgICB9XG4gIH1cbn1cblxuXG4vKlxuZXhwb3J0IGZ1bmN0aW9uIGRlbGV0ZU1JRElFdmVudChldmVudCl7XG4gIC8vZXZlbnQubm90ZSA9IG51bGxcbiAgZXZlbnQubm90ZSA9IG51bGxcbiAgZXZlbnQgPSBudWxsXG59XG4qL1xuIiwiaW1wb3J0IHtNSURJRXZlbnR9IGZyb20gJy4vbWlkaV9ldmVudCdcblxubGV0IG1pZGlOb3RlSW5kZXggPSAwXG5cbmV4cG9ydCBjbGFzcyBNSURJTm90ZXtcblxuICBjb25zdHJ1Y3Rvcihub3Rlb246IE1JRElFdmVudCwgbm90ZW9mZjogTUlESUV2ZW50KXtcbiAgICBpZihub3Rlb24udHlwZSAhPT0gMTQ0IHx8IG5vdGVvZmYudHlwZSAhPT0gMTI4KXtcbiAgICAgIGNvbnNvbGUud2FybignY2Fubm90IGNyZWF0ZSBNSURJTm90ZScpXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdGhpcy5pZCA9IGBNTl8ke21pZGlOb3RlSW5kZXgrK31fJHtuZXcgRGF0ZSgpLmdldFRpbWUoKX1gXG4gICAgdGhpcy5ub3RlT24gPSBub3Rlb25cbiAgICB0aGlzLm5vdGVPZmYgPSBub3Rlb2ZmXG4gICAgbm90ZW9uLm1pZGlOb3RlID0gdGhpc1xuICAgIG5vdGVvZmYubWlkaU5vdGUgPSB0aGlzXG4gICAgbm90ZW9uLm1pZGlOb3RlSWQgPSB0aGlzLmlkXG4gICAgbm90ZW9mZi5taWRpTm90ZUlkID0gdGhpcy5pZFxuICAgIHRoaXMuZHVyYXRpb25UaWNrcyA9IG5vdGVvZmYudGlja3MgLSBub3Rlb24udGlja3NcbiAgICB0aGlzLmR1cmF0aW9uTWlsbGlzID0gLTFcbiAgfVxuXG4gIGNvcHkoKXtcbiAgICByZXR1cm4gbmV3IE1JRElOb3RlKHRoaXMubm90ZU9uLmNvcHkoKSwgdGhpcy5ub3RlT2ZmLmNvcHkoKSlcbiAgfVxuXG4gIHVwZGF0ZSgpeyAvLyBtYXkgdXNlIGFub3RoZXIgbmFtZSBmb3IgdGhpcyBtZXRob2RcbiAgICB0aGlzLmR1cmF0aW9uVGlja3MgPSB0aGlzLm5vdGVPZmYudGlja3MgLSB0aGlzLm5vdGVPbi50aWNrc1xuICB9XG5cbiAgdHJhbnNwb3NlKGFtb3VudDogbnVtYmVyKTogdm9pZHtcbiAgICB0aGlzLm5vdGVPbi50cmFuc3Bvc2UoYW1vdW50KVxuICAgIHRoaXMubm90ZU9mZi50cmFuc3Bvc2UoYW1vdW50KVxuICB9XG5cbiAgbW92ZSh0aWNrczogbnVtYmVyKTogdm9pZHtcbiAgICB0aGlzLm5vdGVPbi5tb3ZlKHRpY2tzKVxuICAgIHRoaXMubm90ZU9mZi5tb3ZlKHRpY2tzKVxuICB9XG5cbiAgbW92ZVRvKHRpY2tzOiBudW1iZXIpOiB2b2lke1xuICAgIHRoaXMubm90ZU9uLm1vdmVUbyh0aWNrcylcbiAgICB0aGlzLm5vdGVPZmYubW92ZVRvKHRpY2tzKVxuICB9XG5cbiAgdW5yZWdpc3Rlcigpe1xuICAgIGlmKHRoaXMucGFydCl7XG4gICAgICB0aGlzLnBhcnQucmVtb3ZlRXZlbnRzKHRoaXMpXG4gICAgICB0aGlzLnBhcnQgPSBudWxsXG4gICAgfVxuICAgIGlmKHRoaXMudHJhY2spe1xuICAgICAgdGhpcy50cmFjay5yZW1vdmVFdmVudHModGhpcylcbiAgICAgIHRoaXMudHJhY2sgPSBudWxsXG4gICAgfVxuICAgIGlmKHRoaXMuc29uZyl7XG4gICAgICB0aGlzLnNvbmcucmVtb3ZlRXZlbnRzKHRoaXMpXG4gICAgICB0aGlzLnNvbmcgPSBudWxsXG4gICAgfVxuICB9XG59XG5cbiIsIi8qXG4gIFdyYXBwZXIgZm9yIGFjY2Vzc2luZyBieXRlcyB0aHJvdWdoIHNlcXVlbnRpYWwgcmVhZHNcblxuICBiYXNlZCBvbjogaHR0cHM6Ly9naXRodWIuY29tL2dhc21hbi9qYXNtaWRcbiAgYWRhcHRlZCB0byB3b3JrIHdpdGggQXJyYXlCdWZmZXIgLT4gVWludDhBcnJheVxuKi9cblxuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IGZjYyA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1JRElTdHJlYW17XG5cbiAgLy8gYnVmZmVyIGlzIFVpbnQ4QXJyYXlcbiAgY29uc3RydWN0b3IoYnVmZmVyKXtcbiAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICB0aGlzLnBvc2l0aW9uID0gMDtcbiAgfVxuXG4gIC8qIHJlYWQgc3RyaW5nIG9yIGFueSBudW1iZXIgb2YgYnl0ZXMgKi9cbiAgcmVhZChsZW5ndGgsIHRvU3RyaW5nID0gdHJ1ZSkge1xuICAgIGxldCByZXN1bHQ7XG5cbiAgICBpZih0b1N0cmluZyl7XG4gICAgICByZXN1bHQgPSAnJztcbiAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKywgdGhpcy5wb3NpdGlvbisrKXtcbiAgICAgICAgcmVzdWx0ICs9IGZjYyh0aGlzLmJ1ZmZlclt0aGlzLnBvc2l0aW9uXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1lbHNle1xuICAgICAgcmVzdWx0ID0gW107XG4gICAgICBmb3IobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyssIHRoaXMucG9zaXRpb24rKyl7XG4gICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuYnVmZmVyW3RoaXMucG9zaXRpb25dKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9XG5cbiAgLyogcmVhZCBhIGJpZy1lbmRpYW4gMzItYml0IGludGVnZXIgKi9cbiAgcmVhZEludDMyKCkge1xuICAgIGxldCByZXN1bHQgPSAoXG4gICAgICAodGhpcy5idWZmZXJbdGhpcy5wb3NpdGlvbl0gPDwgMjQpICtcbiAgICAgICh0aGlzLmJ1ZmZlclt0aGlzLnBvc2l0aW9uICsgMV0gPDwgMTYpICtcbiAgICAgICh0aGlzLmJ1ZmZlclt0aGlzLnBvc2l0aW9uICsgMl0gPDwgOCkgK1xuICAgICAgdGhpcy5idWZmZXJbdGhpcy5wb3NpdGlvbiArIDNdXG4gICAgKTtcbiAgICB0aGlzLnBvc2l0aW9uICs9IDQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qIHJlYWQgYSBiaWctZW5kaWFuIDE2LWJpdCBpbnRlZ2VyICovXG4gIHJlYWRJbnQxNigpIHtcbiAgICBsZXQgcmVzdWx0ID0gKFxuICAgICAgKHRoaXMuYnVmZmVyW3RoaXMucG9zaXRpb25dIDw8IDgpICtcbiAgICAgIHRoaXMuYnVmZmVyW3RoaXMucG9zaXRpb24gKyAxXVxuICAgICk7XG4gICAgdGhpcy5wb3NpdGlvbiArPSAyO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKiByZWFkIGFuIDgtYml0IGludGVnZXIgKi9cbiAgcmVhZEludDgoc2lnbmVkKSB7XG4gICAgbGV0IHJlc3VsdCA9IHRoaXMuYnVmZmVyW3RoaXMucG9zaXRpb25dO1xuICAgIGlmKHNpZ25lZCAmJiByZXN1bHQgPiAxMjcpe1xuICAgICAgcmVzdWx0IC09IDI1NjtcbiAgICB9XG4gICAgdGhpcy5wb3NpdGlvbiArPSAxO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBlb2YoKSB7XG4gICAgcmV0dXJuIHRoaXMucG9zaXRpb24gPj0gdGhpcy5idWZmZXIubGVuZ3RoO1xuICB9XG5cbiAgLyogcmVhZCBhIE1JREktc3R5bGUgbGV0aWFibGUtbGVuZ3RoIGludGVnZXJcbiAgICAoYmlnLWVuZGlhbiB2YWx1ZSBpbiBncm91cHMgb2YgNyBiaXRzLFxuICAgIHdpdGggdG9wIGJpdCBzZXQgdG8gc2lnbmlmeSB0aGF0IGFub3RoZXIgYnl0ZSBmb2xsb3dzKVxuICAqL1xuICByZWFkVmFySW50KCkge1xuICAgIGxldCByZXN1bHQgPSAwO1xuICAgIHdoaWxlKHRydWUpIHtcbiAgICAgIGxldCBiID0gdGhpcy5yZWFkSW50OCgpO1xuICAgICAgaWYgKGIgJiAweDgwKSB7XG4gICAgICAgIHJlc3VsdCArPSAoYiAmIDB4N2YpO1xuICAgICAgICByZXN1bHQgPDw9IDc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBiIGlzIHRoZSBsYXN0IGJ5dGUgKi9cbiAgICAgICAgcmV0dXJuIHJlc3VsdCArIGI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmVzZXQoKXtcbiAgICB0aGlzLnBvc2l0aW9uID0gMDtcbiAgfVxuXG4gIHNldFBvc2l0aW9uKHApe1xuICAgIHRoaXMucG9zaXRpb24gPSBwO1xuICB9XG59XG4iLCIvKlxuICBFeHRyYWN0cyBhbGwgbWlkaSBldmVudHMgZnJvbSBhIGJpbmFyeSBtaWRpIGZpbGUsIHVzZXMgbWlkaV9zdHJlYW0uanNcblxuICBiYXNlZCBvbjogaHR0cHM6Ly9naXRodWIuY29tL2dhc21hbi9qYXNtaWRcbiovXG5cbid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IE1JRElTdHJlYW0gZnJvbSAnLi9taWRpX3N0cmVhbSc7XG5cbmxldFxuICBsYXN0RXZlbnRUeXBlQnl0ZSxcbiAgdHJhY2tOYW1lO1xuXG5cbmZ1bmN0aW9uIHJlYWRDaHVuayhzdHJlYW0pe1xuICBsZXQgaWQgPSBzdHJlYW0ucmVhZCg0LCB0cnVlKTtcbiAgbGV0IGxlbmd0aCA9IHN0cmVhbS5yZWFkSW50MzIoKTtcbiAgLy9jb25zb2xlLmxvZyhsZW5ndGgpO1xuICByZXR1cm57XG4gICAgJ2lkJzogaWQsXG4gICAgJ2xlbmd0aCc6IGxlbmd0aCxcbiAgICAnZGF0YSc6IHN0cmVhbS5yZWFkKGxlbmd0aCwgZmFsc2UpXG4gIH07XG59XG5cblxuZnVuY3Rpb24gcmVhZEV2ZW50KHN0cmVhbSl7XG4gIHZhciBldmVudCA9IHt9O1xuICB2YXIgbGVuZ3RoO1xuICBldmVudC5kZWx0YVRpbWUgPSBzdHJlYW0ucmVhZFZhckludCgpO1xuICBsZXQgZXZlbnRUeXBlQnl0ZSA9IHN0cmVhbS5yZWFkSW50OCgpO1xuICAvL2NvbnNvbGUubG9nKGV2ZW50VHlwZUJ5dGUsIGV2ZW50VHlwZUJ5dGUgJiAweDgwLCAxNDYgJiAweDBmKTtcbiAgaWYoKGV2ZW50VHlwZUJ5dGUgJiAweGYwKSA9PSAweGYwKXtcbiAgICAvKiBzeXN0ZW0gLyBtZXRhIGV2ZW50ICovXG4gICAgaWYoZXZlbnRUeXBlQnl0ZSA9PSAweGZmKXtcbiAgICAgIC8qIG1ldGEgZXZlbnQgKi9cbiAgICAgIGV2ZW50LnR5cGUgPSAnbWV0YSc7XG4gICAgICBsZXQgc3VidHlwZUJ5dGUgPSBzdHJlYW0ucmVhZEludDgoKTtcbiAgICAgIGxlbmd0aCA9IHN0cmVhbS5yZWFkVmFySW50KCk7XG4gICAgICBzd2l0Y2goc3VidHlwZUJ5dGUpe1xuICAgICAgICBjYXNlIDB4MDA6XG4gICAgICAgICAgZXZlbnQuc3VidHlwZSA9ICdzZXF1ZW5jZU51bWJlcic7XG4gICAgICAgICAgaWYobGVuZ3RoICE9PSAyKXtcbiAgICAgICAgICAgIHRocm93ICdFeHBlY3RlZCBsZW5ndGggZm9yIHNlcXVlbmNlTnVtYmVyIGV2ZW50IGlzIDIsIGdvdCAnICsgbGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBldmVudC5udW1iZXIgPSBzdHJlYW0ucmVhZEludDE2KCk7XG4gICAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgICBjYXNlIDB4MDE6XG4gICAgICAgICAgZXZlbnQuc3VidHlwZSA9ICd0ZXh0JztcbiAgICAgICAgICBldmVudC50ZXh0ID0gc3RyZWFtLnJlYWQobGVuZ3RoKTtcbiAgICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgICAgIGNhc2UgMHgwMjpcbiAgICAgICAgICBldmVudC5zdWJ0eXBlID0gJ2NvcHlyaWdodE5vdGljZSc7XG4gICAgICAgICAgZXZlbnQudGV4dCA9IHN0cmVhbS5yZWFkKGxlbmd0aCk7XG4gICAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgICBjYXNlIDB4MDM6XG4gICAgICAgICAgZXZlbnQuc3VidHlwZSA9ICd0cmFja05hbWUnO1xuICAgICAgICAgIGV2ZW50LnRleHQgPSBzdHJlYW0ucmVhZChsZW5ndGgpO1xuICAgICAgICAgIHRyYWNrTmFtZSA9IGV2ZW50LnRleHQ7XG4gICAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgICBjYXNlIDB4MDQ6XG4gICAgICAgICAgZXZlbnQuc3VidHlwZSA9ICdpbnN0cnVtZW50TmFtZSc7XG4gICAgICAgICAgZXZlbnQudGV4dCA9IHN0cmVhbS5yZWFkKGxlbmd0aCk7XG4gICAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgICBjYXNlIDB4MDU6XG4gICAgICAgICAgZXZlbnQuc3VidHlwZSA9ICdseXJpY3MnO1xuICAgICAgICAgIGV2ZW50LnRleHQgPSBzdHJlYW0ucmVhZChsZW5ndGgpO1xuICAgICAgICAgIHJldHVybiBldmVudDtcbiAgICAgICAgY2FzZSAweDA2OlxuICAgICAgICAgIGV2ZW50LnN1YnR5cGUgPSAnbWFya2VyJztcbiAgICAgICAgICBldmVudC50ZXh0ID0gc3RyZWFtLnJlYWQobGVuZ3RoKTtcbiAgICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgICAgIGNhc2UgMHgwNzpcbiAgICAgICAgICBldmVudC5zdWJ0eXBlID0gJ2N1ZVBvaW50JztcbiAgICAgICAgICBldmVudC50ZXh0ID0gc3RyZWFtLnJlYWQobGVuZ3RoKTtcbiAgICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgICAgIGNhc2UgMHgyMDpcbiAgICAgICAgICBldmVudC5zdWJ0eXBlID0gJ21pZGlDaGFubmVsUHJlZml4JztcbiAgICAgICAgICBpZihsZW5ndGggIT09IDEpe1xuICAgICAgICAgICAgdGhyb3cgJ0V4cGVjdGVkIGxlbmd0aCBmb3IgbWlkaUNoYW5uZWxQcmVmaXggZXZlbnQgaXMgMSwgZ290ICcgKyBsZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGV2ZW50LmNoYW5uZWwgPSBzdHJlYW0ucmVhZEludDgoKTtcbiAgICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgICAgIGNhc2UgMHgyZjpcbiAgICAgICAgICBldmVudC5zdWJ0eXBlID0gJ2VuZE9mVHJhY2snO1xuICAgICAgICAgIGlmKGxlbmd0aCAhPT0gMCl7XG4gICAgICAgICAgICB0aHJvdyAnRXhwZWN0ZWQgbGVuZ3RoIGZvciBlbmRPZlRyYWNrIGV2ZW50IGlzIDAsIGdvdCAnICsgbGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgICAgIGNhc2UgMHg1MTpcbiAgICAgICAgICBldmVudC5zdWJ0eXBlID0gJ3NldFRlbXBvJztcbiAgICAgICAgICBpZihsZW5ndGggIT09IDMpe1xuICAgICAgICAgICAgdGhyb3cgJ0V4cGVjdGVkIGxlbmd0aCBmb3Igc2V0VGVtcG8gZXZlbnQgaXMgMywgZ290ICcgKyBsZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGV2ZW50Lm1pY3Jvc2Vjb25kc1BlckJlYXQgPSAoXG4gICAgICAgICAgICAoc3RyZWFtLnJlYWRJbnQ4KCkgPDwgMTYpICtcbiAgICAgICAgICAgIChzdHJlYW0ucmVhZEludDgoKSA8PCA4KSArXG4gICAgICAgICAgICBzdHJlYW0ucmVhZEludDgoKVxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgICBjYXNlIDB4NTQ6XG4gICAgICAgICAgZXZlbnQuc3VidHlwZSA9ICdzbXB0ZU9mZnNldCc7XG4gICAgICAgICAgaWYobGVuZ3RoICE9PSA1KXtcbiAgICAgICAgICAgIHRocm93ICdFeHBlY3RlZCBsZW5ndGggZm9yIHNtcHRlT2Zmc2V0IGV2ZW50IGlzIDUsIGdvdCAnICsgbGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgaG91ckJ5dGUgPSBzdHJlYW0ucmVhZEludDgoKTtcbiAgICAgICAgICBldmVudC5mcmFtZVJhdGUgPXtcbiAgICAgICAgICAgIDB4MDA6IDI0LCAweDIwOiAyNSwgMHg0MDogMjksIDB4NjA6IDMwXG4gICAgICAgICAgfVtob3VyQnl0ZSAmIDB4NjBdO1xuICAgICAgICAgIGV2ZW50LmhvdXIgPSBob3VyQnl0ZSAmIDB4MWY7XG4gICAgICAgICAgZXZlbnQubWluID0gc3RyZWFtLnJlYWRJbnQ4KCk7XG4gICAgICAgICAgZXZlbnQuc2VjID0gc3RyZWFtLnJlYWRJbnQ4KCk7XG4gICAgICAgICAgZXZlbnQuZnJhbWUgPSBzdHJlYW0ucmVhZEludDgoKTtcbiAgICAgICAgICBldmVudC5zdWJmcmFtZSA9IHN0cmVhbS5yZWFkSW50OCgpO1xuICAgICAgICAgIHJldHVybiBldmVudDtcbiAgICAgICAgY2FzZSAweDU4OlxuICAgICAgICAgIGV2ZW50LnN1YnR5cGUgPSAndGltZVNpZ25hdHVyZSc7XG4gICAgICAgICAgaWYobGVuZ3RoICE9PSA0KXtcbiAgICAgICAgICAgIHRocm93ICdFeHBlY3RlZCBsZW5ndGggZm9yIHRpbWVTaWduYXR1cmUgZXZlbnQgaXMgNCwgZ290ICcgKyBsZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGV2ZW50Lm51bWVyYXRvciA9IHN0cmVhbS5yZWFkSW50OCgpO1xuICAgICAgICAgIGV2ZW50LmRlbm9taW5hdG9yID0gTWF0aC5wb3coMiwgc3RyZWFtLnJlYWRJbnQ4KCkpO1xuICAgICAgICAgIGV2ZW50Lm1ldHJvbm9tZSA9IHN0cmVhbS5yZWFkSW50OCgpO1xuICAgICAgICAgIGV2ZW50LnRoaXJ0eXNlY29uZHMgPSBzdHJlYW0ucmVhZEludDgoKTtcbiAgICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgICAgIGNhc2UgMHg1OTpcbiAgICAgICAgICBldmVudC5zdWJ0eXBlID0gJ2tleVNpZ25hdHVyZSc7XG4gICAgICAgICAgaWYobGVuZ3RoICE9PSAyKXtcbiAgICAgICAgICAgIHRocm93ICdFeHBlY3RlZCBsZW5ndGggZm9yIGtleVNpZ25hdHVyZSBldmVudCBpcyAyLCBnb3QgJyArIGxlbmd0aDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZXZlbnQua2V5ID0gc3RyZWFtLnJlYWRJbnQ4KHRydWUpO1xuICAgICAgICAgIGV2ZW50LnNjYWxlID0gc3RyZWFtLnJlYWRJbnQ4KCk7XG4gICAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgICBjYXNlIDB4N2Y6XG4gICAgICAgICAgZXZlbnQuc3VidHlwZSA9ICdzZXF1ZW5jZXJTcGVjaWZpYyc7XG4gICAgICAgICAgZXZlbnQuZGF0YSA9IHN0cmVhbS5yZWFkKGxlbmd0aCk7XG4gICAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIC8vaWYoc2VxdWVuY2VyLmRlYnVnID49IDIpe1xuICAgICAgICAgIC8vICAgIGNvbnNvbGUud2FybignVW5yZWNvZ25pc2VkIG1ldGEgZXZlbnQgc3VidHlwZTogJyArIHN1YnR5cGVCeXRlKTtcbiAgICAgICAgICAvL31cbiAgICAgICAgICBldmVudC5zdWJ0eXBlID0gJ3Vua25vd24nO1xuICAgICAgICAgIGV2ZW50LmRhdGEgPSBzdHJlYW0ucmVhZChsZW5ndGgpO1xuICAgICAgICAgIHJldHVybiBldmVudDtcbiAgICAgIH1cbiAgICAgIGV2ZW50LmRhdGEgPSBzdHJlYW0ucmVhZChsZW5ndGgpO1xuICAgICAgcmV0dXJuIGV2ZW50O1xuICAgIH1lbHNlIGlmKGV2ZW50VHlwZUJ5dGUgPT0gMHhmMCl7XG4gICAgICBldmVudC50eXBlID0gJ3N5c0V4JztcbiAgICAgIGxlbmd0aCA9IHN0cmVhbS5yZWFkVmFySW50KCk7XG4gICAgICBldmVudC5kYXRhID0gc3RyZWFtLnJlYWQobGVuZ3RoKTtcbiAgICAgIHJldHVybiBldmVudDtcbiAgICB9ZWxzZSBpZihldmVudFR5cGVCeXRlID09IDB4Zjcpe1xuICAgICAgZXZlbnQudHlwZSA9ICdkaXZpZGVkU3lzRXgnO1xuICAgICAgbGVuZ3RoID0gc3RyZWFtLnJlYWRWYXJJbnQoKTtcbiAgICAgIGV2ZW50LmRhdGEgPSBzdHJlYW0ucmVhZChsZW5ndGgpO1xuICAgICAgcmV0dXJuIGV2ZW50O1xuICAgIH1lbHNle1xuICAgICAgdGhyb3cgJ1VucmVjb2duaXNlZCBNSURJIGV2ZW50IHR5cGUgYnl0ZTogJyArIGV2ZW50VHlwZUJ5dGU7XG4gICAgfVxuICB9ZWxzZXtcbiAgICAvKiBjaGFubmVsIGV2ZW50ICovXG4gICAgbGV0IHBhcmFtMTtcbiAgICBpZigoZXZlbnRUeXBlQnl0ZSAmIDB4ODApID09PSAwKXtcbiAgICAgIC8qIHJ1bm5pbmcgc3RhdHVzIC0gcmV1c2UgbGFzdEV2ZW50VHlwZUJ5dGUgYXMgdGhlIGV2ZW50IHR5cGUuXG4gICAgICAgIGV2ZW50VHlwZUJ5dGUgaXMgYWN0dWFsbHkgdGhlIGZpcnN0IHBhcmFtZXRlclxuICAgICAgKi9cbiAgICAgIC8vY29uc29sZS5sb2coJ3J1bm5pbmcgc3RhdHVzJyk7XG4gICAgICBwYXJhbTEgPSBldmVudFR5cGVCeXRlO1xuICAgICAgZXZlbnRUeXBlQnl0ZSA9IGxhc3RFdmVudFR5cGVCeXRlO1xuICAgIH1lbHNle1xuICAgICAgcGFyYW0xID0gc3RyZWFtLnJlYWRJbnQ4KCk7XG4gICAgICAvL2NvbnNvbGUubG9nKCdsYXN0JywgZXZlbnRUeXBlQnl0ZSk7XG4gICAgICBsYXN0RXZlbnRUeXBlQnl0ZSA9IGV2ZW50VHlwZUJ5dGU7XG4gICAgfVxuICAgIGxldCBldmVudFR5cGUgPSBldmVudFR5cGVCeXRlID4+IDQ7XG4gICAgZXZlbnQuY2hhbm5lbCA9IGV2ZW50VHlwZUJ5dGUgJiAweDBmO1xuICAgIGV2ZW50LnR5cGUgPSAnY2hhbm5lbCc7XG4gICAgc3dpdGNoIChldmVudFR5cGUpe1xuICAgICAgY2FzZSAweDA4OlxuICAgICAgICBldmVudC5zdWJ0eXBlID0gJ25vdGVPZmYnO1xuICAgICAgICBldmVudC5ub3RlTnVtYmVyID0gcGFyYW0xO1xuICAgICAgICBldmVudC52ZWxvY2l0eSA9IHN0cmVhbS5yZWFkSW50OCgpO1xuICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgICBjYXNlIDB4MDk6XG4gICAgICAgIGV2ZW50Lm5vdGVOdW1iZXIgPSBwYXJhbTE7XG4gICAgICAgIGV2ZW50LnZlbG9jaXR5ID0gc3RyZWFtLnJlYWRJbnQ4KCk7XG4gICAgICAgIGlmKGV2ZW50LnZlbG9jaXR5ID09PSAwKXtcbiAgICAgICAgICBldmVudC5zdWJ0eXBlID0gJ25vdGVPZmYnO1xuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICBldmVudC5zdWJ0eXBlID0gJ25vdGVPbic7XG4gICAgICAgICAgLy9jb25zb2xlLmxvZygnbm90ZU9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgY2FzZSAweDBhOlxuICAgICAgICBldmVudC5zdWJ0eXBlID0gJ25vdGVBZnRlcnRvdWNoJztcbiAgICAgICAgZXZlbnQubm90ZU51bWJlciA9IHBhcmFtMTtcbiAgICAgICAgZXZlbnQuYW1vdW50ID0gc3RyZWFtLnJlYWRJbnQ4KCk7XG4gICAgICAgIHJldHVybiBldmVudDtcbiAgICAgIGNhc2UgMHgwYjpcbiAgICAgICAgZXZlbnQuc3VidHlwZSA9ICdjb250cm9sbGVyJztcbiAgICAgICAgZXZlbnQuY29udHJvbGxlclR5cGUgPSBwYXJhbTE7XG4gICAgICAgIGV2ZW50LnZhbHVlID0gc3RyZWFtLnJlYWRJbnQ4KCk7XG4gICAgICAgIHJldHVybiBldmVudDtcbiAgICAgIGNhc2UgMHgwYzpcbiAgICAgICAgZXZlbnQuc3VidHlwZSA9ICdwcm9ncmFtQ2hhbmdlJztcbiAgICAgICAgZXZlbnQucHJvZ3JhbU51bWJlciA9IHBhcmFtMTtcbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgY2FzZSAweDBkOlxuICAgICAgICBldmVudC5zdWJ0eXBlID0gJ2NoYW5uZWxBZnRlcnRvdWNoJztcbiAgICAgICAgZXZlbnQuYW1vdW50ID0gcGFyYW0xO1xuICAgICAgICAvL2lmKHRyYWNrTmFtZSA9PT0gJ1NILVMxLTQ0LUMwOSBMPVNNTCBJTj0zJyl7XG4gICAgICAgIC8vICAgIGNvbnNvbGUubG9nKCdjaGFubmVsIHByZXNzdXJlJywgdHJhY2tOYW1lLCBwYXJhbTEpO1xuICAgICAgICAvL31cbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgY2FzZSAweDBlOlxuICAgICAgICBldmVudC5zdWJ0eXBlID0gJ3BpdGNoQmVuZCc7XG4gICAgICAgIGV2ZW50LnZhbHVlID0gcGFyYW0xICsgKHN0cmVhbS5yZWFkSW50OCgpIDw8IDcpO1xuICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvKlxuICAgICAgICB0aHJvdyAnVW5yZWNvZ25pc2VkIE1JREkgZXZlbnQgdHlwZTogJyArIGV2ZW50VHlwZTtcbiAgICAgICAgY29uc29sZS5sb2coJ1VucmVjb2duaXNlZCBNSURJIGV2ZW50IHR5cGU6ICcgKyBldmVudFR5cGUpO1xuICAgICAgICAqL1xuXG4gICAgICAgIGV2ZW50LnZhbHVlID0gc3RyZWFtLnJlYWRJbnQ4KCk7XG4gICAgICAgIGV2ZW50LnN1YnR5cGUgPSAndW5rbm93bic7XG4gICAgICAgIC8vY29uc29sZS5sb2coZXZlbnQpO1xuLypcbiAgICAgICAgZXZlbnQubm90ZU51bWJlciA9IHBhcmFtMTtcbiAgICAgICAgZXZlbnQudmVsb2NpdHkgPSBzdHJlYW0ucmVhZEludDgoKTtcbiAgICAgICAgZXZlbnQuc3VidHlwZSA9ICdub3RlT24nO1xuICAgICAgICBjb25zb2xlLmxvZygnd2VpcmRvJywgdHJhY2tOYW1lLCBwYXJhbTEsIGV2ZW50LnZlbG9jaXR5KTtcbiovXG5cbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgIH1cbiAgfVxufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZU1JRElGaWxlKGJ1ZmZlcil7XG4gIGlmKGJ1ZmZlciBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgPT09IGZhbHNlICYmIGJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyID09PSBmYWxzZSl7XG4gICAgY29uc29sZS5lcnJvcignYnVmZmVyIHNob3VsZCBiZSBhbiBpbnN0YW5jZSBvZiBVaW50OEFycmF5IG9mIEFycmF5QnVmZmVyJylcbiAgICByZXR1cm5cbiAgfVxuICBpZihidWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcil7XG4gICAgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKVxuICB9XG4gIGxldCB0cmFja3MgPSBuZXcgTWFwKCk7XG4gIGxldCBzdHJlYW0gPSBuZXcgTUlESVN0cmVhbShidWZmZXIpO1xuXG4gIGxldCBoZWFkZXJDaHVuayA9IHJlYWRDaHVuayhzdHJlYW0pO1xuICBpZihoZWFkZXJDaHVuay5pZCAhPT0gJ01UaGQnIHx8IGhlYWRlckNodW5rLmxlbmd0aCAhPT0gNil7XG4gICAgdGhyb3cgJ0JhZCAubWlkIGZpbGUgLSBoZWFkZXIgbm90IGZvdW5kJztcbiAgfVxuXG4gIGxldCBoZWFkZXJTdHJlYW0gPSBuZXcgTUlESVN0cmVhbShoZWFkZXJDaHVuay5kYXRhKTtcbiAgbGV0IGZvcm1hdFR5cGUgPSBoZWFkZXJTdHJlYW0ucmVhZEludDE2KCk7XG4gIGxldCB0cmFja0NvdW50ID0gaGVhZGVyU3RyZWFtLnJlYWRJbnQxNigpO1xuICBsZXQgdGltZURpdmlzaW9uID0gaGVhZGVyU3RyZWFtLnJlYWRJbnQxNigpO1xuXG4gIGlmKHRpbWVEaXZpc2lvbiAmIDB4ODAwMCl7XG4gICAgdGhyb3cgJ0V4cHJlc3NpbmcgdGltZSBkaXZpc2lvbiBpbiBTTVRQRSBmcmFtZXMgaXMgbm90IHN1cHBvcnRlZCB5ZXQnO1xuICB9XG5cbiAgbGV0IGhlYWRlciA9e1xuICAgICdmb3JtYXRUeXBlJzogZm9ybWF0VHlwZSxcbiAgICAndHJhY2tDb3VudCc6IHRyYWNrQ291bnQsXG4gICAgJ3RpY2tzUGVyQmVhdCc6IHRpbWVEaXZpc2lvblxuICB9O1xuXG4gIGZvcihsZXQgaSA9IDA7IGkgPCB0cmFja0NvdW50OyBpKyspe1xuICAgIHRyYWNrTmFtZSA9ICd0cmFja18nICsgaTtcbiAgICBsZXQgdHJhY2sgPSBbXTtcbiAgICBsZXQgdHJhY2tDaHVuayA9IHJlYWRDaHVuayhzdHJlYW0pO1xuICAgIGlmKHRyYWNrQ2h1bmsuaWQgIT09ICdNVHJrJyl7XG4gICAgICB0aHJvdyAnVW5leHBlY3RlZCBjaHVuayAtIGV4cGVjdGVkIE1UcmssIGdvdCAnKyB0cmFja0NodW5rLmlkO1xuICAgIH1cbiAgICBsZXQgdHJhY2tTdHJlYW0gPSBuZXcgTUlESVN0cmVhbSh0cmFja0NodW5rLmRhdGEpO1xuICAgIHdoaWxlKCF0cmFja1N0cmVhbS5lb2YoKSl7XG4gICAgICBsZXQgZXZlbnQgPSByZWFkRXZlbnQodHJhY2tTdHJlYW0pO1xuICAgICAgdHJhY2sucHVzaChldmVudCk7XG4gICAgfVxuICAgIHRyYWNrcy5zZXQodHJhY2tOYW1lLCB0cmFjayk7XG4gIH1cblxuICByZXR1cm57XG4gICAgJ2hlYWRlcic6IGhlYWRlcixcbiAgICAndHJhY2tzJzogdHJhY2tzXG4gIH07XG59IiwiLypcbiAgQWRkcyBhIGZ1bmN0aW9uIHRvIGNyZWF0ZSBhIG5vdGUgb2JqZWN0IHRoYXQgY29udGFpbnMgaW5mb3JtYXRpb24gYWJvdXQgYSBtdXNpY2FsIG5vdGU6XG4gICAgLSBuYW1lLCBlLmcuICdDJ1xuICAgIC0gb2N0YXZlLCAgLTEgLSA5XG4gICAgLSBmdWxsTmFtZTogJ0MxJ1xuICAgIC0gZnJlcXVlbmN5OiAyMzQuMTYsIGJhc2VkIG9uIHRoZSBiYXNpYyBwaXRjaFxuICAgIC0gbnVtYmVyOiA2MCBtaWRpIG5vdGUgbnVtYmVyXG5cbiAgQWRkcyBzZXZlcmFsIHV0aWxpdHkgbWV0aG9kcyBvcmdhbmlzZWQgYXJvdW5kIHRoZSBub3RlIG9iamVjdFxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQge3R5cGVTdHJpbmd9IGZyb20gJy4vdXRpbCc7XG5cbmxldFxuICBlcnJvck1zZyxcbiAgd2FybmluZ01zZyxcbiAgcG93ID0gTWF0aC5wb3csXG4gIGZsb29yID0gTWF0aC5mbG9vcjtcblxuY29uc3Qgbm90ZU5hbWVzID0ge1xuICAnc2hhcnAnIDogWydDJywgJ0MjJywgJ0QnLCAnRCMnLCAnRScsICdGJywgJ0YjJywgJ0cnLCAnRyMnLCAnQScsICdBIycsICdCJ10sXG4gICdmbGF0JyA6IFsnQycsICdEYicsICdEJywgJ0ViJywgJ0UnLCAnRicsICdHYicsICdHJywgJ0FiJywgJ0EnLCAnQmInLCAnQiddLFxuICAnZW5oYXJtb25pYy1zaGFycCcgOiBbJ0IjJywgJ0MjJywgJ0MjIycsICdEIycsICdEIyMnLCAnRSMnLCAnRiMnLCAnRiMjJywgJ0cjJywgJ0cjIycsICdBIycsICdBIyMnXSxcbiAgJ2VuaGFybW9uaWMtZmxhdCcgOiBbJ0RiYicsICdEYicsICdFYmInLCAnRWInLCAnRmInLCAnR2JiJywgJ0diJywgJ0FiYicsICdBYicsICdCYmInLCAnQmInLCAnQ2InXVxufTtcblxuXG4vKlxuICBhcmd1bWVudHNcbiAgLSBub3RlTnVtYmVyOiA2MFxuICAtIG5vdGVOdW1iZXIgYW5kIG5vdGVuYW1lIG1vZGU6IDYwLCAnc2hhcnAnXG4gIC0gbm90ZU5hbWU6ICdDIzQnXG4gIC0gbmFtZSBhbmQgb2N0YXZlOiAnQyMnLCA0XG4gIC0gbm90ZSBuYW1lLCBvY3RhdmUsIG5vdGUgbmFtZSBtb2RlOiAnRCcsIDQsICdzaGFycCdcbiAgLSBkYXRhIG9iamVjdDpcbiAgICB7XG4gICAgICBuYW1lOiAnQycsXG4gICAgICBvY3RhdmU6IDRcbiAgICB9XG4gICAgb3JcbiAgICB7XG4gICAgICBmcmVxdWVuY3k6IDIzNC4xNlxuICAgIH1cbiovXG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVOb3RlKC4uLmFyZ3Mpe1xuICBsZXRcbiAgICBudW1BcmdzID0gYXJncy5sZW5ndGgsXG4gICAgZGF0YSxcbiAgICBvY3RhdmUsXG4gICAgbm90ZU5hbWUsXG4gICAgbm90ZU51bWJlcixcbiAgICBub3RlTmFtZU1vZGUsXG4gICAgYXJnMCA9IGFyZ3NbMF0sXG4gICAgYXJnMSA9IGFyZ3NbMV0sXG4gICAgYXJnMiA9IGFyZ3NbMl0sXG4gICAgdHlwZTAgPSB0eXBlU3RyaW5nKGFyZzApLFxuICAgIHR5cGUxID0gdHlwZVN0cmluZyhhcmcxKSxcbiAgICB0eXBlMiA9IHR5cGVTdHJpbmcoYXJnMik7XG5cbiAgZXJyb3JNc2cgPSAnJztcbiAgd2FybmluZ01zZyA9ICcnO1xuXG4gIC8vIGFyZ3VtZW50OiBub3RlIG51bWJlclxuICAvL2NvbnNvbGUubG9nKG51bUFyZ3MsIHR5cGUwKVxuICBpZihudW1BcmdzID09PSAxICYmIHR5cGUwID09PSAnbnVtYmVyJyl7XG4gICAgaWYoYXJnMCA8IDAgfHwgYXJnMCA+IDEyNyl7XG4gICAgICBlcnJvck1zZyA9ICdwbGVhc2UgcHJvdmlkZSBhIG5vdGUgbnVtYmVyID49IDAgYW5kIDw9IDEyNyAnICsgIGFyZzA7XG4gICAgfWVsc2V7XG4gICAgICBub3RlTnVtYmVyID0gYXJnMDtcbiAgICAgIGRhdGEgPSBfZ2V0Tm90ZU5hbWUobm90ZU51bWJlcik7XG4gICAgICBub3RlTmFtZSA9IGRhdGFbMF07XG4gICAgICBvY3RhdmUgPSBkYXRhWzFdO1xuICAgIH1cblxuXG4gIC8vIGFyZ3VtZW50czogZnVsbCBub3RlIG5hbWVcbiAgfWVsc2UgaWYobnVtQXJncyA9PT0gMSAmJiB0eXBlMCA9PT0gJ3N0cmluZycpe1xuICAgIGRhdGEgPSBfY2hlY2tOb3RlTmFtZShhcmcwKTtcbiAgICBpZihlcnJvck1zZyA9PT0gJycpe1xuICAgICAgbm90ZU5hbWUgPSBkYXRhWzBdO1xuICAgICAgb2N0YXZlID0gZGF0YVsxXTtcbiAgICAgIG5vdGVOdW1iZXIgPSBfZ2V0Tm90ZU51bWJlcihub3RlTmFtZSwgb2N0YXZlKTtcbiAgICB9XG5cbiAgLy8gYXJndW1lbnRzOiBub3RlIG5hbWUsIG9jdGF2ZVxuICB9ZWxzZSBpZihudW1BcmdzID09PSAyICYmIHR5cGUwID09PSAnc3RyaW5nJyAmJiB0eXBlMSA9PT0gJ251bWJlcicpe1xuICAgIGRhdGEgPSBfY2hlY2tOb3RlTmFtZShhcmcwLCBhcmcxKTtcbiAgICBpZihlcnJvck1zZyA9PT0gJycpe1xuICAgICAgbm90ZU5hbWUgPSBkYXRhWzBdO1xuICAgICAgb2N0YXZlID0gZGF0YVsxXTtcbiAgICAgIG5vdGVOdW1iZXIgPSBfZ2V0Tm90ZU51bWJlcihub3RlTmFtZSwgb2N0YXZlKTtcbiAgICB9XG5cbiAgLy8gYXJndW1lbnRzOiBmdWxsIG5vdGUgbmFtZSwgbm90ZSBuYW1lIG1vZGUgLT4gZm9yIGNvbnZlcnRpbmcgYmV0d2VlbiBub3RlIG5hbWUgbW9kZXNcbiAgfWVsc2UgaWYobnVtQXJncyA9PT0gMiAmJiB0eXBlMCA9PT0gJ3N0cmluZycgJiYgdHlwZTEgPT09ICdzdHJpbmcnKXtcbiAgICBkYXRhID0gX2NoZWNrTm90ZU5hbWUoYXJnMCk7XG4gICAgaWYoZXJyb3JNc2cgPT09ICcnKXtcbiAgICAgIG5vdGVOYW1lTW9kZSA9IF9jaGVja05vdGVOYW1lTW9kZShhcmcxKTtcbiAgICAgIG5vdGVOYW1lID0gZGF0YVswXTtcbiAgICAgIG9jdGF2ZSA9IGRhdGFbMV07XG4gICAgICBub3RlTnVtYmVyID0gX2dldE5vdGVOdW1iZXIobm90ZU5hbWUsIG9jdGF2ZSk7XG4gICAgfVxuXG5cbiAgLy8gYXJndW1lbnRzOiBub3RlIG51bWJlciwgbm90ZSBuYW1lIG1vZGVcbiAgfWVsc2UgaWYobnVtQXJncyA9PT0gMiAmJiB0eXBlU3RyaW5nKGFyZzApID09PSAnbnVtYmVyJyAmJiB0eXBlU3RyaW5nKGFyZzEpID09PSAnc3RyaW5nJyl7XG4gICAgaWYoYXJnMCA8IDAgfHwgYXJnMCA+IDEyNyl7XG4gICAgICBlcnJvck1zZyA9ICdwbGVhc2UgcHJvdmlkZSBhIG5vdGUgbnVtYmVyID49IDAgYW5kIDw9IDEyNyAnICsgYXJnMDtcbiAgICB9ZWxzZXtcbiAgICAgIG5vdGVOYW1lTW9kZSA9IF9jaGVja05vdGVOYW1lTW9kZShhcmcxKTtcbiAgICAgIG5vdGVOdW1iZXIgPSBhcmcwO1xuICAgICAgZGF0YSA9IF9nZXROb3RlTmFtZShub3RlTnVtYmVyLCBub3RlTmFtZU1vZGUpO1xuICAgICAgbm90ZU5hbWUgPSBkYXRhWzBdO1xuICAgICAgb2N0YXZlID0gZGF0YVsxXTtcbiAgICB9XG5cblxuICAvLyBhcmd1bWVudHM6IG5vdGUgbmFtZSwgb2N0YXZlLCBub3RlIG5hbWUgbW9kZVxuICB9ZWxzZSBpZihudW1BcmdzID09PSAzICYmIHR5cGUwID09PSAnc3RyaW5nJyAmJiB0eXBlMSA9PT0gJ251bWJlcicgJiYgdHlwZTIgPT09ICdzdHJpbmcnKXtcbiAgICBkYXRhID0gX2NoZWNrTm90ZU5hbWUoYXJnMCwgYXJnMSk7XG4gICAgaWYoZXJyb3JNc2cgPT09ICcnKXtcbiAgICAgIG5vdGVOYW1lTW9kZSA9IF9jaGVja05vdGVOYW1lTW9kZShhcmcyKTtcbiAgICAgIG5vdGVOYW1lID0gZGF0YVswXTtcbiAgICAgIG9jdGF2ZSA9IGRhdGFbMV07XG4gICAgICBub3RlTnVtYmVyID0gX2dldE5vdGVOdW1iZXIobm90ZU5hbWUsb2N0YXZlKTtcbiAgICB9XG5cbiAgfWVsc2V7XG4gICAgZXJyb3JNc2cgPSAnd3JvbmcgYXJndW1lbnRzLCBwbGVhc2UgY29uc3VsdCBkb2N1bWVudGF0aW9uJztcbiAgfVxuXG4gIGlmKGVycm9yTXNnKXtcbiAgICBjb25zb2xlLmVycm9yKGVycm9yTXNnKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZih3YXJuaW5nTXNnKXtcbiAgICBjb25zb2xlLndhcm4od2FybmluZ01zZyk7XG4gIH1cblxuICBsZXQgbm90ZSA9IHtcbiAgICBuYW1lOiBub3RlTmFtZSxcbiAgICBvY3RhdmU6IG9jdGF2ZSxcbiAgICBmdWxsTmFtZTogbm90ZU5hbWUgKyBvY3RhdmUsXG4gICAgbnVtYmVyOiBub3RlTnVtYmVyLFxuICAgIGZyZXF1ZW5jeTogX2dldEZyZXF1ZW5jeShub3RlTnVtYmVyKSxcbiAgICBibGFja0tleTogX2lzQmxhY2tLZXkobm90ZU51bWJlcilcbiAgfVxuICBPYmplY3QuZnJlZXplKG5vdGUpO1xuICByZXR1cm4gbm90ZTtcbn1cblxuXG4vL2Z1bmN0aW9uIF9nZXROb3RlTmFtZShudW1iZXIsIG1vZGUgPSBjb25maWcuZ2V0KCdub3RlTmFtZU1vZGUnKSkge1xuZnVuY3Rpb24gX2dldE5vdGVOYW1lKG51bWJlciwgbW9kZSA9ICdzaGFycCcpIHtcbiAgLy9sZXQgb2N0YXZlID0gTWF0aC5mbG9vcigobnVtYmVyIC8gMTIpIC0gMiksIC8vIOKGkiBpbiBDdWJhc2UgY2VudHJhbCBDID0gQzMgaW5zdGVhZCBvZiBDNFxuICBsZXQgb2N0YXZlID0gZmxvb3IoKG51bWJlciAvIDEyKSAtIDEpO1xuICBsZXQgbm90ZU5hbWUgPSBub3RlTmFtZXNbbW9kZV1bbnVtYmVyICUgMTJdO1xuICByZXR1cm4gW25vdGVOYW1lLCBvY3RhdmVdO1xufVxuXG5cbmZ1bmN0aW9uIF9nZXROb3RlTnVtYmVyKG5hbWUsIG9jdGF2ZSkge1xuICBsZXQga2V5cyA9IE9iamVjdC5rZXlzKG5vdGVOYW1lcyk7XG4gIGxldCBpbmRleDtcblxuICBmb3IobGV0IGtleSBvZiBrZXlzKXtcbiAgICBsZXQgbW9kZSA9IG5vdGVOYW1lc1trZXldO1xuICAgIGluZGV4ID0gbW9kZS5maW5kSW5kZXgoeCA9PiB4ID09PSBuYW1lKTtcbiAgICBpZihpbmRleCAhPT0gLTEpe1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLy9udW1iZXIgPSAoaW5kZXggKyAxMikgKyAob2N0YXZlICogMTIpICsgMTI7IC8vIOKGkiBpbiBDdWJhc2UgY2VudHJhbCBDID0gQzMgaW5zdGVhZCBvZiBDNFxuICBsZXQgbnVtYmVyID0gKGluZGV4ICsgMTIpICsgKG9jdGF2ZSAqIDEyKTsvLyDihpIgbWlkaSBzdGFuZGFyZCArIHNjaWVudGlmaWMgbmFtaW5nLCBzZWU6IGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTWlkZGxlX0MgYW5kIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU2NpZW50aWZpY19waXRjaF9ub3RhdGlvblxuXG4gIGlmKG51bWJlciA8IDAgfHwgbnVtYmVyID4gMTI3KXtcbiAgICBlcnJvck1zZyA9ICdwbGVhc2UgcHJvdmlkZSBhIG5vdGUgYmV0d2VlbiBDMCBhbmQgRzEwJztcbiAgICByZXR1cm47XG4gIH1cbiAgcmV0dXJuIG51bWJlcjtcbn1cblxuXG5mdW5jdGlvbiBfZ2V0RnJlcXVlbmN5KG51bWJlcil7XG4gIC8vcmV0dXJuIGNvbmZpZy5nZXQoJ3BpdGNoJykgKiBwb3coMiwobnVtYmVyIC0gNjkpLzEyKTsgLy8gbWlkaSBzdGFuZGFyZCwgc2VlOiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01JRElfVHVuaW5nX1N0YW5kYXJkXG4gIHJldHVybiA0NDAgKiBwb3coMiwobnVtYmVyIC0gNjkpLzEyKTsgLy8gbWlkaSBzdGFuZGFyZCwgc2VlOiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01JRElfVHVuaW5nX1N0YW5kYXJkXG59XG5cblxuLy8gVE9ETzogY2FsY3VsYXRlIG5vdGUgZnJvbSBmcmVxdWVuY3lcbmZ1bmN0aW9uIF9nZXRQaXRjaChoZXJ0eil7XG4gIC8vZm0gID0gIDIobeKIkjY5KS8xMig0NDAgSHopLlxufVxuXG5cbmZ1bmN0aW9uIF9jaGVja05vdGVOYW1lTW9kZShtb2RlKXtcbiAgbGV0IGtleXMgPSBPYmplY3Qua2V5cyhub3RlTmFtZXMpO1xuICBsZXQgcmVzdWx0ID0ga2V5cy5maW5kKHggPT4geCA9PT0gbW9kZSkgIT09IHVuZGVmaW5lZDtcbiAgaWYocmVzdWx0ID09PSBmYWxzZSl7XG4gICAgLy9tb2RlID0gY29uZmlnLmdldCgnbm90ZU5hbWVNb2RlJyk7XG4gICAgbW9kZSA9ICdzaGFycCc7XG4gICAgd2FybmluZ01zZyA9IG1vZGUgKyAnIGlzIG5vdCBhIHZhbGlkIG5vdGUgbmFtZSBtb2RlLCB1c2luZyBcIicgKyBtb2RlICsgJ1wiIGluc3RlYWQnO1xuICB9XG4gIHJldHVybiBtb2RlO1xufVxuXG5cbmZ1bmN0aW9uIF9jaGVja05vdGVOYW1lKC4uLmFyZ3Mpe1xuICBsZXRcbiAgICBudW1BcmdzID0gYXJncy5sZW5ndGgsXG4gICAgYXJnMCA9IGFyZ3NbMF0sXG4gICAgYXJnMSA9IGFyZ3NbMV0sXG4gICAgY2hhcixcbiAgICBuYW1lID0gJycsXG4gICAgb2N0YXZlID0gJyc7XG5cbiAgLy8gZXh0cmFjdCBvY3RhdmUgZnJvbSBub3RlIG5hbWVcbiAgaWYobnVtQXJncyA9PT0gMSl7XG4gICAgZm9yKGNoYXIgb2YgYXJnMCl7XG4gICAgICBpZihpc05hTihjaGFyKSAmJiBjaGFyICE9PSAnLScpe1xuICAgICAgICBuYW1lICs9IGNoYXI7XG4gICAgICB9ZWxzZXtcbiAgICAgICAgb2N0YXZlICs9IGNoYXI7XG4gICAgICB9XG4gICAgfVxuICAgIGlmKG9jdGF2ZSA9PT0gJycpe1xuICAgICAgb2N0YXZlID0gMDtcbiAgICB9XG4gIH1lbHNlIGlmKG51bUFyZ3MgPT09IDIpe1xuICAgIG5hbWUgPSBhcmcwO1xuICAgIG9jdGF2ZSA9IGFyZzE7XG4gIH1cblxuICAvLyBjaGVjayBpZiBub3RlIG5hbWUgaXMgdmFsaWRcbiAgbGV0IGtleXMgPSBPYmplY3Qua2V5cyhub3RlTmFtZXMpO1xuICBsZXQgaW5kZXggPSAtMTtcblxuICBmb3IobGV0IGtleSBvZiBrZXlzKXtcbiAgICBsZXQgbW9kZSA9IG5vdGVOYW1lc1trZXldO1xuICAgIGluZGV4ID0gbW9kZS5maW5kSW5kZXgoeCA9PiB4ID09PSBuYW1lKTtcbiAgICBpZihpbmRleCAhPT0gLTEpe1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYoaW5kZXggPT09IC0xKXtcbiAgICBlcnJvck1zZyA9IGFyZzAgKyAnIGlzIG5vdCBhIHZhbGlkIG5vdGUgbmFtZSwgcGxlYXNlIHVzZSBsZXR0ZXJzIEEgLSBHIGFuZCBpZiBuZWNlc3NhcnkgYW4gYWNjaWRlbnRhbCBsaWtlICMsICMjLCBiIG9yIGJiLCBmb2xsb3dlZCBieSBhIG51bWJlciBmb3IgdGhlIG9jdGF2ZSc7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYob2N0YXZlIDwgLTEgfHwgb2N0YXZlID4gOSl7XG4gICAgZXJyb3JNc2cgPSAncGxlYXNlIHByb3ZpZGUgYW4gb2N0YXZlIGJldHdlZW4gLTEgYW5kIDknO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIG9jdGF2ZSA9IHBhcnNlSW50KG9jdGF2ZSwgMTApO1xuICBuYW1lID0gbmFtZS5zdWJzdHJpbmcoMCwgMSkudG9VcHBlckNhc2UoKSArIG5hbWUuc3Vic3RyaW5nKDEpO1xuXG4gIC8vY29uc29sZS5sb2cobmFtZSwnfCcsb2N0YXZlKTtcbiAgcmV0dXJuIFtuYW1lLCBvY3RhdmVdO1xufVxuXG5cblxuZnVuY3Rpb24gX2lzQmxhY2tLZXkobm90ZU51bWJlcil7XG4gIGxldCBibGFjaztcblxuICBzd2l0Y2godHJ1ZSl7XG4gICAgY2FzZSBub3RlTnVtYmVyICUgMTIgPT09IDE6Ly9DI1xuICAgIGNhc2Ugbm90ZU51bWJlciAlIDEyID09PSAzOi8vRCNcbiAgICBjYXNlIG5vdGVOdW1iZXIgJSAxMiA9PT0gNjovL0YjXG4gICAgY2FzZSBub3RlTnVtYmVyICUgMTIgPT09IDg6Ly9HI1xuICAgIGNhc2Ugbm90ZU51bWJlciAlIDEyID09PSAxMDovL0EjXG4gICAgICBibGFjayA9IHRydWU7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgYmxhY2sgPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBibGFjaztcbn1cblxuXG5cblxuZXhwb3J0IGZ1bmN0aW9uIGdldE5vdGVOdW1iZXIoLi4uYXJncyl7XG4gIGxldCBub3RlID0gY3JlYXRlTm90ZSguLi5hcmdzKTtcbiAgaWYobm90ZSl7XG4gICAgcmV0dXJuIG5vdGUubnVtYmVyO1xuICB9XG4gIHJldHVybiBlcnJvck1zZztcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Tm90ZU5hbWUoLi4uYXJncyl7XG4gIGxldCBub3RlID0gY3JlYXRlTm90ZSguLi5hcmdzKTtcbiAgaWYobm90ZSl7XG4gICAgcmV0dXJuIG5vdGUubmFtZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGdldE5vdGVPY3RhdmUoLi4uYXJncyl7XG4gIGxldCBub3RlID0gY3JlYXRlTm90ZSguLi5hcmdzKTtcbiAgaWYobm90ZSl7XG4gICAgcmV0dXJuIG5vdGUub2N0YXZlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RnVsbE5vdGVOYW1lKC4uLmFyZ3Mpe1xuICBsZXQgbm90ZSA9IGNyZWF0ZU5vdGUoLi4uYXJncyk7XG4gIGlmKG5vdGUpe1xuICAgIHJldHVybiBub3RlLmZ1bGxOYW1lO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RnJlcXVlbmN5KC4uLmFyZ3Mpe1xuICBsZXQgbm90ZSA9IGNyZWF0ZU5vdGUoLi4uYXJncyk7XG4gIGlmKG5vdGUpe1xuICAgIHJldHVybiBub3RlLmZyZXF1ZW5jeTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQmxhY2tLZXkoLi4uYXJncyl7XG4gIGxldCBub3RlID0gY3JlYXRlTm90ZSguLi5hcmdzKTtcbiAgaWYobm90ZSl7XG4gICAgcmV0dXJuIG5vdGUuYmxhY2tLZXk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuIiwiaW1wb3J0IHtjb250ZXh0fSBmcm9tICcuL2luaXRfYXVkaW8nXG5pbXBvcnQge3R5cGVTdHJpbmcsIGNoZWNrSWZCYXNlNjQsIGJhc2U2NFRvQmluYXJ5fSBmcm9tICcuL3V0aWwnXG5pbXBvcnQgZmV0Y2ggZnJvbSAnaXNvbW9ycGhpYy1mZXRjaCdcblxuXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlU2FtcGxlKHNhbXBsZSwgaWQsIGV2ZXJ5KXtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpe1xuICAgIHRyeXtcbiAgICAgIGNvbnRleHQuZGVjb2RlQXVkaW9EYXRhKHNhbXBsZSxcblxuICAgICAgICBmdW5jdGlvbiBvblN1Y2Nlc3MoYnVmZmVyKXtcbiAgICAgICAgICAvL2NvbnNvbGUubG9nKGlkLCBidWZmZXIpO1xuICAgICAgICAgIGlmKHR5cGVvZiBpZCAhPT0gJ3VuZGVmaW5lZCcpe1xuICAgICAgICAgICAgcmVzb2x2ZSh7aWQsIGJ1ZmZlcn0pXG4gICAgICAgICAgICBpZihldmVyeSl7XG4gICAgICAgICAgICAgIGV2ZXJ5KHtpZCwgYnVmZmVyfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIHJlc29sdmUoYnVmZmVyKTtcbiAgICAgICAgICAgIGlmKGV2ZXJ5KXtcbiAgICAgICAgICAgICAgZXZlcnkoYnVmZmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZnVuY3Rpb24gb25FcnJvcihlKXtcbiAgICAgICAgICBjb25zb2xlKCdlcnJvciBkZWNvZGluZyBhdWRpb2RhdGEnLCBpZCwgZSk7XG4gICAgICAgICAgLy9yZWplY3QoZSk7IC8vIGRvbid0IHVzZSByZWplY3QgYmVjYXVzZSB3ZSB1c2UgdGhpcyBhcyBhIG5lc3RlZCBwcm9taXNlIGFuZCB3ZSBkb24ndCB3YW50IHRoZSBwYXJlbnQgcHJvbWlzZSB0byByZWplY3RcbiAgICAgICAgICBpZih0eXBlb2YgaWQgIT09ICd1bmRlZmluZWQnKXtcbiAgICAgICAgICAgIHJlc29sdmUoe2lkfSlcbiAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIHJlc29sdmUoKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKVxuICAgIH1jYXRjaChlKXtcbiAgICAgIGNvbnNvbGUud2FybignZXJyb3IgZGVjb2RpbmcgYXVkaW9kYXRhJywgaWQsIGUpXG4gICAgICBpZih0eXBlb2YgaWQgIT09ICd1bmRlZmluZWQnKXtcbiAgICAgICAgcmVzb2x2ZSh7aWR9KVxuICAgICAgfWVsc2V7XG4gICAgICAgIHJlc29sdmUoKVxuICAgICAgfVxuICAgIH1cbiAgfSlcbn1cblxuXG5mdW5jdGlvbiBsb2FkQW5kUGFyc2VTYW1wbGUodXJsLCBpZCwgZXZlcnkpe1xuICAvL2NvbnNvbGUubG9nKGlkLCB1cmwpXG4gIGxldCBleGVjdXRvciA9IGZ1bmN0aW9uKHJlc29sdmUpe1xuICAgIGZldGNoKGVzY2FwZSh1cmwpLCB7XG4gICAgICBtZXRob2Q6ICdHRVQnXG4gICAgfSkudGhlbihcbiAgICAgIGZ1bmN0aW9uKHJlc3BvbnNlKXtcbiAgICAgICAgaWYocmVzcG9uc2Uub2spe1xuICAgICAgICAgIHJlc3BvbnNlLmFycmF5QnVmZmVyKCkudGhlbihmdW5jdGlvbihkYXRhKXtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coZGF0YSlcbiAgICAgICAgICAgIGRlY29kZVNhbXBsZShkYXRhLCBpZCwgZXZlcnkpLnRoZW4ocmVzb2x2ZSlcbiAgICAgICAgICB9KVxuICAgICAgICB9ZWxzZSBpZih0eXBlb2YgaWQgIT09ICd1bmRlZmluZWQnKXtcbiAgICAgICAgICByZXNvbHZlKHtpZH0pXG4gICAgICAgIH1lbHNle1xuICAgICAgICAgIHJlc29sdmUoKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgKVxuICB9XG4gIHJldHVybiBuZXcgUHJvbWlzZShleGVjdXRvcilcbn1cblxuXG5mdW5jdGlvbiBnZXRQcm9taXNlcyhwcm9taXNlcywgc2FtcGxlLCBrZXksIGV2ZXJ5KXtcblxuICBjb25zdCBnZXRTYW1wbGUgPSBmdW5jdGlvbigpe1xuXG4gICAgaWYoc2FtcGxlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpe1xuICAgICAgcHJvbWlzZXMucHVzaChkZWNvZGVTYW1wbGUoc2FtcGxlLCBrZXksIGV2ZXJ5KSlcbiAgICB9ZWxzZSBpZih0eXBlb2Ygc2FtcGxlID09PSAnc3RyaW5nJyl7XG4gICAgICBpZihjaGVja0lmQmFzZTY0KHNhbXBsZSkpe1xuICAgICAgICBwcm9taXNlcy5wdXNoKGRlY29kZVNhbXBsZShiYXNlNjRUb0JpbmFyeShzYW1wbGUpLCBrZXksIGV2ZXJ5KSlcbiAgICAgIH1lbHNle1xuICAgICAgICBwcm9taXNlcy5wdXNoKGxvYWRBbmRQYXJzZVNhbXBsZShzYW1wbGUsIGtleSwgZXZlcnkpKVxuICAgICAgfVxuICAgIH1lbHNlIGlmKHR5cGVvZiBzYW1wbGUgPT09ICdvYmplY3QnKXtcbiAgICAgIHNhbXBsZSA9IHNhbXBsZS5zYW1wbGUgfHwgc2FtcGxlLmJ1ZmZlciB8fCBzYW1wbGUuYmFzZTY0IHx8IHNhbXBsZS51cmxcbiAgICAgIGdldFNhbXBsZShwcm9taXNlcywgc2FtcGxlLCBrZXksIGV2ZXJ5KVxuICAgICAgLy9jb25zb2xlLmxvZyhzYW1wbGUsIHByb21pc2VzLmxlbmd0aClcbiAgICB9XG4gIH1cblxuICBnZXRTYW1wbGUoKVxufVxuXG5cbi8vIG9ubHkgZm9yIGludGVybmFsbHkgdXNlIGluIHFhbWJpXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VTYW1wbGVzMihtYXBwaW5nLCBldmVyeSA9IGZhbHNlKXtcbiAgbGV0IHR5cGUgPSB0eXBlU3RyaW5nKG1hcHBpbmcpLFxuICAgIHByb21pc2VzID0gW11cblxuICBldmVyeSA9IHR5cGVvZiBldmVyeSA9PT0gJ2Z1bmN0aW9uJyA/IGV2ZXJ5IDogZmFsc2VcbiAgLy9jb25zb2xlLmxvZyh0eXBlLCBtYXBwaW5nKVxuICBpZih0eXBlID09PSAnb2JqZWN0Jyl7XG4gICAgT2JqZWN0LmtleXMobWFwcGluZykuZm9yRWFjaChmdW5jdGlvbihrZXkpe1xuICAgICAgLy9rZXkgPSBwYXJzZUludChrZXksIDEwKVxuICAgICAgZ2V0UHJvbWlzZXMocHJvbWlzZXMsIG1hcHBpbmdba2V5XSwga2V5LCBldmVyeSlcbiAgICB9KVxuICB9ZWxzZSBpZih0eXBlID09PSAnYXJyYXknKXtcbiAgICBsZXQga2V5XG4gICAgbWFwcGluZy5mb3JFYWNoKGZ1bmN0aW9uKHNhbXBsZSl7XG4gICAgICAvLyBrZXkgaXMgZGVsaWJlcmF0ZWx5IHVuZGVmaW5lZFxuICAgICAgZ2V0UHJvbWlzZXMocHJvbWlzZXMsIHNhbXBsZSwga2V5LCBldmVyeSlcbiAgICB9KVxuICB9XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpe1xuICAgIFByb21pc2UuYWxsKHByb21pc2VzKVxuICAgIC50aGVuKCh2YWx1ZXMpID0+IHtcbiAgICAgIGlmKHR5cGUgPT09ICdvYmplY3QnKXtcbiAgICAgICAgbWFwcGluZyA9IHt9XG4gICAgICAgIHZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgICAgICBtYXBwaW5nW3ZhbHVlLmlkXSA9IHZhbHVlLmJ1ZmZlclxuICAgICAgICB9KVxuICAgICAgICByZXNvbHZlKG1hcHBpbmcpO1xuICAgICAgfWVsc2UgaWYodHlwZSA9PT0gJ2FycmF5Jyl7XG4gICAgICAgIHJlc29sdmUodmFsdWVzKTtcbiAgICAgIH1cbiAgICB9KVxuICB9KVxufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVNhbXBsZXMoLi4uZGF0YSl7XG4gIGlmKGRhdGEubGVuZ3RoID09PSAxICYmIHR5cGVTdHJpbmcoZGF0YVswXSkgIT09ICdzdHJpbmcnKXtcbiAgICByZXR1cm4gcGFyc2VTYW1wbGVzMihkYXRhWzBdKVxuICB9XG4gIHJldHVybiBwYXJzZVNhbXBsZXMyKGRhdGEpXG59XG4iLCJpbXBvcnQge2dldE5pY2VUaW1lfSBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IHtNSURJTm90ZX0gZnJvbSAnLi9taWRpX25vdGUnO1xuXG5sZXRcbiAgcHBxLFxuICBicG0sXG4gIGZhY3RvcixcbiAgbm9taW5hdG9yLFxuICBkZW5vbWluYXRvcixcbiAgcGxheWJhY2tTcGVlZCxcblxuICBiYXIsXG4gIGJlYXQsXG4gIHNpeHRlZW50aCxcbiAgdGljayxcbiAgdGlja3MsXG4gIG1pbGxpcyxcblxuICBtaWxsaXNQZXJUaWNrLFxuICBzZWNvbmRzUGVyVGljayxcblxuICB0aWNrc1BlckJlYXQsXG4gIHRpY2tzUGVyQmFyLFxuICB0aWNrc1BlclNpeHRlZW50aCxcbiAgbnVtU2l4dGVlbnRoLFxuXG4gIGRpZmZUaWNrcyxcbiAgcHJldmlvdXNFdmVudDtcblxuXG5mdW5jdGlvbiBzZXRUaWNrRHVyYXRpb24oKXtcbiAgc2Vjb25kc1BlclRpY2sgPSAoMSAvIHBsYXliYWNrU3BlZWQgKiA2MCkgLyBicG0gLyBwcHE7XG4gIG1pbGxpc1BlclRpY2sgPSBzZWNvbmRzUGVyVGljayAqIDEwMDA7XG4gIC8vY29uc29sZS5sb2cobWlsbGlzUGVyVGljaywgYnBtLCBwcHEsIHBsYXliYWNrU3BlZWQsIChwcHEgKiBtaWxsaXNQZXJUaWNrKSk7XG4gIC8vY29uc29sZS5sb2cocHBxKTtcbn1cblxuXG5mdW5jdGlvbiBzZXRUaWNrc1BlckJlYXQoKXtcbiAgZmFjdG9yID0gKDQgLyBkZW5vbWluYXRvcik7XG4gIG51bVNpeHRlZW50aCA9IGZhY3RvciAqIDQ7XG4gIHRpY2tzUGVyQmVhdCA9IHBwcSAqIGZhY3RvcjtcbiAgdGlja3NQZXJCYXIgPSB0aWNrc1BlckJlYXQgKiBub21pbmF0b3I7XG4gIHRpY2tzUGVyU2l4dGVlbnRoID0gcHBxIC8gNDtcbiAgLy9jb25zb2xlLmxvZyhkZW5vbWluYXRvciwgZmFjdG9yLCBudW1TaXh0ZWVudGgsIHRpY2tzUGVyQmVhdCwgdGlja3NQZXJCYXIsIHRpY2tzUGVyU2l4dGVlbnRoKTtcbn1cblxuXG5mdW5jdGlvbiB1cGRhdGVQb3NpdGlvbihldmVudCwgZmFzdCA9IGZhbHNlKXtcbiAgZGlmZlRpY2tzID0gZXZlbnQudGlja3MgLSB0aWNrcztcbiAgLy8gaWYoZGlmZlRpY2tzIDwgMCl7XG4gIC8vICAgY29uc29sZS5sb2coZGlmZlRpY2tzLCBldmVudC50aWNrcywgcHJldmlvdXNFdmVudC50aWNrcywgcHJldmlvdXNFdmVudC50eXBlKVxuICAvLyB9XG4gIHRpY2sgKz0gZGlmZlRpY2tzO1xuICB0aWNrcyA9IGV2ZW50LnRpY2tzO1xuICBwcmV2aW91c0V2ZW50ID0gZXZlbnRcbiAgLy9jb25zb2xlLmxvZyhkaWZmVGlja3MsIG1pbGxpc1BlclRpY2spO1xuICBtaWxsaXMgKz0gZGlmZlRpY2tzICogbWlsbGlzUGVyVGljaztcblxuICBpZihmYXN0ID09PSBmYWxzZSl7XG4gICAgd2hpbGUodGljayA+PSB0aWNrc1BlclNpeHRlZW50aCl7XG4gICAgICBzaXh0ZWVudGgrKztcbiAgICAgIHRpY2sgLT0gdGlja3NQZXJTaXh0ZWVudGg7XG4gICAgICB3aGlsZShzaXh0ZWVudGggPiBudW1TaXh0ZWVudGgpe1xuICAgICAgICBzaXh0ZWVudGggLT0gbnVtU2l4dGVlbnRoO1xuICAgICAgICBiZWF0Kys7XG4gICAgICAgIHdoaWxlKGJlYXQgPiBub21pbmF0b3Ipe1xuICAgICAgICAgIGJlYXQgLT0gbm9taW5hdG9yO1xuICAgICAgICAgIGJhcisrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlVGltZUV2ZW50cyhzZXR0aW5ncywgdGltZUV2ZW50cywgaXNQbGF5aW5nID0gZmFsc2Upe1xuICAvL2NvbnNvbGUubG9nKCdwYXJzZSB0aW1lIGV2ZW50cycpXG4gIGxldCB0eXBlO1xuICBsZXQgZXZlbnQ7XG5cbiAgcHBxID0gc2V0dGluZ3MucHBxO1xuICBicG0gPSBzZXR0aW5ncy5icG07XG4gIG5vbWluYXRvciA9IHNldHRpbmdzLm5vbWluYXRvcjtcbiAgZGVub21pbmF0b3IgPSBzZXR0aW5ncy5kZW5vbWluYXRvcjtcbiAgcGxheWJhY2tTcGVlZCA9IHNldHRpbmdzLnBsYXliYWNrU3BlZWQ7XG4gIGJhciA9IDE7XG4gIGJlYXQgPSAxO1xuICBzaXh0ZWVudGggPSAxO1xuICB0aWNrID0gMDtcbiAgdGlja3MgPSAwO1xuICBtaWxsaXMgPSAwO1xuXG4gIHNldFRpY2tEdXJhdGlvbigpO1xuICBzZXRUaWNrc1BlckJlYXQoKTtcblxuICB0aW1lRXZlbnRzLnNvcnQoKGEsIGIpID0+IChhLnRpY2tzIDw9IGIudGlja3MpID8gLTEgOiAxKTtcbiAgbGV0IGUgPSAwO1xuICBmb3IoZXZlbnQgb2YgdGltZUV2ZW50cyl7XG4gICAgLy9jb25zb2xlLmxvZyhlKyssIGV2ZW50LnRpY2tzLCBldmVudC50eXBlKVxuICAgIC8vZXZlbnQuc29uZyA9IHNvbmc7XG4gICAgdHlwZSA9IGV2ZW50LnR5cGU7XG4gICAgdXBkYXRlUG9zaXRpb24oZXZlbnQsIGlzUGxheWluZyk7XG5cbiAgICBzd2l0Y2godHlwZSl7XG5cbiAgICAgIGNhc2UgMHg1MTpcbiAgICAgICAgYnBtID0gZXZlbnQuZGF0YTE7XG4gICAgICAgIC8vY29uc29sZS5sb2coZXZlbnQpXG4gICAgICAgIHNldFRpY2tEdXJhdGlvbigpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAweDU4OlxuICAgICAgICBub21pbmF0b3IgPSBldmVudC5kYXRhMTtcbiAgICAgICAgZGVub21pbmF0b3IgPSBldmVudC5kYXRhMjtcbiAgICAgICAgc2V0VGlja3NQZXJCZWF0KCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvL3RpbWUgZGF0YSBvZiB0aW1lIGV2ZW50IGlzIHZhbGlkIGZyb20gKGFuZCBpbmNsdWRlZCkgdGhlIHBvc2l0aW9uIG9mIHRoZSB0aW1lIGV2ZW50XG4gICAgdXBkYXRlRXZlbnQoZXZlbnQsIGlzUGxheWluZyk7XG4gICAgLy9jb25zb2xlLmxvZyhldmVudC5iYXJzQXNTdHJpbmcpO1xuICB9XG5cbiAgLy9zb25nLmxhc3RFdmVudFRtcCA9IGV2ZW50O1xuICAvL2NvbnNvbGUubG9nKGV2ZW50KTtcbiAgLy9jb25zb2xlLmxvZyh0aW1lRXZlbnRzKTtcbn1cblxuXG4vL2V4cG9ydCBmdW5jdGlvbiBwYXJzZUV2ZW50cyhzb25nLCBldmVudHMpe1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlRXZlbnRzKGV2ZW50cywgaXNQbGF5aW5nID0gZmFsc2Upe1xuICAvL2NvbnNvbGUubG9nKCdwYXJzZUV2ZW50cycpXG4gIGxldCBldmVudDtcbiAgbGV0IHN0YXJ0RXZlbnQgPSAwO1xuICBsZXQgbGFzdEV2ZW50VGljayA9IDA7XG4gIGxldCByZXN1bHQgPSBbXVxuXG4gIHRpY2sgPSAwXG4gIHRpY2tzID0gMFxuICBkaWZmVGlja3MgPSAwXG5cbiAgLy9sZXQgZXZlbnRzID0gW10uY29uY2F0KGV2dHMsIHNvbmcuX3RpbWVFdmVudHMpO1xuICBsZXQgbnVtRXZlbnRzID0gZXZlbnRzLmxlbmd0aFxuICAvL2NvbnNvbGUubG9nKGV2ZW50cylcblxuICAvLyBub3Rlb2ZmIGNvbWVzIGJlZm9yZSBub3Rlb25cblxuLypcbiAgZXZlbnRzLnNvcnQoZnVuY3Rpb24oYSwgYil7XG4gICAgcmV0dXJuIGEuc29ydEluZGV4IC0gYi5zb3J0SW5kZXg7XG4gIH0pXG4qL1xuXG4gIGV2ZW50cy5zb3J0KGZ1bmN0aW9uKGEsIGIpe1xuICAgIGlmKGEudGlja3MgPT09IGIudGlja3Mpe1xuICAgICAgLy8gaWYoYS50eXBlID09PSAxMjgpe1xuICAgICAgLy8gICByZXR1cm4gLTFcbiAgICAgIC8vIH1lbHNlIGlmKGIudHlwZSA9PT0gMTI4KXtcbiAgICAgIC8vICAgcmV0dXJuIDFcbiAgICAgIC8vIH1cbiAgICAgIC8vIHNob3J0OlxuICAgICAgbGV0IHIgPSBhLnR5cGUgLSBiLnR5cGU7XG4gICAgICBpZihhLnR5cGUgPT09IDE3NiAmJiBiLnR5cGUgPT09IDE0NCl7XG4gICAgICAgIHIgPSAtMVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJcbiAgICB9XG4gICAgcmV0dXJuIGEudGlja3MgLSBiLnRpY2tzXG4gIH0pXG4gIGV2ZW50ID0gZXZlbnRzWzBdXG4gIC8vY29uc29sZS5sb2coZXZlbnQpXG5cblxuICBicG0gPSBldmVudC5icG07XG4gIGZhY3RvciA9IGV2ZW50LmZhY3RvcjtcbiAgbm9taW5hdG9yID0gZXZlbnQubm9taW5hdG9yO1xuICBkZW5vbWluYXRvciA9IGV2ZW50LmRlbm9taW5hdG9yO1xuXG4gIHRpY2tzUGVyQmFyID0gZXZlbnQudGlja3NQZXJCYXI7XG4gIHRpY2tzUGVyQmVhdCA9IGV2ZW50LnRpY2tzUGVyQmVhdDtcbiAgdGlja3NQZXJTaXh0ZWVudGggPSBldmVudC50aWNrc1BlclNpeHRlZW50aDtcblxuICBudW1TaXh0ZWVudGggPSBldmVudC5udW1TaXh0ZWVudGg7XG5cbiAgbWlsbGlzUGVyVGljayA9IGV2ZW50Lm1pbGxpc1BlclRpY2s7XG4gIHNlY29uZHNQZXJUaWNrID0gZXZlbnQuc2Vjb25kc1BlclRpY2s7XG5cbiAgbWlsbGlzID0gZXZlbnQubWlsbGlzO1xuXG4gIGJhciA9IGV2ZW50LmJhcjtcbiAgYmVhdCA9IGV2ZW50LmJlYXQ7XG4gIHNpeHRlZW50aCA9IGV2ZW50LnNpeHRlZW50aDtcbiAgdGljayA9IGV2ZW50LnRpY2s7XG5cblxuICBmb3IobGV0IGkgPSBzdGFydEV2ZW50OyBpIDwgbnVtRXZlbnRzOyBpKyspe1xuXG4gICAgZXZlbnQgPSBldmVudHNbaV07XG5cbiAgICBzd2l0Y2goZXZlbnQudHlwZSl7XG5cbiAgICAgIGNhc2UgMHg1MTpcbiAgICAgICAgYnBtID0gZXZlbnQuZGF0YTE7XG4gICAgICAgIG1pbGxpcyA9IGV2ZW50Lm1pbGxpcztcbiAgICAgICAgbWlsbGlzUGVyVGljayA9IGV2ZW50Lm1pbGxpc1BlclRpY2s7XG4gICAgICAgIHNlY29uZHNQZXJUaWNrID0gZXZlbnQuc2Vjb25kc1BlclRpY2s7XG5cbiAgICAgICAgZGlmZlRpY2tzID0gZXZlbnQudGlja3MgLSB0aWNrc1xuICAgICAgICB0aWNrICs9IGRpZmZUaWNrc1xuICAgICAgICB0aWNrcyA9IGV2ZW50LnRpY2tzXG4gICAgICAgIC8vY29uc29sZS5sb2cobWlsbGlzUGVyVGljayxldmVudC5taWxsaXNQZXJUaWNrKTtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhldmVudCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDB4NTg6XG4gICAgICAgIGZhY3RvciA9IGV2ZW50LmZhY3RvcjtcbiAgICAgICAgbm9taW5hdG9yID0gZXZlbnQuZGF0YTE7XG4gICAgICAgIGRlbm9taW5hdG9yID0gZXZlbnQuZGF0YTI7XG4gICAgICAgIG51bVNpeHRlZW50aCA9IGV2ZW50Lm51bVNpeHRlZW50aDtcbiAgICAgICAgdGlja3NQZXJCYXIgPSBldmVudC50aWNrc1BlckJhcjtcbiAgICAgICAgdGlja3NQZXJCZWF0ID0gZXZlbnQudGlja3NQZXJCZWF0O1xuICAgICAgICB0aWNrc1BlclNpeHRlZW50aCA9IGV2ZW50LnRpY2tzUGVyU2l4dGVlbnRoO1xuICAgICAgICBtaWxsaXMgPSBldmVudC5taWxsaXM7XG5cbiAgICAgICAgZGlmZlRpY2tzID0gZXZlbnQudGlja3MgLSB0aWNrc1xuICAgICAgICB0aWNrICs9IGRpZmZUaWNrc1xuICAgICAgICB0aWNrcyA9IGV2ZW50LnRpY2tzXG4gICAgICAgIC8vY29uc29sZS5sb2cobm9taW5hdG9yLG51bVNpeHRlZW50aCx0aWNrc1BlclNpeHRlZW50aCk7XG4gICAgICAgIC8vY29uc29sZS5sb2coZXZlbnQpO1xuXG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAvL2Nhc2UgMTI4OlxuICAgICAgLy9jYXNlIDE0NDpcbiAgICAgICAgdXBkYXRlUG9zaXRpb24oZXZlbnQsIGlzUGxheWluZyk7XG4gICAgICAgIHVwZGF0ZUV2ZW50KGV2ZW50LCBpc1BsYXlpbmcpO1xuICAgICAgICByZXN1bHQucHVzaChldmVudClcblxuICAgICAgICAvLyBpZihldmVudC50eXBlID09PSAxNzYgJiYgZXZlbnQuZGF0YTEgPT09IDY0KXtcbiAgICAgICAgLy8gICBjb25zb2xlLmxvZyhldmVudC5kYXRhMiwgZXZlbnQuYmFyc0FzU3RyaW5nKVxuICAgICAgICAvLyB9XG5cbiAgICB9XG5cblxuICAgIC8vIGlmKGkgPCAxMDAgJiYgKGV2ZW50LnR5cGUgPT09IDgxIHx8IGV2ZW50LnR5cGUgPT09IDE0NCB8fCBldmVudC50eXBlID09PSAxMjgpKXtcbiAgICAvLyAgIC8vY29uc29sZS5sb2coaSwgdGlja3MsIGRpZmZUaWNrcywgbWlsbGlzLCBtaWxsaXNQZXJUaWNrKVxuICAgIC8vICAgY29uc29sZS5sb2coZXZlbnQudHlwZSwgZXZlbnQubWlsbGlzLCAnbm90ZScsIGV2ZW50LmRhdGExLCAndmVsbycsIGV2ZW50LmRhdGEyKVxuICAgIC8vIH1cblxuICAgIGxhc3RFdmVudFRpY2sgPSBldmVudC50aWNrcztcbiAgfVxuICBwYXJzZU1JRElOb3RlcyhyZXN1bHQpXG4gIHJldHVybiByZXN1bHQ7XG4gIC8vc29uZy5sYXN0RXZlbnRUbXAgPSBldmVudDtcbn1cblxuXG5mdW5jdGlvbiB1cGRhdGVFdmVudChldmVudCwgZmFzdCA9IGZhbHNlKXtcbiAgLy9jb25zb2xlLmxvZyhiYXIsIGJlYXQsIHRpY2tzKVxuICAvL2NvbnNvbGUubG9nKGV2ZW50LCBicG0sIG1pbGxpc1BlclRpY2ssIHRpY2tzLCBtaWxsaXMpO1xuXG4gIGV2ZW50LmJwbSA9IGJwbTtcbiAgZXZlbnQubm9taW5hdG9yID0gbm9taW5hdG9yO1xuICBldmVudC5kZW5vbWluYXRvciA9IGRlbm9taW5hdG9yO1xuXG4gIGV2ZW50LnRpY2tzUGVyQmFyID0gdGlja3NQZXJCYXI7XG4gIGV2ZW50LnRpY2tzUGVyQmVhdCA9IHRpY2tzUGVyQmVhdDtcbiAgZXZlbnQudGlja3NQZXJTaXh0ZWVudGggPSB0aWNrc1BlclNpeHRlZW50aDtcblxuICBldmVudC5mYWN0b3IgPSBmYWN0b3I7XG4gIGV2ZW50Lm51bVNpeHRlZW50aCA9IG51bVNpeHRlZW50aDtcbiAgZXZlbnQuc2Vjb25kc1BlclRpY2sgPSBzZWNvbmRzUGVyVGljaztcbiAgZXZlbnQubWlsbGlzUGVyVGljayA9IG1pbGxpc1BlclRpY2s7XG5cblxuICBldmVudC50aWNrcyA9IHRpY2tzO1xuXG4gIGV2ZW50Lm1pbGxpcyA9IG1pbGxpcztcbiAgZXZlbnQuc2Vjb25kcyA9IG1pbGxpcyAvIDEwMDA7XG5cbiAgaWYoZmFzdCl7XG4gICAgcmV0dXJuXG4gIH1cblxuICBldmVudC5iYXIgPSBiYXI7XG4gIGV2ZW50LmJlYXQgPSBiZWF0O1xuICBldmVudC5zaXh0ZWVudGggPSBzaXh0ZWVudGg7XG4gIGV2ZW50LnRpY2sgPSB0aWNrO1xuICAvL2V2ZW50LmJhcnNBc1N0cmluZyA9IChiYXIgKyAxKSArICc6JyArIChiZWF0ICsgMSkgKyAnOicgKyAoc2l4dGVlbnRoICsgMSkgKyAnOicgKyB0aWNrO1xuICB2YXIgdGlja0FzU3RyaW5nID0gdGljayA9PT0gMCA/ICcwMDAnIDogdGljayA8IDEwID8gJzAwJyArIHRpY2sgOiB0aWNrIDwgMTAwID8gJzAnICsgdGljayA6IHRpY2s7XG4gIGV2ZW50LmJhcnNBc1N0cmluZyA9IGJhciArICc6JyArIGJlYXQgKyAnOicgKyBzaXh0ZWVudGggKyAnOicgKyB0aWNrQXNTdHJpbmc7XG4gIGV2ZW50LmJhcnNBc0FycmF5ID0gW2JhciwgYmVhdCwgc2l4dGVlbnRoLCB0aWNrXTtcblxuXG4gIHZhciB0aW1lRGF0YSA9IGdldE5pY2VUaW1lKG1pbGxpcyk7XG5cbiAgZXZlbnQuaG91ciA9IHRpbWVEYXRhLmhvdXI7XG4gIGV2ZW50Lm1pbnV0ZSA9IHRpbWVEYXRhLm1pbnV0ZTtcbiAgZXZlbnQuc2Vjb25kID0gdGltZURhdGEuc2Vjb25kO1xuICBldmVudC5taWxsaXNlY29uZCA9IHRpbWVEYXRhLm1pbGxpc2Vjb25kO1xuICBldmVudC50aW1lQXNTdHJpbmcgPSB0aW1lRGF0YS50aW1lQXNTdHJpbmc7XG4gIGV2ZW50LnRpbWVBc0FycmF5ID0gdGltZURhdGEudGltZUFzQXJyYXk7XG5cbiAgLy8gaWYobWlsbGlzIDwgMCl7XG4gIC8vICAgY29uc29sZS5sb2coZXZlbnQpXG4gIC8vIH1cblxuXG59XG5cblxubGV0IG1pZGlOb3RlSW5kZXggPSAwXG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZU1JRElOb3RlcyhldmVudHMpe1xuICBsZXQgbm90ZXMgPSB7fVxuICBsZXQgbm90ZXNJblRyYWNrXG4gIGxldCBuID0gMFxuICBmb3IobGV0IGV2ZW50IG9mIGV2ZW50cyl7XG4gICAgaWYodHlwZW9mIGV2ZW50Ll9wYXJ0ID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgZXZlbnQuX3RyYWNrID09PSAndW5kZWZpbmVkJyl7XG4gICAgICBjb25zb2xlLmxvZygnbm8gcGFydCBhbmQvb3IgdHJhY2sgc2V0JylcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIGlmKGV2ZW50LnR5cGUgPT09IDE0NCl7XG4gICAgICBub3Rlc0luVHJhY2sgPSBub3Rlc1tldmVudC5fdHJhY2suaWRdXG4gICAgICBpZih0eXBlb2Ygbm90ZXNJblRyYWNrID09PSAndW5kZWZpbmVkJyl7XG4gICAgICAgIG5vdGVzSW5UcmFjayA9IG5vdGVzW2V2ZW50Ll90cmFjay5pZF0gPSB7fVxuICAgICAgfVxuICAgICAgbm90ZXNJblRyYWNrW2V2ZW50LmRhdGExXSA9IGV2ZW50XG4gICAgfWVsc2UgaWYoZXZlbnQudHlwZSA9PT0gMTI4KXtcbiAgICAgIG5vdGVzSW5UcmFjayA9IG5vdGVzW2V2ZW50Ll90cmFjay5pZF1cbiAgICAgIGlmKHR5cGVvZiBub3Rlc0luVHJhY2sgPT09ICd1bmRlZmluZWQnKXtcbiAgICAgICAgLy9jb25zb2xlLmluZm8obisrLCAnbm8gY29ycmVzcG9uZGluZyBub3Rlb24gZXZlbnQgZm91bmQgZm9yIGV2ZW50JywgZXZlbnQuaWQpXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICBsZXQgbm90ZU9uID0gbm90ZXNJblRyYWNrW2V2ZW50LmRhdGExXVxuICAgICAgbGV0IG5vdGVPZmYgPSBldmVudFxuICAgICAgaWYodHlwZW9mIG5vdGVPbiA9PT0gJ3VuZGVmaW5lZCcpe1xuICAgICAgICAvL2NvbnNvbGUuaW5mbyhuKyssICdubyBub3Rlb24gZXZlbnQgZm9yIGV2ZW50JywgZXZlbnQuaWQpXG4gICAgICAgIGRlbGV0ZSBub3Rlc1tldmVudC5fdHJhY2suaWRdW2V2ZW50LmRhdGExXVxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgbGV0IG5vdGUgPSBuZXcgTUlESU5vdGUobm90ZU9uLCBub3RlT2ZmKVxuICAgICAgLy8gbGV0IGlkID0gYE1OXyR7bWlkaU5vdGVJbmRleCsrfV8ke25ldyBEYXRlKCkuZ2V0VGltZSgpfWBcbiAgICAgIC8vIG5vdGVPbi5taWRpTm90ZUlkID0gaWRcbiAgICAgIC8vIG5vdGVPbi5vZmYgPSBub3RlT2ZmLmlkXG4gICAgICAvLyBub3RlT2ZmLm1pZGlOb3RlSWQgPSBpZFxuICAgICAgLy8gbm90ZU9mZi5vbiA9IG5vdGVPbi5pZFxuICAgICAgZGVsZXRlIG5vdGVzW2V2ZW50Ll90cmFjay5pZF1bZXZlbnQuZGF0YTFdXG4gICAgfVxuICB9XG4gIE9iamVjdC5rZXlzKG5vdGVzKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSl7XG4gICAgZGVsZXRlIG5vdGVzW2tleV1cbiAgfSlcbiAgLy9jb25zb2xlLmxvZyhub3Rlcywgbm90ZXNJblRyYWNrKVxufVxuXG5cbi8vIG5vdCBpbiB1c2UhXG5leHBvcnQgZnVuY3Rpb24gZmlsdGVyRXZlbnRzKGV2ZW50cyl7XG4gIGxldCBzdXN0YWluID0ge31cbiAgbGV0IHRtcFJlc3VsdCA9IHt9XG4gIGxldCByZXN1bHQgPSBbXVxuICBmb3IobGV0IGV2ZW50IG9mIGV2ZW50cyl7XG4gICAgaWYoZXZlbnQudHlwZSA9PT0gMTc2ICYmIGV2ZW50LmRhdGExID09PSA2NCl7XG4gICAgICBpZihldmVudC5kYXRhMiA9PT0gMCl7XG4gICAgICAgIGlmKHR5cGVvZiBzdXN0YWluW2V2ZW50LnRyYWNrSWRdID09PSAndW5kZWZpbmVkJyl7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfWVsc2UgaWYoc3VzdGFpbltldmVudC50cmFja0lkXSA9PT0gZXZlbnQudGlja3Mpe1xuICAgICAgICAgIGRlbGV0ZSB0bXBSZXN1bHRbZXZlbnQudGlja3NdXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgICB0bXBSZXN1bHRbZXZlbnQudGlja3NdID0gZXZlbnRcbiAgICAgICAgZGVsZXRlIHN1c3RhaW5bZXZlbnQudHJhY2tJZF1cbiAgICAgIH1lbHNlIGlmKGV2ZW50LmRhdGEyID09PSAxMjcpe1xuICAgICAgICBzdXN0YWluW2V2ZW50LnRyYWNrSWRdID0gZXZlbnQudGlja3NcbiAgICAgICAgdG1wUmVzdWx0W2V2ZW50LnRpY2tzXSA9IGV2ZW50XG4gICAgICB9XG4gICAgfWVsc2V7XG4gICAgICByZXN1bHQucHVzaChldmVudClcbiAgICB9XG4gIH1cbiAgY29uc29sZS5sb2coc3VzdGFpbilcbiAgT2JqZWN0LmtleXModG1wUmVzdWx0KS5mb3JFYWNoKGZ1bmN0aW9uKGtleSl7XG4gICAgbGV0IHN1c3RhaW5FdmVudCA9IHRtcFJlc3VsdFtrZXldXG4gICAgY29uc29sZS5sb2coc3VzdGFpbkV2ZW50KVxuICAgIHJlc3VsdC5wdXNoKHN1c3RhaW5FdmVudClcbiAgfSlcbiAgcmV0dXJuIHJlc3VsdFxufVxuIiwiLy8gQCBmbG93XG5cbmltcG9ydCB7c29ydEV2ZW50c30gZnJvbSAnLi91dGlsJ1xuXG5sZXQgcGFydEluZGV4ID0gMFxuXG5leHBvcnQgY2xhc3MgUGFydHtcblxuICBjb25zdHJ1Y3RvcihuYW1lOiBzdHJpbmcgPSBudWxsKXtcbiAgICB0aGlzLmlkID0gYE1QXyR7cGFydEluZGV4Kyt9XyR7bmV3IERhdGUoKS5nZXRUaW1lKCl9YFxuICAgIHRoaXMubmFtZSA9IG5hbWUgfHwgdGhpcy5pZFxuICAgIHRoaXMubXV0ZWQgPSBmYWxzZVxuICAgIHRoaXMuX3RyYWNrID0gbnVsbFxuICAgIHRoaXMuX3NvbmcgPSBudWxsXG4gICAgdGhpcy5fZXZlbnRzID0gW11cbiAgICB0aGlzLl9ldmVudHNCeUlkID0gbmV3IE1hcCgpXG4gICAgdGhpcy5fbmVlZHNVcGRhdGUgPSBmYWxzZVxuICAgIHRoaXMuX2NyZWF0ZUV2ZW50QXJyYXkgPSBmYWxzZVxuICAgIHRoaXMuX3N0YXJ0ID0ge21pbGxpczogMCwgdGlja3M6IDB9XG4gICAgdGhpcy5fZW5kID0ge21pbGxpczogMCwgdGlja3M6IDB9XG4gIH1cblxuICBjb3B5KCl7XG4gICAgbGV0IHAgPSBuZXcgUGFydCh0aGlzLm5hbWUgKyAnX2NvcHknKSAvLyBpbXBsZW1lbnQgZ2V0TmFtZU9mQ29weSgpIGluIHV0aWwgKHNlZSBoZWFydGJlYXQpXG4gICAgbGV0IGV2ZW50cyA9IFtdXG4gICAgdGhpcy5fZXZlbnRzLmZvckVhY2goZnVuY3Rpb24oZXZlbnQpe1xuICAgICAgbGV0IGNvcHkgPSBldmVudC5jb3B5KClcbiAgICAgIGNvbnNvbGUubG9nKGNvcHkpXG4gICAgICBldmVudHMucHVzaChjb3B5KVxuICAgIH0pXG4gICAgcC5hZGRFdmVudHMoLi4uZXZlbnRzKVxuICAgIHAudXBkYXRlKClcbiAgICByZXR1cm4gcFxuICB9XG5cbiAgdHJhbnNwb3NlKGFtb3VudDogbnVtYmVyKXtcbiAgICB0aGlzLl9ldmVudHMuZm9yRWFjaCgoZXZlbnQpID0+IHtcbiAgICAgIGV2ZW50LnRyYW5zcG9zZShhbW91bnQpXG4gICAgfSlcbiAgICB0aGlzLl9uZWVkc1VwZGF0ZSA9IHRydWVcbiAgfVxuXG4gIG1vdmUodGlja3M6IG51bWJlcil7XG4gICAgdGhpcy5fZXZlbnRzLmZvckVhY2goKGV2ZW50KSA9PiB7XG4gICAgICBldmVudC5tb3ZlKHRpY2tzKVxuICAgIH0pXG4gICAgaWYodGhpcy5fc29uZyl7XG4gICAgICB0aGlzLl9zb25nLl9tb3ZlZEV2ZW50cy5wdXNoKC4uLnRoaXMuX2V2ZW50cylcbiAgICB9XG4gICAgdGhpcy5fbmVlZHNVcGRhdGUgPSB0cnVlXG4gIH1cblxuICBtb3ZlVG8odGlja3M6IG51bWJlcil7XG4gICAgdGhpcy5fZXZlbnRzLmZvckVhY2goKGV2ZW50KSA9PiB7XG4gICAgICBldmVudC5tb3ZlVG8odGlja3MpXG4gICAgfSlcbiAgICBpZih0aGlzLl9zb25nKXtcbiAgICAgIHRoaXMuX3NvbmcuX21vdmVkRXZlbnRzLnB1c2goLi4udGhpcy5fZXZlbnRzKVxuICAgIH1cbiAgICB0aGlzLl9uZWVkc1VwZGF0ZSA9IHRydWVcbiAgfVxuXG4gIGFkZEV2ZW50cyguLi5ldmVudHMpe1xuICAgIGxldCB0cmFjayA9IHRoaXMuX3RyYWNrXG4gICAgZXZlbnRzLmZvckVhY2goKGV2ZW50KSA9PiB7XG4gICAgICBldmVudC5fcGFydCA9IHRoaXNcbiAgICAgIHRoaXMuX2V2ZW50c0J5SWQuc2V0KGV2ZW50LmlkLCBldmVudClcbiAgICAgIHRoaXMuX2V2ZW50cy5wdXNoKGV2ZW50KVxuICAgICAgaWYodHJhY2spe1xuICAgICAgICBldmVudC5fdHJhY2sgPSB0cmFja1xuICAgICAgfVxuICAgIH0pXG4gICAgaWYodHJhY2spe1xuICAgICAgdHJhY2suX2V2ZW50cy5wdXNoKC4uLmV2ZW50cylcbiAgICAgIHRyYWNrLl9uZWVkc1VwZGF0ZSA9IHRydWVcbiAgICB9XG4gICAgaWYodGhpcy5fc29uZyl7XG4gICAgICB0aGlzLl9zb25nLl9uZXdFdmVudHMucHVzaCguLi5ldmVudHMpXG4gICAgfVxuICAgIHRoaXMuX25lZWRzVXBkYXRlID0gdHJ1ZVxuICB9XG5cbiAgcmVtb3ZlRXZlbnRzKC4uLmV2ZW50cyl7XG4gICAgbGV0IHRyYWNrID0gdGhpcy5fdHJhY2tcbiAgICBldmVudHMuZm9yRWFjaCgoZXZlbnQpID0+IHtcbiAgICAgIGV2ZW50Ll9wYXJ0ID0gbnVsbFxuICAgICAgdGhpcy5fZXZlbnRzQnlJZC5kZWxldGUoZXZlbnQuaWQpXG4gICAgICBpZih0cmFjayl7XG4gICAgICAgIGV2ZW50Ll90cmFjayA9IG51bGxcbiAgICAgICAgdHJhY2suX2V2ZW50c0J5SWQuZGVsZXRlKGV2ZW50LmlkKVxuICAgICAgfVxuICAgIH0pXG4gICAgaWYodHJhY2spe1xuICAgICAgdHJhY2suX25lZWRzVXBkYXRlID0gdHJ1ZVxuICAgICAgdHJhY2suX2NyZWF0ZUV2ZW50QXJyYXkgPSB0cnVlXG4gICAgfVxuICAgIGlmKHRoaXMuX3Nvbmcpe1xuICAgICAgdGhpcy5fc29uZy5fcmVtb3ZlZEV2ZW50cy5wdXNoKC4uLmV2ZW50cylcbiAgICB9XG4gICAgdGhpcy5fY3JlYXRlRXZlbnRBcnJheSA9IHRydWVcbiAgICB0aGlzLl9uZWVkc1VwZGF0ZSA9IHRydWVcbiAgfVxuXG4gIG1vdmVFdmVudHModGlja3M6IG51bWJlciwgLi4uZXZlbnRzKXtcbiAgICBldmVudHMuZm9yRWFjaCgoZXZlbnQpID0+IHtcbiAgICAgIGV2ZW50Lm1vdmUodGlja3MpXG4gICAgfSlcbiAgICBpZih0aGlzLl9zb25nKXtcbiAgICAgIHRoaXMuX3NvbmcuX21vdmVkRXZlbnRzLnB1c2goLi4udGhpcy5fZXZlbnRzKVxuICAgIH1cbiAgICB0aGlzLl9uZWVkc1VwZGF0ZSA9IHRydWVcbiAgfVxuXG4gIG1vdmVFdmVudHNUbyh0aWNrczogbnVtYmVyLCAuLi5ldmVudHMpe1xuICAgIGV2ZW50cy5mb3JFYWNoKChldmVudCkgPT4ge1xuICAgICAgZXZlbnQubW92ZVRvKHRpY2tzKVxuICAgIH0pXG4gICAgaWYodGhpcy5fc29uZyl7XG4gICAgICB0aGlzLl9zb25nLl9tb3ZlZEV2ZW50cy5wdXNoKC4uLnRoaXMuX2V2ZW50cylcbiAgICB9XG4gICAgdGhpcy5fbmVlZHNVcGRhdGUgPSB0cnVlXG4gIH1cblxuXG4gIGdldEV2ZW50cyhmaWx0ZXI6IHN0cmluZ1tdID0gbnVsbCl7IC8vIGNhbiBiZSB1c2UgYXMgZmluZEV2ZW50c1xuICAgIGlmKHRoaXMuX25lZWRzVXBkYXRlKXtcbiAgICAgIHRoaXMudXBkYXRlKClcbiAgICB9XG4gICAgcmV0dXJuIFsuLi50aGlzLl9ldmVudHNdIC8vQFRPRE8gaW1wbGVtZW50IGZpbHRlciAtPiBmaWx0ZXJFdmVudHMoKSBzaG91bGQgYmUgYSB1dGlsaXR5IGZ1bmN0aW9uIChub3QgYSBjbGFzcyBtZXRob2QpXG4gIH1cblxuICBtdXRlKGZsYWc6IGJvb2xlYW4gPSBudWxsKXtcbiAgICBpZihmbGFnKXtcbiAgICAgIHRoaXMubXV0ZWQgPSBmbGFnXG4gICAgfWVsc2V7XG4gICAgICB0aGlzLm11dGVkID0gIXRoaXMubXV0ZWRcbiAgICB9XG4gIH1cblxuICB1cGRhdGUoKXtcbiAgICBpZih0aGlzLl9uZWVkc1VwZGF0ZSA9PT0gZmFsc2Upe1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmKHRoaXMuX2NyZWF0ZUV2ZW50QXJyYXkpe1xuICAgICAgdGhpcy5fZXZlbnRzID0gQXJyYXkuZnJvbSh0aGlzLl9ldmVudHNCeUlkLnZhbHVlcygpKVxuICAgICAgdGhpcy5fY3JlYXRlRXZlbnRBcnJheSA9IGZhbHNlXG4gICAgfVxuICAgIHNvcnRFdmVudHModGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX25lZWRzVXBkYXRlID0gZmFsc2VcbiAgICAvL0BUT0RPOiBjYWxjdWxhdGUgcGFydCBzdGFydCBhbmQgZW5kLCBhbmQgaGlnaGVzdCBhbmQgbG93ZXN0IG5vdGVcbiAgfVxufVxuIiwiaW1wb3J0IHtnZXRQb3NpdGlvbjJ9IGZyb20gJy4vcG9zaXRpb24uanMnXG5pbXBvcnQge2Rpc3BhdGNoRXZlbnR9IGZyb20gJy4vZXZlbnRsaXN0ZW5lci5qcydcbmltcG9ydCB7c29ydEV2ZW50c30gZnJvbSAnLi91dGlsLmpzJ1xuXG5jb25zdCByYW5nZSA9IDEwIC8vIG1pbGxpc2Vjb25kcyBvciB0aWNrc1xubGV0IGluc3RhbmNlSWQgPSAwXG5cbmV4cG9ydCBjbGFzcyBQbGF5aGVhZHtcblxuICBjb25zdHJ1Y3Rvcihzb25nLCB0eXBlID0gJ2FsbCcpe1xuICAgIHRoaXMuaWQgPSBgUE9TICR7aW5zdGFuY2VJZCsrfSAke25ldyBEYXRlKCkuZ2V0VGltZSgpfWBcbiAgICB0aGlzLnNvbmcgPSBzb25nXG4gICAgdGhpcy50eXBlID0gdHlwZVxuICAgIHRoaXMubGFzdEV2ZW50ID0gbnVsbFxuICAgIHRoaXMuZGF0YSA9IHt9XG5cbiAgICB0aGlzLmFjdGl2ZVBhcnRzID0gW11cbiAgICB0aGlzLmFjdGl2ZU5vdGVzID0gW11cbiAgICB0aGlzLmFjdGl2ZUV2ZW50cyA9IFtdXG4gIH1cblxuICAvLyB1bml0IGNhbiBiZSAnbWlsbGlzJyBvciAndGlja3MnXG4gIHNldCh1bml0LCB2YWx1ZSl7XG4gICAgdGhpcy51bml0ID0gdW5pdFxuICAgIHRoaXMuY3VycmVudFZhbHVlID0gdmFsdWVcbiAgICB0aGlzLmV2ZW50SW5kZXggPSAwXG4gICAgdGhpcy5ub3RlSW5kZXggPSAwXG4gICAgdGhpcy5wYXJ0SW5kZXggPSAwXG4gICAgdGhpcy5jYWxjdWxhdGUoKVxuICAgIHJldHVybiB0aGlzLmRhdGFcbiAgfVxuXG5cbiAgZ2V0KCl7XG4gICAgcmV0dXJuIHRoaXMuZGF0YVxuICB9XG5cblxuICB1cGRhdGUodW5pdCwgZGlmZil7XG4gICAgaWYoZGlmZiA9PT0gMCl7XG4gICAgICByZXR1cm4gdGhpcy5kYXRhXG4gICAgfVxuICAgIHRoaXMudW5pdCA9IHVuaXRcbiAgICB0aGlzLmN1cnJlbnRWYWx1ZSArPSBkaWZmXG4gICAgdGhpcy5jYWxjdWxhdGUoKVxuICAgIHJldHVybiB0aGlzLmRhdGFcbiAgfVxuXG5cbiAgdXBkYXRlU29uZygpe1xuICAgIHRoaXMuZXZlbnRzID0gWy4uLnRoaXMuc29uZy5fZXZlbnRzLCAuLi50aGlzLnNvbmcuX3RpbWVFdmVudHNdXG4gICAgc29ydEV2ZW50cyh0aGlzLmV2ZW50cylcbiAgICBjb25zb2xlLmxvZygnZXZlbnRzICVPJywgdGhpcy5ldmVudHMpXG4gICAgdGhpcy5ub3RlcyA9IHRoaXMuc29uZy5fbm90ZXNcbiAgICB0aGlzLnBhcnRzID0gdGhpcy5zb25nLl9wYXJ0c1xuICAgIHRoaXMubnVtRXZlbnRzID0gdGhpcy5ldmVudHMubGVuZ3RoXG4gICAgdGhpcy5udW1Ob3RlcyA9IHRoaXMubm90ZXMubGVuZ3RoXG4gICAgdGhpcy5udW1QYXJ0cyA9IHRoaXMucGFydHMubGVuZ3RoXG4gICAgdGhpcy5zZXQoJ21pbGxpcycsIHRoaXMuc29uZy5fbWlsbGlzKVxuICB9XG5cblxuICBjYWxjdWxhdGUoKXtcbiAgICBsZXQgaVxuICAgIGxldCB2YWx1ZVxuICAgIGxldCBldmVudFxuICAgIGxldCBub3RlXG4gICAgbGV0IHBhcnRcbiAgICBsZXQgcG9zaXRpb25cbiAgICBsZXQgc3RpbGxBY3RpdmVOb3RlcyA9IFtdXG4gICAgbGV0IHN0aWxsQWN0aXZlUGFydHMgPSBbXVxuICAgIGxldCBjb2xsZWN0ZWRQYXJ0cyA9IG5ldyBTZXQoKVxuICAgIGxldCBjb2xsZWN0ZWROb3RlcyA9IG5ldyBTZXQoKVxuXG4gICAgdGhpcy5kYXRhID0ge31cbiAgICB0aGlzLmFjdGl2ZUV2ZW50cyA9IFtdXG5cbiAgICBmb3IoaSA9IHRoaXMuZXZlbnRJbmRleDsgaSA8IHRoaXMubnVtRXZlbnRzOyBpKyspe1xuICAgICAgZXZlbnQgPSB0aGlzLmV2ZW50c1tpXVxuICAgICAgdmFsdWUgPSBldmVudFt0aGlzLnVuaXRdXG4gICAgICBpZih2YWx1ZSA8PSB0aGlzLmN1cnJlbnRWYWx1ZSl7XG4gICAgICAgIC8vIGlmIHRoZSBwbGF5aGVhZCBpcyBzZXQgdG8gYSBwb3NpdGlvbiBvZiBzYXkgMzAwMCBtaWxsaXMsIHdlIGRvbid0IHdhbnQgdG8gYWRkIGV2ZW50cyBtb3JlIHRoYXQgMTAgdW5pdHMgYmVmb3JlIHRoZSBwbGF5aGVhZFxuICAgICAgICBpZih2YWx1ZSA9PT0gMCB8fCB2YWx1ZSA+IHRoaXMuY3VycmVudFZhbHVlIC0gcmFuZ2Upe1xuICAgICAgICAgIHRoaXMuYWN0aXZlRXZlbnRzLnB1c2goZXZlbnQpXG4gICAgICAgICAgZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgICB0eXBlOiAnZXZlbnQnLFxuICAgICAgICAgICAgZGF0YTogZXZlbnRcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubGFzdEV2ZW50ID0gZXZlbnRcbiAgICAgICAgdGhpcy5ldmVudEluZGV4KytcbiAgICAgIH1lbHNle1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmRhdGEuYWN0aXZlRXZlbnRzID0gdGhpcy5hY3RpdmVFdmVudHNcblxuICAgIC8vIGlmIGEgc29uZyBoYXMgbm8gZXZlbnRzIHlldCwgdXNlIHRoZSBmaXJzdCB0aW1lIGV2ZW50IGFzIHJlZmVyZW5jZVxuICAgIGlmKHRoaXMubGFzdEV2ZW50ID09PSBudWxsKXtcbiAgICAgIHRoaXMubGFzdEV2ZW50ID0gdGhpcy5zb25nLl90aW1lRXZlbnRzWzBdXG4gICAgfVxuXG4gICAgcG9zaXRpb24gPSBnZXRQb3NpdGlvbjIodGhpcy5zb25nLCB0aGlzLnVuaXQsIHRoaXMuY3VycmVudFZhbHVlLCAnYWxsJywgdGhpcy5sYXN0RXZlbnQpXG4gICAgdGhpcy5kYXRhLmV2ZW50SW5kZXggPSB0aGlzLmV2ZW50SW5kZXhcbiAgICB0aGlzLmRhdGEubWlsbGlzID0gcG9zaXRpb24ubWlsbGlzXG4gICAgdGhpcy5kYXRhLnRpY2tzID0gcG9zaXRpb24udGlja3NcbiAgICB0aGlzLmRhdGEucG9zaXRpb24gPSBwb3NpdGlvblxuICAgIGRpc3BhdGNoRXZlbnQoe1xuICAgICAgdHlwZTogJ3Bvc2l0aW9uJyxcbiAgICAgIGRhdGE6IHBvc2l0aW9uXG4gICAgfSlcblxuICAgIGlmKHRoaXMudHlwZS5pbmRleE9mKCdhbGwnKSAhPT0gLTEpe1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLmRhdGFcbiAgICAgIGZvcihsZXQga2V5IG9mIE9iamVjdC5rZXlzKHBvc2l0aW9uKSl7XG4gICAgICAgIGRhdGFba2V5XSA9IHBvc2l0aW9uW2tleV1cbiAgICAgIH1cbiAgICB9ZWxzZSBpZih0aGlzLnR5cGUuaW5kZXhPZignYmFyc2JlYXRzJykgIT09IC0xKXtcbiAgICAgIHRoaXMuZGF0YS5iYXIgPSBwb3NpdGlvbi5iYXJcbiAgICAgIHRoaXMuZGF0YS5iZWF0ID0gcG9zaXRpb24uYmVhdFxuICAgICAgdGhpcy5kYXRhLnNpeHRlZW50aCA9IHBvc2l0aW9uLnNpeHRlZW50aFxuICAgICAgdGhpcy5kYXRhLnRpY2sgPSBwb3NpdGlvbi50aWNrXG4gICAgICB0aGlzLmRhdGEuYmFyc0FzU3RyaW5nID0gcG9zaXRpb24uYmFyc0FzU3RyaW5nXG5cbiAgICAgIHRoaXMuZGF0YS50aWNrc1BlckJhciA9IHBvc2l0aW9uLnRpY2tzUGVyQmFyXG4gICAgICB0aGlzLmRhdGEudGlja3NQZXJCZWF0ID0gcG9zaXRpb24udGlja3NQZXJCZWF0XG4gICAgICB0aGlzLmRhdGEudGlja3NQZXJTaXh0ZWVudGggPSBwb3NpdGlvbi50aWNrc1BlclNpeHRlZW50aFxuICAgICAgdGhpcy5kYXRhLm51bVNpeHRlZW50aCA9IHBvc2l0aW9uLm51bVNpeHRlZW50aFxuXG4gICAgfWVsc2UgaWYodGhpcy50eXBlLmluZGV4T2YoJ3RpbWUnKSAhPT0gLTEpe1xuICAgICAgdGhpcy5kYXRhLmhvdXIgPSBwb3NpdGlvbi5ob3VyXG4gICAgICB0aGlzLmRhdGEubWludXRlID0gcG9zaXRpb24ubWludXRlXG4gICAgICB0aGlzLmRhdGEuc2Vjb25kID0gcG9zaXRpb24uc2Vjb25kXG4gICAgICB0aGlzLmRhdGEubWlsbGlzZWNvbmQgPSBwb3NpdGlvbi5taWxsaXNlY29uZFxuICAgICAgdGhpcy5kYXRhLnRpbWVBc1N0cmluZyA9IHBvc2l0aW9uLnRpbWVBc1N0cmluZ1xuXG4gICAgfWVsc2UgaWYodGhpcy50eXBlLmluZGV4T2YoJ3BlcmNlbnRhZ2UnKSAhPT0gLTEpe1xuICAgICAgdGhpcy5kYXRhLnBlcmNlbnRhZ2UgPSBwb3NpdGlvbi5wZXJjZW50YWdlXG4gICAgfVxuXG4gICAgLy8gZ2V0IGFjdGl2ZSBub3Rlc1xuICAgIGlmKHRoaXMudHlwZS5pbmRleE9mKCdub3RlcycpICE9PSAtMSB8fCB0aGlzLnR5cGUuaW5kZXhPZignYWxsJykgIT09IC0xKXtcblxuICAgICAgLy8gZ2V0IGFsbCBub3RlcyBiZXR3ZWVuIHRoZSBub3RlSW5kZXggYW5kIHRoZSBjdXJyZW50IHBsYXloZWFkIHBvc2l0aW9uXG4gICAgICBmb3IoaSA9IHRoaXMubm90ZUluZGV4OyBpIDwgdGhpcy5udW1Ob3RlczsgaSsrKXtcbiAgICAgICAgbm90ZSA9IHRoaXMubm90ZXNbaV1cbiAgICAgICAgdmFsdWUgPSBub3RlLm5vdGVPblt0aGlzLnVuaXRdXG4gICAgICAgIGlmKHZhbHVlIDw9IHRoaXMuY3VycmVudFZhbHVlKXtcbiAgICAgICAgICB0aGlzLm5vdGVJbmRleCsrXG4gICAgICAgICAgaWYodHlwZW9mIG5vdGUubm90ZU9mZiA9PT0gJ3VuZGVmaW5lZCcpe1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGlmIHRoZSBwbGF5aGVhZCBpcyBzZXQgdG8gYSBwb3NpdGlvbiBvZiBzYXkgMzAwMCBtaWxsaXMsIHdlIGRvbid0IHdhbnQgdG8gYWRkIG5vdGVzIGJlZm9yZSB0aGUgcGxheWhlYWRcbiAgICAgICAgICBpZih0aGlzLmN1cnJlbnRWYWx1ZSA9PT0gMCB8fCBub3RlLm5vdGVPZmZbdGhpcy51bml0XSA+IHRoaXMuY3VycmVudFZhbHVlKXtcbiAgICAgICAgICAgIGNvbGxlY3RlZE5vdGVzLmFkZChub3RlKVxuICAgICAgICAgICAgZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgICAgIHR5cGU6ICdub3RlT24nLFxuICAgICAgICAgICAgICBkYXRhOiBub3RlXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gZmlsdGVyIG5vdGVzIHRoYXQgYXJlIG5vIGxvbmdlciBhY3RpdmVcbiAgICAgIGZvcihpID0gdGhpcy5hY3RpdmVOb3Rlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSl7XG4gICAgICAgIG5vdGUgPSB0aGlzLmFjdGl2ZU5vdGVzW2ldO1xuICAgICAgICAvL2lmKG5vdGUubm90ZU9uLnN0YXRlLmluZGV4T2YoJ3JlbW92ZWQnKSA9PT0gMCB8fCB0aGlzLnNvbmcuX25vdGVzQnlJZC5nZXQobm90ZS5pZCkgPT09IGZhbHNlKXtcbiAgICAgICAgaWYodGhpcy5zb25nLl9ub3Rlc0J5SWQuZ2V0KG5vdGUuaWQpID09PSBmYWxzZSl7XG4gICAgICAgICAgLy9jb25zb2xlLmxvZygnc2tpcHBpbmcgcmVtb3ZlZCBub3RlJywgbm90ZS5pZCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZih0eXBlb2Ygbm90ZS5ub3RlT2ZmID09PSAndW5kZWZpbmVkJyl7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdub3RlIHdpdGggaWQnLCBub3RlLmlkLCAnaGFzIG5vIG5vdGVPZmYgZXZlbnQnKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vaWYobm90ZS5ub3RlT2ZmW3RoaXMudW5pdF0gPiB0aGlzLmN1cnJlbnRWYWx1ZSAmJiBjb2xsZWN0ZWROb3Rlcy5oYXMobm90ZSkgPT09IGZhbHNlKXtcbiAgICAgICAgaWYobm90ZS5ub3RlT2ZmW3RoaXMudW5pdF0gPiB0aGlzLmN1cnJlbnRWYWx1ZSl7XG4gICAgICAgICAgc3RpbGxBY3RpdmVOb3Rlcy5wdXNoKG5vdGUpO1xuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICBkaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICAgIHR5cGU6ICdub3RlT2ZmJyxcbiAgICAgICAgICAgIGRhdGE6IG5vdGVcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGFkZCB0aGUgc3RpbGwgYWN0aXZlIG5vdGVzIGFuZCB0aGUgbmV3bHkgYWN0aXZlIGV2ZW50cyB0byB0aGUgYWN0aXZlIG5vdGVzIGFycmF5XG4gICAgICB0aGlzLmFjdGl2ZU5vdGVzID0gWy4uLmNvbGxlY3RlZE5vdGVzLnZhbHVlcygpLCAuLi5zdGlsbEFjdGl2ZU5vdGVzXVxuICAgICAgdGhpcy5kYXRhLmFjdGl2ZU5vdGVzID0gdGhpcy5hY3RpdmVOb3Rlc1xuICAgIH1cblxuXG4gICAgLy8gZ2V0IGFjdGl2ZSBwYXJ0c1xuICAgIGlmKHRoaXMudHlwZS5pbmRleE9mKCdwYXJ0cycpICE9PSAtMSB8fCB0aGlzLnR5cGUuaW5kZXhPZignYWxsJykgIT09IC0xKXtcblxuICAgICAgZm9yKGkgPSB0aGlzLnBhcnRJbmRleDsgaSA8IHRoaXMubnVtUGFydHM7IGkrKyl7XG4gICAgICAgIHBhcnQgPSB0aGlzLnBhcnRzW2ldXG4gICAgICAgIC8vY29uc29sZS5sb2cocGFydCwgdGhpcy51bml0LCB0aGlzLmN1cnJlbnRWYWx1ZSk7XG4gICAgICAgIGlmKHBhcnQuX3N0YXJ0W3RoaXMudW5pdF0gPD0gdGhpcy5jdXJyZW50VmFsdWUpe1xuICAgICAgICAgIGNvbGxlY3RlZFBhcnRzLmFkZChwYXJ0KVxuICAgICAgICAgIGRpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgICAgdHlwZTogJ3BhcnRPbicsXG4gICAgICAgICAgICBkYXRhOiBwYXJ0XG4gICAgICAgICAgfSlcbiAgICAgICAgICB0aGlzLnBhcnRJbmRleCsrXG4gICAgICAgIH1lbHNle1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cblxuXG4gICAgICAvLyBmaWx0ZXIgcGFydHMgdGhhdCBhcmUgbm8gbG9uZ2VyIGFjdGl2ZVxuICAgICAgZm9yKGkgPSB0aGlzLmFjdGl2ZVBhcnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKXtcbiAgICAgICAgcGFydCA9IHRoaXMuYWN0aXZlUGFydHNbaV07XG4gICAgICAgIC8vaWYocGFydC5zdGF0ZS5pbmRleE9mKCdyZW1vdmVkJykgPT09IDAgfHwgdGhpcy5zb25nLl9wYXJ0c0J5SWQuZ2V0KHBhcnQuaWQpID09PSBmYWxzZSl7XG4gICAgICAgIGlmKHRoaXMuc29uZy5fcGFydHNCeUlkLmdldChwYXJ0LmlkKSA9PT0gZmFsc2Upe1xuICAgICAgICAgIC8vY29uc29sZS5sb2coJ3NraXBwaW5nIHJlbW92ZWQgcGFydCcsIHBhcnQuaWQpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9pZihwYXJ0Ll9lbmRbdGhpcy51bml0XSA+IHRoaXMuY3VycmVudFZhbHVlICYmIGNvbGxlY3RlZFBhcnRzLmhhcyhwYXJ0KSA9PT0gZmFsc2Upe1xuICAgICAgICBpZihwYXJ0Ll9lbmRbdGhpcy51bml0XSA+IHRoaXMuY3VycmVudFZhbHVlKXtcbiAgICAgICAgICBzdGlsbEFjdGl2ZVBhcnRzLnB1c2gobm90ZSk7XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgIGRpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgICAgdHlwZTogJ3BhcnRPZmYnLFxuICAgICAgICAgICAgZGF0YTogcGFydFxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5hY3RpdmVQYXJ0cyA9IFsuLi5jb2xsZWN0ZWRQYXJ0cy52YWx1ZXMoKSwgLi4uc3RpbGxBY3RpdmVQYXJ0c11cbiAgICAgIHRoaXMuZGF0YS5hY3RpdmVQYXJ0cyA9IHRoaXMuYWN0aXZlUGFydHNcbiAgICB9XG5cbiAgICBkaXNwYXRjaEV2ZW50KHtcbiAgICAgIHR5cGU6ICdwbGF5aGVhZCcsXG4gICAgICBkYXRhOiB0aGlzLmRhdGFcbiAgICB9KVxuXG4gIH1cblxuLypcbiAgc2V0VHlwZSh0KXtcbiAgICB0aGlzLnR5cGUgPSB0O1xuICAgIHRoaXMuc2V0KHRoaXMudW5pdCwgdGhpcy5jdXJyZW50VmFsdWUpO1xuICAgIC8vY29uc29sZS5sb2codHlwZSxhY3RpdmVQYXJ0cyk7XG4gIH1cblxuXG4gIGFkZFR5cGUodCl7XG4gICAgdGhpcy50eXBlICs9ICcgJyArIHQ7XG4gICAgdGhpcy5zZXQodGhpcy51bml0LCB0aGlzLmN1cnJlbnRWYWx1ZSk7XG4gICAgLy9jb25zb2xlLmxvZyh0eXBlLGFjdGl2ZVBhcnRzKTtcbiAgfVxuXG4gIHJlbW92ZVR5cGUodCl7XG4gICAgdmFyIGFyciA9IHRoaXMudHlwZS5zcGxpdCgnICcpO1xuICAgIHRoaXMudHlwZSA9ICcnO1xuICAgIGFyci5mb3JFYWNoKGZ1bmN0aW9uKHR5cGUpe1xuICAgICAgaWYodHlwZSAhPT0gdCl7XG4gICAgICAgIHRoaXMudHlwZSArPSB0ICsgJyAnO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMudHlwZS50cmltKCk7XG4gICAgdGhpcy5zZXQodGhpcy5jdXJyZW50VmFsdWUpO1xuICAgIC8vY29uc29sZS5sb2codHlwZSxhY3RpdmVQYXJ0cyk7XG4gIH1cbiovXG5cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHtnZXROaWNlVGltZX0gZnJvbSAnLi91dGlsJztcblxuY29uc3RcbiAgc3VwcG9ydGVkVHlwZXMgPSAnYmFyc2FuZGJlYXRzIGJhcnNiZWF0cyB0aW1lIG1pbGxpcyB0aWNrcyBwZXJjIHBlcmNlbnRhZ2UnLFxuICBzdXBwb3J0ZWRSZXR1cm5UeXBlcyA9ICdiYXJzYW5kYmVhdHMgYmFyc2JlYXRzIHRpbWUgbWlsbGlzIHRpY2tzIGFsbCcsXG4gIGZsb29yID0gTWF0aC5mbG9vcixcbiAgcm91bmQgPSBNYXRoLnJvdW5kO1xuXG5cbmxldFxuICAvL2xvY2FsXG4gIGJwbSxcbiAgbm9taW5hdG9yLFxuICBkZW5vbWluYXRvcixcblxuICB0aWNrc1BlckJlYXQsXG4gIHRpY2tzUGVyQmFyLFxuICB0aWNrc1BlclNpeHRlZW50aCxcblxuICBtaWxsaXNQZXJUaWNrLFxuICBzZWNvbmRzUGVyVGljayxcbiAgbnVtU2l4dGVlbnRoLFxuXG4gIHRpY2tzLFxuICBtaWxsaXMsXG4gIGRpZmZUaWNrcyxcbiAgZGlmZk1pbGxpcyxcblxuICBiYXIsXG4gIGJlYXQsXG4gIHNpeHRlZW50aCxcbiAgdGljayxcblxuLy8gIHR5cGUsXG4gIGluZGV4LFxuICByZXR1cm5UeXBlID0gJ2FsbCcsXG4gIGJleW9uZEVuZE9mU29uZyA9IHRydWU7XG5cblxuZnVuY3Rpb24gZ2V0VGltZUV2ZW50KHNvbmcsIHVuaXQsIHRhcmdldCl7XG4gIC8vIGZpbmRzIHRoZSB0aW1lIGV2ZW50IHRoYXQgY29tZXMgdGhlIGNsb3Nlc3QgYmVmb3JlIHRoZSB0YXJnZXQgcG9zaXRpb25cbiAgbGV0IHRpbWVFdmVudHMgPSBzb25nLl90aW1lRXZlbnRzXG5cbiAgZm9yKGxldCBpID0gdGltZUV2ZW50cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSl7XG4gICAgbGV0IGV2ZW50ID0gdGltZUV2ZW50c1tpXTtcbiAgICBpZihldmVudFt1bml0XSA8PSB0YXJnZXQpe1xuICAgICAgaW5kZXggPSBpXG4gICAgICByZXR1cm4gZXZlbnRcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGxcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gbWlsbGlzVG9UaWNrcyhzb25nLCB0YXJnZXRNaWxsaXMsIGJlb3MgPSB0cnVlKXtcbiAgYmV5b25kRW5kT2ZTb25nID0gYmVvc1xuICBmcm9tTWlsbGlzKHNvbmcsIHRhcmdldE1pbGxpcylcbiAgLy9yZXR1cm4gcm91bmQodGlja3MpO1xuICByZXR1cm4gdGlja3Ncbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gdGlja3NUb01pbGxpcyhzb25nLCB0YXJnZXRUaWNrcywgYmVvcyA9IHRydWUpe1xuICBiZXlvbmRFbmRPZlNvbmcgPSBiZW9zXG4gIGZyb21UaWNrcyhzb25nLCB0YXJnZXRUaWNrcylcbiAgcmV0dXJuIG1pbGxpc1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBiYXJzVG9NaWxsaXMoc29uZywgcG9zaXRpb24sIGJlb3MpeyAvLyBiZW9zID0gYmV5b25kRW5kT2ZTb25nXG4gIGNhbGN1bGF0ZVBvc2l0aW9uKHNvbmcsIHtcbiAgICB0eXBlOiAnYmFyc2JlYXQnLFxuICAgIHBvc2l0aW9uLFxuICAgIHJlc3VsdDogJ21pbGxpcycsXG4gICAgYmVvcyxcbiAgfSlcbiAgcmV0dXJuIG1pbGxpc1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBiYXJzVG9UaWNrcyhzb25nLCBwb3NpdGlvbiwgYmVvcyl7IC8vIGJlb3MgPSBiZXlvbmRFbmRPZlNvbmdcbiAgY2FsY3VsYXRlUG9zaXRpb24oc29uZywge1xuICAgIHR5cGU6ICdiYXJzYmVhdHMnLFxuICAgIHBvc2l0aW9uLFxuICAgIHJlc3VsdDogJ3RpY2tzJyxcbiAgICBiZW9zXG4gIH0pXG4gIC8vcmV0dXJuIHJvdW5kKHRpY2tzKTtcbiAgcmV0dXJuIHRpY2tzXG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIHRpY2tzVG9CYXJzKHNvbmcsIHRhcmdldCwgYmVvcyA9IHRydWUpe1xuICBiZXlvbmRFbmRPZlNvbmcgPSBiZW9zXG4gIGZyb21UaWNrcyhzb25nLCB0YXJnZXQpXG4gIGNhbGN1bGF0ZUJhcnNBbmRCZWF0cygpXG4gIHJldHVyblR5cGUgPSAnYmFyc2FuZGJlYXRzJ1xuICByZXR1cm4gZ2V0UG9zaXRpb25EYXRhKClcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gbWlsbGlzVG9CYXJzKHNvbmcsIHRhcmdldCwgYmVvcyA9IHRydWUpe1xuICBiZXlvbmRFbmRPZlNvbmcgPSBiZW9zXG4gIGZyb21NaWxsaXMoc29uZywgdGFyZ2V0KVxuICBjYWxjdWxhdGVCYXJzQW5kQmVhdHMoKVxuICByZXR1cm5UeXBlID0gJ2JhcnNhbmRiZWF0cydcbiAgcmV0dXJuIGdldFBvc2l0aW9uRGF0YSgpXG59XG5cblxuLy8gbWFpbiBjYWxjdWxhdGlvbiBmdW5jdGlvbiBmb3IgbWlsbGlzIHBvc2l0aW9uXG5mdW5jdGlvbiBmcm9tTWlsbGlzKHNvbmcsIHRhcmdldE1pbGxpcywgZXZlbnQpe1xuICBsZXQgbGFzdEV2ZW50ID0gc29uZy5fbGFzdEV2ZW50O1xuXG4gIGlmKGJleW9uZEVuZE9mU29uZyA9PT0gZmFsc2Upe1xuICAgIGlmKHRhcmdldE1pbGxpcyA+IGxhc3RFdmVudC5taWxsaXMpe1xuICAgICAgdGFyZ2V0TWlsbGlzID0gbGFzdEV2ZW50Lm1pbGxpcztcbiAgICB9XG4gIH1cblxuICBpZih0eXBlb2YgZXZlbnQgPT09ICd1bmRlZmluZWQnKXtcbiAgICBldmVudCA9IGdldFRpbWVFdmVudChzb25nLCAnbWlsbGlzJywgdGFyZ2V0TWlsbGlzKTtcbiAgfVxuICBnZXREYXRhRnJvbUV2ZW50KGV2ZW50KTtcblxuICAvLyBpZiB0aGUgZXZlbnQgaXMgbm90IGV4YWN0bHkgYXQgdGFyZ2V0IG1pbGxpcywgY2FsY3VsYXRlIHRoZSBkaWZmXG4gIGlmKGV2ZW50Lm1pbGxpcyA9PT0gdGFyZ2V0TWlsbGlzKXtcbiAgICBkaWZmTWlsbGlzID0gMDtcbiAgICBkaWZmVGlja3MgPSAwO1xuICB9ZWxzZXtcbiAgICBkaWZmTWlsbGlzID0gdGFyZ2V0TWlsbGlzIC0gZXZlbnQubWlsbGlzO1xuICAgIGRpZmZUaWNrcyA9IGRpZmZNaWxsaXMgLyBtaWxsaXNQZXJUaWNrO1xuICB9XG5cbiAgbWlsbGlzICs9IGRpZmZNaWxsaXM7XG4gIHRpY2tzICs9IGRpZmZUaWNrcztcblxuICByZXR1cm4gdGlja3M7XG59XG5cblxuLy8gbWFpbiBjYWxjdWxhdGlvbiBmdW5jdGlvbiBmb3IgdGlja3MgcG9zaXRpb25cbmZ1bmN0aW9uIGZyb21UaWNrcyhzb25nLCB0YXJnZXRUaWNrcywgZXZlbnQpe1xuICBsZXQgbGFzdEV2ZW50ID0gc29uZy5fbGFzdEV2ZW50O1xuXG4gIGlmKGJleW9uZEVuZE9mU29uZyA9PT0gZmFsc2Upe1xuICAgIGlmKHRhcmdldFRpY2tzID4gbGFzdEV2ZW50LnRpY2tzKXtcbiAgICAgIHRhcmdldFRpY2tzID0gbGFzdEV2ZW50LnRpY2tzO1xuICAgIH1cbiAgfVxuXG4gIGlmKHR5cGVvZiBldmVudCA9PT0gJ3VuZGVmaW5lZCcpe1xuICAgIGV2ZW50ID0gZ2V0VGltZUV2ZW50KHNvbmcsICd0aWNrcycsIHRhcmdldFRpY2tzKTtcbiAgfVxuICBnZXREYXRhRnJvbUV2ZW50KGV2ZW50KTtcblxuICAvLyBpZiB0aGUgZXZlbnQgaXMgbm90IGV4YWN0bHkgYXQgdGFyZ2V0IHRpY2tzLCBjYWxjdWxhdGUgdGhlIGRpZmZcbiAgaWYoZXZlbnQudGlja3MgPT09IHRhcmdldFRpY2tzKXtcbiAgICBkaWZmVGlja3MgPSAwO1xuICAgIGRpZmZNaWxsaXMgPSAwO1xuICB9ZWxzZXtcbiAgICBkaWZmVGlja3MgPSB0YXJnZXRUaWNrcyAtIHRpY2tzO1xuICAgIGRpZmZNaWxsaXMgPSBkaWZmVGlja3MgKiBtaWxsaXNQZXJUaWNrO1xuICB9XG5cbiAgdGlja3MgKz0gZGlmZlRpY2tzO1xuICBtaWxsaXMgKz0gZGlmZk1pbGxpcztcblxuICByZXR1cm4gbWlsbGlzO1xufVxuXG5cbi8vIG1haW4gY2FsY3VsYXRpb24gZnVuY3Rpb24gZm9yIGJhcnMgYW5kIGJlYXRzIHBvc2l0aW9uXG5mdW5jdGlvbiBmcm9tQmFycyhzb25nLCB0YXJnZXRCYXIsIHRhcmdldEJlYXQsIHRhcmdldFNpeHRlZW50aCwgdGFyZ2V0VGljaywgZXZlbnQgPSBudWxsKXtcbiAgLy9jb25zb2xlLnRpbWUoJ2Zyb21CYXJzJyk7XG4gIGxldCBpID0gMCxcbiAgICBkaWZmQmFycyxcbiAgICBkaWZmQmVhdHMsXG4gICAgZGlmZlNpeHRlZW50aCxcbiAgICBkaWZmVGljayxcbiAgICBsYXN0RXZlbnQgPSBzb25nLl9sYXN0RXZlbnQ7XG5cbiAgaWYoYmV5b25kRW5kT2ZTb25nID09PSBmYWxzZSl7XG4gICAgaWYodGFyZ2V0QmFyID4gbGFzdEV2ZW50LmJhcil7XG4gICAgICB0YXJnZXRCYXIgPSBsYXN0RXZlbnQuYmFyO1xuICAgIH1cbiAgfVxuXG4gIGlmKGV2ZW50ID09PSBudWxsKXtcbiAgICBldmVudCA9IGdldFRpbWVFdmVudChzb25nLCAnYmFyJywgdGFyZ2V0QmFyKTtcbiAgfVxuICAvL2NvbnNvbGUubG9nKGV2ZW50KVxuICBnZXREYXRhRnJvbUV2ZW50KGV2ZW50KTtcblxuICAvL2NvcnJlY3Qgd3JvbmcgcG9zaXRpb24gZGF0YSwgZm9yIGluc3RhbmNlOiAnMywzLDIsNzg4JyBiZWNvbWVzICczLDQsNCwwNjgnIGluIGEgNC80IG1lYXN1cmUgYXQgUFBRIDQ4MFxuICB3aGlsZSh0YXJnZXRUaWNrID49IHRpY2tzUGVyU2l4dGVlbnRoKXtcbiAgICB0YXJnZXRTaXh0ZWVudGgrKztcbiAgICB0YXJnZXRUaWNrIC09IHRpY2tzUGVyU2l4dGVlbnRoO1xuICB9XG5cbiAgd2hpbGUodGFyZ2V0U2l4dGVlbnRoID4gbnVtU2l4dGVlbnRoKXtcbiAgICB0YXJnZXRCZWF0Kys7XG4gICAgdGFyZ2V0U2l4dGVlbnRoIC09IG51bVNpeHRlZW50aDtcbiAgfVxuXG4gIHdoaWxlKHRhcmdldEJlYXQgPiBub21pbmF0b3Ipe1xuICAgIHRhcmdldEJhcisrO1xuICAgIHRhcmdldEJlYXQgLT0gbm9taW5hdG9yO1xuICB9XG5cbiAgZXZlbnQgPSBnZXRUaW1lRXZlbnQoc29uZywgJ2JhcicsIHRhcmdldEJhciwgaW5kZXgpO1xuICBmb3IoaSA9IGluZGV4OyBpID49IDA7IGktLSl7XG4gICAgZXZlbnQgPSBzb25nLl90aW1lRXZlbnRzW2ldO1xuICAgIGlmKGV2ZW50LmJhciA8PSB0YXJnZXRCYXIpe1xuICAgICAgZ2V0RGF0YUZyb21FdmVudChldmVudCk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICAvLyBnZXQgdGhlIGRpZmZlcmVuY2VzXG4gIGRpZmZUaWNrID0gdGFyZ2V0VGljayAtIHRpY2s7XG4gIGRpZmZTaXh0ZWVudGggPSB0YXJnZXRTaXh0ZWVudGggLSBzaXh0ZWVudGg7XG4gIGRpZmZCZWF0cyA9IHRhcmdldEJlYXQgLSBiZWF0O1xuICBkaWZmQmFycyA9IHRhcmdldEJhciAtIGJhcjsgLy9iYXIgaXMgYWx3YXlzIGxlc3MgdGhlbiBvciBlcXVhbCB0byB0YXJnZXRCYXIsIHNvIGRpZmZCYXJzIGlzIGFsd2F5cyA+PSAwXG5cbiAgLy9jb25zb2xlLmxvZygnZGlmZicsZGlmZkJhcnMsZGlmZkJlYXRzLGRpZmZTaXh0ZWVudGgsZGlmZlRpY2spO1xuICAvL2NvbnNvbGUubG9nKCdtaWxsaXMnLG1pbGxpcyx0aWNrc1BlckJhcix0aWNrc1BlckJlYXQsdGlja3NQZXJTaXh0ZWVudGgsbWlsbGlzUGVyVGljayk7XG5cbiAgLy8gY29udmVydCBkaWZmZXJlbmNlcyB0byBtaWxsaXNlY29uZHMgYW5kIHRpY2tzXG4gIGRpZmZNaWxsaXMgPSAoZGlmZkJhcnMgKiB0aWNrc1BlckJhcikgKiBtaWxsaXNQZXJUaWNrO1xuICBkaWZmTWlsbGlzICs9IChkaWZmQmVhdHMgKiB0aWNrc1BlckJlYXQpICogbWlsbGlzUGVyVGljaztcbiAgZGlmZk1pbGxpcyArPSAoZGlmZlNpeHRlZW50aCAqIHRpY2tzUGVyU2l4dGVlbnRoKSAqIG1pbGxpc1BlclRpY2s7XG4gIGRpZmZNaWxsaXMgKz0gZGlmZlRpY2sgKiBtaWxsaXNQZXJUaWNrO1xuICBkaWZmVGlja3MgPSBkaWZmTWlsbGlzIC8gbWlsbGlzUGVyVGljaztcbiAgLy9jb25zb2xlLmxvZyhkaWZmQmFycywgdGlja3NQZXJCYXIsIG1pbGxpc1BlclRpY2ssIGRpZmZNaWxsaXMsIGRpZmZUaWNrcyk7XG5cbiAgLy8gc2V0IGFsbCBjdXJyZW50IHBvc2l0aW9uIGRhdGFcbiAgYmFyID0gdGFyZ2V0QmFyO1xuICBiZWF0ID0gdGFyZ2V0QmVhdDtcbiAgc2l4dGVlbnRoID0gdGFyZ2V0U2l4dGVlbnRoO1xuICB0aWNrID0gdGFyZ2V0VGljaztcbiAgLy9jb25zb2xlLmxvZyh0aWNrLCB0YXJnZXRUaWNrKVxuXG4gIG1pbGxpcyArPSBkaWZmTWlsbGlzO1xuICAvL2NvbnNvbGUubG9nKHRhcmdldEJhciwgdGFyZ2V0QmVhdCwgdGFyZ2V0U2l4dGVlbnRoLCB0YXJnZXRUaWNrLCAnIC0+ICcsIG1pbGxpcyk7XG4gIHRpY2tzICs9IGRpZmZUaWNrcztcblxuICAvL2NvbnNvbGUudGltZUVuZCgnZnJvbUJhcnMnKTtcbn1cblxuXG5mdW5jdGlvbiBjYWxjdWxhdGVCYXJzQW5kQmVhdHMoKXtcbiAgLy8gc3ByZWFkIHRoZSBkaWZmZXJlbmNlIGluIHRpY2sgb3ZlciBiYXJzLCBiZWF0cyBhbmQgc2l4dGVlbnRoXG4gIGxldCB0bXAgPSByb3VuZChkaWZmVGlja3MpO1xuICB3aGlsZSh0bXAgPj0gdGlja3NQZXJTaXh0ZWVudGgpe1xuICAgIHNpeHRlZW50aCsrO1xuICAgIHRtcCAtPSB0aWNrc1BlclNpeHRlZW50aDtcbiAgICB3aGlsZShzaXh0ZWVudGggPiBudW1TaXh0ZWVudGgpe1xuICAgICAgc2l4dGVlbnRoIC09IG51bVNpeHRlZW50aDtcbiAgICAgIGJlYXQrKztcbiAgICAgIHdoaWxlKGJlYXQgPiBub21pbmF0b3Ipe1xuICAgICAgICBiZWF0IC09IG5vbWluYXRvcjtcbiAgICAgICAgYmFyKys7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHRpY2sgPSByb3VuZCh0bXApO1xufVxuXG5cbi8vIHN0b3JlIHByb3BlcnRpZXMgb2YgZXZlbnQgaW4gbG9jYWwgc2NvcGVcbmZ1bmN0aW9uIGdldERhdGFGcm9tRXZlbnQoZXZlbnQpe1xuXG4gIGJwbSA9IGV2ZW50LmJwbTtcbiAgbm9taW5hdG9yID0gZXZlbnQubm9taW5hdG9yO1xuICBkZW5vbWluYXRvciA9IGV2ZW50LmRlbm9taW5hdG9yO1xuXG4gIHRpY2tzUGVyQmFyID0gZXZlbnQudGlja3NQZXJCYXI7XG4gIHRpY2tzUGVyQmVhdCA9IGV2ZW50LnRpY2tzUGVyQmVhdDtcbiAgdGlja3NQZXJTaXh0ZWVudGggPSBldmVudC50aWNrc1BlclNpeHRlZW50aDtcbiAgbnVtU2l4dGVlbnRoID0gZXZlbnQubnVtU2l4dGVlbnRoO1xuICBtaWxsaXNQZXJUaWNrID0gZXZlbnQubWlsbGlzUGVyVGljaztcbiAgc2Vjb25kc1BlclRpY2sgPSBldmVudC5zZWNvbmRzUGVyVGljaztcblxuICBiYXIgPSBldmVudC5iYXI7XG4gIGJlYXQgPSBldmVudC5iZWF0O1xuICBzaXh0ZWVudGggPSBldmVudC5zaXh0ZWVudGg7XG4gIHRpY2sgPSBldmVudC50aWNrO1xuXG4gIHRpY2tzID0gZXZlbnQudGlja3M7XG4gIG1pbGxpcyA9IGV2ZW50Lm1pbGxpcztcblxuICAvL2NvbnNvbGUubG9nKGJwbSwgZXZlbnQudHlwZSk7XG4gIC8vY29uc29sZS5sb2coJ3RpY2tzJywgdGlja3MsICdtaWxsaXMnLCBtaWxsaXMsICdiYXInLCBiYXIpO1xufVxuXG5cbmZ1bmN0aW9uIGdldFBvc2l0aW9uRGF0YShzb25nKXtcbiAgbGV0IHRpbWVEYXRhLFxuICAgIHBvc2l0aW9uRGF0YSA9IHt9O1xuXG4gIHN3aXRjaChyZXR1cm5UeXBlKXtcblxuICAgIGNhc2UgJ21pbGxpcyc6XG4gICAgICAvL3Bvc2l0aW9uRGF0YS5taWxsaXMgPSBtaWxsaXM7XG4gICAgICBwb3NpdGlvbkRhdGEubWlsbGlzID0gcm91bmQobWlsbGlzICogMTAwMCkgLyAxMDAwO1xuICAgICAgcG9zaXRpb25EYXRhLm1pbGxpc1JvdW5kZWQgPSByb3VuZChtaWxsaXMpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICd0aWNrcyc6XG4gICAgICAvL3Bvc2l0aW9uRGF0YS50aWNrcyA9IHRpY2tzO1xuICAgICAgcG9zaXRpb25EYXRhLnRpY2tzID0gcm91bmQodGlja3MpO1xuICAgICAgLy9wb3NpdGlvbkRhdGEudGlja3NVbnJvdW5kZWQgPSB0aWNrcztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYmFyc2JlYXRzJzpcbiAgICBjYXNlICdiYXJzYW5kYmVhdHMnOlxuICAgICAgcG9zaXRpb25EYXRhLmJhciA9IGJhcjtcbiAgICAgIHBvc2l0aW9uRGF0YS5iZWF0ID0gYmVhdDtcbiAgICAgIHBvc2l0aW9uRGF0YS5zaXh0ZWVudGggPSBzaXh0ZWVudGg7XG4gICAgICBwb3NpdGlvbkRhdGEudGljayA9IHRpY2s7XG4gICAgICAvL3Bvc2l0aW9uRGF0YS5iYXJzQXNTdHJpbmcgPSAoYmFyICsgMSkgKyAnOicgKyAoYmVhdCArIDEpICsgJzonICsgKHNpeHRlZW50aCArIDEpICsgJzonICsgdGlja0FzU3RyaW5nO1xuICAgICAgcG9zaXRpb25EYXRhLmJhcnNBc1N0cmluZyA9IGJhciArICc6JyArIGJlYXQgKyAnOicgKyBzaXh0ZWVudGggKyAnOicgKyBnZXRUaWNrQXNTdHJpbmcodGljayk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3RpbWUnOlxuICAgICAgdGltZURhdGEgPSBnZXROaWNlVGltZShtaWxsaXMpO1xuICAgICAgcG9zaXRpb25EYXRhLmhvdXIgPSB0aW1lRGF0YS5ob3VyO1xuICAgICAgcG9zaXRpb25EYXRhLm1pbnV0ZSA9IHRpbWVEYXRhLm1pbnV0ZTtcbiAgICAgIHBvc2l0aW9uRGF0YS5zZWNvbmQgPSB0aW1lRGF0YS5zZWNvbmQ7XG4gICAgICBwb3NpdGlvbkRhdGEubWlsbGlzZWNvbmQgPSB0aW1lRGF0YS5taWxsaXNlY29uZDtcbiAgICAgIHBvc2l0aW9uRGF0YS50aW1lQXNTdHJpbmcgPSB0aW1lRGF0YS50aW1lQXNTdHJpbmc7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2FsbCc6XG4gICAgICAvLyBtaWxsaXNcbiAgICAgIC8vcG9zaXRpb25EYXRhLm1pbGxpcyA9IG1pbGxpcztcbiAgICAgIHBvc2l0aW9uRGF0YS5taWxsaXMgPSByb3VuZChtaWxsaXMgKiAxMDAwKSAvIDEwMDA7XG4gICAgICBwb3NpdGlvbkRhdGEubWlsbGlzUm91bmRlZCA9IHJvdW5kKG1pbGxpcyk7XG5cbiAgICAgIC8vIHRpY2tzXG4gICAgICAvL3Bvc2l0aW9uRGF0YS50aWNrcyA9IHRpY2tzO1xuICAgICAgcG9zaXRpb25EYXRhLnRpY2tzID0gcm91bmQodGlja3MpO1xuICAgICAgLy9wb3NpdGlvbkRhdGEudGlja3NVbnJvdW5kZWQgPSB0aWNrcztcblxuICAgICAgLy8gYmFyc2JlYXRzXG4gICAgICBwb3NpdGlvbkRhdGEuYmFyID0gYmFyO1xuICAgICAgcG9zaXRpb25EYXRhLmJlYXQgPSBiZWF0O1xuICAgICAgcG9zaXRpb25EYXRhLnNpeHRlZW50aCA9IHNpeHRlZW50aDtcbiAgICAgIHBvc2l0aW9uRGF0YS50aWNrID0gdGljaztcbiAgICAgIC8vcG9zaXRpb25EYXRhLmJhcnNBc1N0cmluZyA9IChiYXIgKyAxKSArICc6JyArIChiZWF0ICsgMSkgKyAnOicgKyAoc2l4dGVlbnRoICsgMSkgKyAnOicgKyB0aWNrQXNTdHJpbmc7XG4gICAgICBwb3NpdGlvbkRhdGEuYmFyc0FzU3RyaW5nID0gYmFyICsgJzonICsgYmVhdCArICc6JyArIHNpeHRlZW50aCArICc6JyArIGdldFRpY2tBc1N0cmluZyh0aWNrKTtcblxuICAgICAgLy8gdGltZVxuICAgICAgdGltZURhdGEgPSBnZXROaWNlVGltZShtaWxsaXMpO1xuICAgICAgcG9zaXRpb25EYXRhLmhvdXIgPSB0aW1lRGF0YS5ob3VyO1xuICAgICAgcG9zaXRpb25EYXRhLm1pbnV0ZSA9IHRpbWVEYXRhLm1pbnV0ZTtcbiAgICAgIHBvc2l0aW9uRGF0YS5zZWNvbmQgPSB0aW1lRGF0YS5zZWNvbmQ7XG4gICAgICBwb3NpdGlvbkRhdGEubWlsbGlzZWNvbmQgPSB0aW1lRGF0YS5taWxsaXNlY29uZDtcbiAgICAgIHBvc2l0aW9uRGF0YS50aW1lQXNTdHJpbmcgPSB0aW1lRGF0YS50aW1lQXNTdHJpbmc7XG5cbiAgICAgIC8vIGV4dHJhIGRhdGFcbiAgICAgIHBvc2l0aW9uRGF0YS5icG0gPSByb3VuZChicG0gKiBzb25nLnBsYXliYWNrU3BlZWQsIDMpO1xuICAgICAgcG9zaXRpb25EYXRhLm5vbWluYXRvciA9IG5vbWluYXRvcjtcbiAgICAgIHBvc2l0aW9uRGF0YS5kZW5vbWluYXRvciA9IGRlbm9taW5hdG9yO1xuXG4gICAgICBwb3NpdGlvbkRhdGEudGlja3NQZXJCYXIgPSB0aWNrc1BlckJhcjtcbiAgICAgIHBvc2l0aW9uRGF0YS50aWNrc1BlckJlYXQgPSB0aWNrc1BlckJlYXQ7XG4gICAgICBwb3NpdGlvbkRhdGEudGlja3NQZXJTaXh0ZWVudGggPSB0aWNrc1BlclNpeHRlZW50aDtcblxuICAgICAgcG9zaXRpb25EYXRhLm51bVNpeHRlZW50aCA9IG51bVNpeHRlZW50aDtcbiAgICAgIHBvc2l0aW9uRGF0YS5taWxsaXNQZXJUaWNrID0gbWlsbGlzUGVyVGljaztcbiAgICAgIHBvc2l0aW9uRGF0YS5zZWNvbmRzUGVyVGljayA9IHNlY29uZHNQZXJUaWNrO1xuXG4gICAgICAvLyB1c2UgdGlja3MgdG8gbWFrZSB0ZW1wbyBjaGFuZ2VzIHZpc2libGUgYnkgYSBmYXN0ZXIgbW92aW5nIHBsYXloZWFkXG4gICAgICBwb3NpdGlvbkRhdGEucGVyY2VudGFnZSA9IHRpY2tzIC8gc29uZy5fZHVyYXRpb25UaWNrcztcbiAgICAgIC8vcG9zaXRpb25EYXRhLnBlcmNlbnRhZ2UgPSBtaWxsaXMgLyBzb25nLmR1cmF0aW9uTWlsbGlzO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBudWxsXG4gIH1cblxuICByZXR1cm4gcG9zaXRpb25EYXRhXG59XG5cblxuZnVuY3Rpb24gZ2V0VGlja0FzU3RyaW5nKHQpe1xuICBpZih0ID09PSAwKXtcbiAgICB0ID0gJzAwMCdcbiAgfWVsc2UgaWYodCA8IDEwKXtcbiAgICB0ID0gJzAwJyArIHRcbiAgfWVsc2UgaWYodCA8IDEwMCl7XG4gICAgdCA9ICcwJyArIHRcbiAgfVxuICByZXR1cm4gdFxufVxuXG5cbi8vIHVzZWQgYnkgcGxheWhlYWRcbmV4cG9ydCBmdW5jdGlvbiBnZXRQb3NpdGlvbjIoc29uZywgdW5pdCwgdGFyZ2V0LCB0eXBlLCBldmVudCl7XG4gIGlmKHVuaXQgPT09ICdtaWxsaXMnKXtcbiAgICBmcm9tTWlsbGlzKHNvbmcsIHRhcmdldCwgZXZlbnQpO1xuICB9ZWxzZSBpZih1bml0ID09PSAndGlja3MnKXtcbiAgICBmcm9tVGlja3Moc29uZywgdGFyZ2V0LCBldmVudCk7XG4gIH1cbiAgaWYodHlwZSA9PT0gJ2FsbCcpe1xuICAgIGNhbGN1bGF0ZUJhcnNBbmRCZWF0cygpO1xuICB9XG4gIHJldHVybiBnZXRQb3NpdGlvbkRhdGEoc29uZyk7XG59XG5cblxuLy8gaW1wcm92ZWQgdmVyc2lvbiBvZiBnZXRQb3NpdGlvblxuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZVBvc2l0aW9uKHNvbmcsIHNldHRpbmdzKXtcbiAgbGV0IHtcbiAgICB0eXBlLCAvLyBhbnkgb2YgYmFyc2FuZGJlYXRzIGJhcnNiZWF0cyB0aW1lIG1pbGxpcyB0aWNrcyBwZXJjIHBlcmNlbnRhZ2VcbiAgICB0YXJnZXQsIC8vIGlmIHR5cGUgaXMgYmFyc2JlYXRzIG9yIHRpbWUsIHRhcmdldCBtdXN0IGJlIGFuIGFycmF5LCBlbHNlIGlmIG11c3QgYmUgYSBudW1iZXJcbiAgICByZXN1bHQ6IHJlc3VsdCA9ICdhbGwnLCAvLyBhbnkgb2YgYmFyc2FuZGJlYXRzIGJhcnNiZWF0cyB0aW1lIG1pbGxpcyB0aWNrcyBhbGxcbiAgICBiZW9zOiBiZW9zID0gdHJ1ZSxcbiAgICBzbmFwOiBzbmFwID0gLTFcbiAgfSA9IHNldHRpbmdzXG5cbiAgaWYoc3VwcG9ydGVkUmV0dXJuVHlwZXMuaW5kZXhPZihyZXN1bHQpID09PSAtMSl7XG4gICAgY29uc29sZS53YXJuKGB1bnN1cHBvcnRlZCByZXR1cm4gdHlwZSwgJ2FsbCcgdXNlZCBpbnN0ZWFkIG9mICcke3Jlc3VsdH0nYClcbiAgICByZXN1bHQgPSAnYWxsJ1xuICB9XG5cbiAgcmV0dXJuVHlwZSA9IHJlc3VsdFxuICBiZXlvbmRFbmRPZlNvbmcgPSBiZW9zXG5cbiAgaWYoc3VwcG9ydGVkVHlwZXMuaW5kZXhPZih0eXBlKSA9PT0gLTEpe1xuICAgIGNvbnNvbGUuZXJyb3IoYHVuc3VwcG9ydGVkIHR5cGUgJHt0eXBlfWApXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuXG4gIHN3aXRjaCh0eXBlKXtcblxuICAgIGNhc2UgJ2JhcnNiZWF0cyc6XG4gICAgY2FzZSAnYmFyc2FuZGJlYXRzJzpcbiAgICAgIGxldCBbdGFyZ2V0YmFyID0gMSwgdGFyZ2V0YmVhdCA9IDEsIHRhcmdldHNpeHRlZW50aCA9IDEsIHRhcmdldHRpY2sgPSAwXSA9IHRhcmdldFxuICAgICAgLy9jb25zb2xlLmxvZyh0YXJnZXRiYXIsIHRhcmdldGJlYXQsIHRhcmdldHNpeHRlZW50aCwgdGFyZ2V0dGljaylcbiAgICAgIGZyb21CYXJzKHNvbmcsIHRhcmdldGJhciwgdGFyZ2V0YmVhdCwgdGFyZ2V0c2l4dGVlbnRoLCB0YXJnZXR0aWNrKVxuICAgICAgcmV0dXJuIGdldFBvc2l0aW9uRGF0YShzb25nKVxuXG4gICAgY2FzZSAndGltZSc6XG4gICAgICAvLyBjYWxjdWxhdGUgbWlsbGlzIG91dCBvZiB0aW1lIGFycmF5OiBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzXG4gICAgICBsZXQgW3RhcmdldGhvdXIgPSAwLCB0YXJnZXRtaW51dGUgPSAwLCB0YXJnZXRzZWNvbmQgPSAwLCB0YXJnZXRtaWxsaXNlY29uZCA9IDBdID0gdGFyZ2V0XG4gICAgICBsZXQgbWlsbGlzID0gMFxuICAgICAgbWlsbGlzICs9IHRhcmdldGhvdXIgKiA2MCAqIDYwICogMTAwMCAvL2hvdXJzXG4gICAgICBtaWxsaXMgKz0gdGFyZ2V0bWludXRlICogNjAgKiAxMDAwIC8vbWludXRlc1xuICAgICAgbWlsbGlzICs9IHRhcmdldHNlY29uZCAqIDEwMDAgLy9zZWNvbmRzXG4gICAgICBtaWxsaXMgKz0gdGFyZ2V0bWlsbGlzZWNvbmQgLy9taWxsaXNlY29uZHNcblxuICAgICAgZnJvbU1pbGxpcyhzb25nLCBtaWxsaXMpXG4gICAgICBjYWxjdWxhdGVCYXJzQW5kQmVhdHMoKVxuICAgICAgcmV0dXJuIGdldFBvc2l0aW9uRGF0YShzb25nKVxuXG4gICAgY2FzZSAnbWlsbGlzJzpcbiAgICAgIGZyb21NaWxsaXMoc29uZywgdGFyZ2V0KVxuICAgICAgY2FsY3VsYXRlQmFyc0FuZEJlYXRzKClcbiAgICAgIHJldHVybiBnZXRQb3NpdGlvbkRhdGEoc29uZylcblxuICAgIGNhc2UgJ3RpY2tzJzpcbiAgICAgIGZyb21UaWNrcyhzb25nLCB0YXJnZXQpXG4gICAgICBjYWxjdWxhdGVCYXJzQW5kQmVhdHMoKVxuICAgICAgcmV0dXJuIGdldFBvc2l0aW9uRGF0YShzb25nKVxuXG4gICAgY2FzZSAncGVyYyc6XG4gICAgY2FzZSAncGVyY2VudGFnZSc6XG5cbiAgICAgIC8vbWlsbGlzID0gcG9zaXRpb25bMV0gKiBzb25nLmR1cmF0aW9uTWlsbGlzO1xuICAgICAgLy9mcm9tTWlsbGlzKHNvbmcsIG1pbGxpcyk7XG4gICAgICAvL2NvbnNvbGUubG9nKG1pbGxpcyk7XG5cbiAgICAgIHRpY2tzID0gdGFyZ2V0ICogc29uZy5fZHVyYXRpb25UaWNrcyAvLyB0YXJnZXQgbXVzdCBiZSBpbiB0aWNrcyFcbiAgICAgIC8vY29uc29sZS5sb2codGlja3MsIHNvbmcuX2R1cmF0aW9uVGlja3MpXG4gICAgICBpZihzbmFwICE9PSAtMSl7XG4gICAgICAgIHRpY2tzID0gZmxvb3IodGlja3MgLyBzbmFwKSAqIHNuYXA7XG4gICAgICAgIC8vZnJvbVRpY2tzKHNvbmcsIHRpY2tzKTtcbiAgICAgICAgLy9jb25zb2xlLmxvZyh0aWNrcyk7XG4gICAgICB9XG4gICAgICBmcm9tVGlja3Moc29uZywgdGlja3MpXG4gICAgICBjYWxjdWxhdGVCYXJzQW5kQmVhdHMoKVxuICAgICAgbGV0IHRtcCA9IGdldFBvc2l0aW9uRGF0YShzb25nKVxuICAgICAgLy9jb25zb2xlLmxvZygnZGlmZicsIHBvc2l0aW9uWzFdIC0gdG1wLnBlcmNlbnRhZ2UpO1xuICAgICAgcmV0dXJuIHRtcFxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbi8qXG5cbi8vQHBhcmFtOiAnbWlsbGlzJywgMTAwMCwgW3RydWVdXG4vL0BwYXJhbTogJ3RpY2tzJywgMTAwMCwgW3RydWVdXG4vL0BwYXJhbTogJ2JhcnNhbmRiZWF0cycsIDEsIFsnYWxsJywgdHJ1ZV1cbi8vQHBhcmFtOiAnYmFyc2FuZGJlYXRzJywgNjAsIDQsIDMsIDEyMCwgWydhbGwnLCB0cnVlXVxuLy9AcGFyYW06ICdiYXJzYW5kYmVhdHMnLCA2MCwgNCwgMywgMTIwLCBbdHJ1ZSwgJ2FsbCddXG5cbmZ1bmN0aW9uIGNoZWNrUG9zaXRpb24odHlwZSwgYXJncywgcmV0dXJuVHlwZSA9ICdhbGwnKXtcbiAgYmV5b25kRW5kT2ZTb25nID0gdHJ1ZTtcbiAgY29uc29sZS5sb2coJy0tLS0+IGNoZWNrUG9zaXRpb246JywgYXJncywgdHlwZVN0cmluZyhhcmdzKSk7XG5cbiAgaWYodHlwZVN0cmluZyhhcmdzKSA9PT0gJ2FycmF5Jyl7XG4gICAgbGV0XG4gICAgICBudW1BcmdzID0gYXJncy5sZW5ndGgsXG4gICAgICBwb3NpdGlvbixcbiAgICAgIGksIGEsIHBvc2l0aW9uTGVuZ3RoO1xuXG4gICAgdHlwZSA9IGFyZ3NbMF07XG5cbiAgICAvLyBzdXBwb3J0IGZvciBbWydtaWxsaXMnLCAzMDAwXV1cbiAgICBpZih0eXBlU3RyaW5nKGFyZ3NbMF0pID09PSAnYXJyYXknKXtcbiAgICAgIC8vY29uc29sZS53YXJuKCd0aGlzIHNob3VsZG5cXCd0IGhhcHBlbiEnKTtcbiAgICAgIGFyZ3MgPSBhcmdzWzBdO1xuICAgICAgdHlwZSA9IGFyZ3NbMF07XG4gICAgICBudW1BcmdzID0gYXJncy5sZW5ndGg7XG4gICAgfVxuXG4gICAgcG9zaXRpb24gPSBbdHlwZV07XG5cbiAgICBjb25zb2xlLmxvZygnY2hlY2sgcG9zaXRpb24nLCBhcmdzLCBudW1BcmdzLCBzdXBwb3J0ZWRUeXBlcy5pbmRleE9mKHR5cGUpKTtcblxuICAgIC8vY29uc29sZS5sb2coJ2FyZycsIDAsICctPicsIHR5cGUpO1xuXG4gICAgaWYoc3VwcG9ydGVkVHlwZXMuaW5kZXhPZih0eXBlKSAhPT0gLTEpe1xuICAgICAgZm9yKGkgPSAxOyBpIDwgbnVtQXJnczsgaSsrKXtcbiAgICAgICAgYSA9IGFyZ3NbaV07XG4gICAgICAgIC8vY29uc29sZS5sb2coJ2FyZycsIGksICctPicsIGEpO1xuICAgICAgICBpZihhID09PSB0cnVlIHx8IGEgPT09IGZhbHNlKXtcbiAgICAgICAgICBiZXlvbmRFbmRPZlNvbmcgPSBhO1xuICAgICAgICB9ZWxzZSBpZihpc05hTihhKSl7XG4gICAgICAgICAgaWYoc3VwcG9ydGVkUmV0dXJuVHlwZXMuaW5kZXhPZihhKSAhPT0gLTEpe1xuICAgICAgICAgICAgcmV0dXJuVHlwZSA9IGE7XG4gICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9ZWxzZSB7XG4gICAgICAgICAgcG9zaXRpb24ucHVzaChhKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy9jaGVjayBudW1iZXIgb2YgYXJndW1lbnRzIC0+IGVpdGhlciAxIG51bWJlciBvciA0IG51bWJlcnMgaW4gcG9zaXRpb24sIGUuZy4gWydiYXJzYmVhdHMnLCAxXSBvciBbJ2JhcnNiZWF0cycsIDEsIDEsIDEsIDBdLFxuICAgICAgLy8gb3IgWydwZXJjJywgMC41NiwgbnVtYmVyT2ZUaWNrc1RvU25hcFRvXVxuICAgICAgcG9zaXRpb25MZW5ndGggPSBwb3NpdGlvbi5sZW5ndGg7XG4gICAgICBpZihwb3NpdGlvbkxlbmd0aCAhPT0gMiAmJiBwb3NpdGlvbkxlbmd0aCAhPT0gMyAmJiBwb3NpdGlvbkxlbmd0aCAhPT0gNSl7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vY29uc29sZS5sb2cocG9zaXRpb24sIHJldHVyblR5cGUsIGJleW9uZEVuZE9mU29uZyk7XG4gICAgICAvL2NvbnNvbGUubG9nKCctLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0nKVxuICAgICAgcmV0dXJuIHBvc2l0aW9uO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFBvc2l0aW9uKHNvbmcsIHR5cGUsIGFyZ3Mpe1xuICAvL2NvbnNvbGUubG9nKCdnZXRQb3NpdGlvbicsIGFyZ3MpO1xuXG4gIGlmKHR5cGVvZiBhcmdzID09PSAndW5kZWZpbmVkJyl7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1pbGxpczogMFxuICAgIH1cbiAgfVxuXG4gIGxldCBwb3NpdGlvbiA9IGNoZWNrUG9zaXRpb24odHlwZSwgYXJncyksXG4gICAgbWlsbGlzLCB0bXAsIHNuYXA7XG5cblxuICBpZihwb3NpdGlvbiA9PT0gZmFsc2Upe1xuICAgIGVycm9yKCd3cm9uZyBwb3NpdGlvbiBkYXRhJyk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc3dpdGNoKHR5cGUpe1xuXG4gICAgY2FzZSAnYmFyc2JlYXRzJzpcbiAgICBjYXNlICdiYXJzYW5kYmVhdHMnOlxuICAgICAgZnJvbUJhcnMoc29uZywgcG9zaXRpb25bMV0sIHBvc2l0aW9uWzJdLCBwb3NpdGlvblszXSwgcG9zaXRpb25bNF0pO1xuICAgICAgcmV0dXJuIGdldFBvc2l0aW9uRGF0YShzb25nKTtcblxuICAgIGNhc2UgJ3RpbWUnOlxuICAgICAgLy8gY2FsY3VsYXRlIG1pbGxpcyBvdXQgb2YgdGltZSBhcnJheTogaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc1xuICAgICAgbWlsbGlzID0gMDtcbiAgICAgIHRtcCA9IHBvc2l0aW9uWzFdIHx8IDA7XG4gICAgICBtaWxsaXMgKz0gdG1wICogNjAgKiA2MCAqIDEwMDA7IC8vaG91cnNcbiAgICAgIHRtcCA9IHBvc2l0aW9uWzJdIHx8IDA7XG4gICAgICBtaWxsaXMgKz0gdG1wICogNjAgKiAxMDAwOyAvL21pbnV0ZXNcbiAgICAgIHRtcCA9IHBvc2l0aW9uWzNdIHx8IDA7XG4gICAgICBtaWxsaXMgKz0gdG1wICogMTAwMDsgLy9zZWNvbmRzXG4gICAgICB0bXAgPSBwb3NpdGlvbls0XSB8fCAwO1xuICAgICAgbWlsbGlzICs9IHRtcDsgLy9taWxsaXNlY29uZHNcblxuICAgICAgZnJvbU1pbGxpcyhzb25nLCBtaWxsaXMpO1xuICAgICAgY2FsY3VsYXRlQmFyc0FuZEJlYXRzKCk7XG4gICAgICByZXR1cm4gZ2V0UG9zaXRpb25EYXRhKHNvbmcpO1xuXG4gICAgY2FzZSAnbWlsbGlzJzpcbiAgICAgIGZyb21NaWxsaXMoc29uZywgcG9zaXRpb25bMV0pO1xuICAgICAgY2FsY3VsYXRlQmFyc0FuZEJlYXRzKCk7XG4gICAgICByZXR1cm4gZ2V0UG9zaXRpb25EYXRhKHNvbmcpO1xuXG4gICAgY2FzZSAndGlja3MnOlxuICAgICAgZnJvbVRpY2tzKHNvbmcsIHBvc2l0aW9uWzFdKTtcbiAgICAgIGNhbGN1bGF0ZUJhcnNBbmRCZWF0cygpO1xuICAgICAgcmV0dXJuIGdldFBvc2l0aW9uRGF0YShzb25nKTtcblxuICAgIGNhc2UgJ3BlcmMnOlxuICAgIGNhc2UgJ3BlcmNlbnRhZ2UnOlxuICAgICAgc25hcCA9IHBvc2l0aW9uWzJdO1xuXG4gICAgICAvL21pbGxpcyA9IHBvc2l0aW9uWzFdICogc29uZy5kdXJhdGlvbk1pbGxpcztcbiAgICAgIC8vZnJvbU1pbGxpcyhzb25nLCBtaWxsaXMpO1xuICAgICAgLy9jb25zb2xlLmxvZyhtaWxsaXMpO1xuXG4gICAgICB0aWNrcyA9IHBvc2l0aW9uWzFdICogc29uZy5kdXJhdGlvblRpY2tzO1xuICAgICAgaWYoc25hcCAhPT0gdW5kZWZpbmVkKXtcbiAgICAgICAgdGlja3MgPSBmbG9vcih0aWNrcy9zbmFwKSAqIHNuYXA7XG4gICAgICAgIC8vZnJvbVRpY2tzKHNvbmcsIHRpY2tzKTtcbiAgICAgICAgLy9jb25zb2xlLmxvZyh0aWNrcyk7XG4gICAgICB9XG4gICAgICBmcm9tVGlja3Moc29uZywgdGlja3MpO1xuICAgICAgY2FsY3VsYXRlQmFyc0FuZEJlYXRzKCk7XG4gICAgICB0bXAgPSBnZXRQb3NpdGlvbkRhdGEoc29uZyk7XG4gICAgICAvL2NvbnNvbGUubG9nKCdkaWZmJywgcG9zaXRpb25bMV0gLSB0bXAucGVyY2VudGFnZSk7XG4gICAgICByZXR1cm4gdG1wO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuKi9cblxuIiwiaW1wb3J0IHtcbiAgTUlESUV2ZW50XG59IGZyb20gJy4vbWlkaV9ldmVudCdcblxuaW1wb3J0e1xuICBNSURJTm90ZSxcbn0gZnJvbSAnLi9taWRpX25vdGUnXG5cbmltcG9ydHtcbiAgUGFydCxcbn0gZnJvbSAnLi9wYXJ0J1xuXG5pbXBvcnR7XG4gIFRyYWNrLFxufSBmcm9tICcuL3RyYWNrJ1xuXG5pbXBvcnQge1xuICBJbnN0cnVtZW50LFxufSBmcm9tICcuL2luc3RydW1lbnQnXG5cbmltcG9ydCB7XG4gIFNvbmcsXG59IGZyb20gJy4vc29uZydcblxuaW1wb3J0IHtcbiAgcGFyc2VNSURJRmlsZVxufSBmcm9tICcuL21pZGlmaWxlJ1xuXG5pbXBvcnQge1xuICBpbml0LFxufSBmcm9tICcuL2luaXQnXG5cbmltcG9ydCB7XG4gIGNvbnRleHQsXG4gIGdldE1hc3RlclZvbHVtZSxcbiAgc2V0TWFzdGVyVm9sdW1lLFxufSBmcm9tICcuL2luaXRfYXVkaW8nXG5cbmltcG9ydCB7XG4gIGdldE1JRElBY2Nlc3MsXG4gIGdldE1JRElJbnB1dHMsXG4gIGdldE1JRElPdXRwdXRzLFxuICBnZXRNSURJSW5wdXRJZHMsXG4gIGdldE1JRElPdXRwdXRJZHMsXG4gIGdldE1JRElJbnB1dHNCeUlkLFxuICBnZXRNSURJT3V0cHV0c0J5SWQsXG59IGZyb20gJy4vaW5pdF9taWRpJ1xuXG5pbXBvcnQge1xuICBwYXJzZVNhbXBsZXMsXG59IGZyb20gJy4vcGFyc2VfYXVkaW8nXG5cblxuY29uc3QgZ2V0QXVkaW9Db250ZXh0ID0gZnVuY3Rpb24oKXtcbiAgcmV0dXJuIGNvbnRleHRcbn1cblxuY29uc3QgcWFtYmkgPSB7XG4gIHZlcnNpb246ICcxLjAuMC1iZXRhMicsXG5cbiAgLy8gZnJvbSAuL3V0aWxcbiAgcGFyc2VTYW1wbGVzLFxuXG4gIC8vIGZyb20gLi9pbml0XG4gIGluaXQsXG5cbiAgLy8gZnJvbSAuL2luaXRfYXVkaW9cbiAgZ2V0QXVkaW9Db250ZXh0LFxuICBnZXRNYXN0ZXJWb2x1bWUsXG4gIHNldE1hc3RlclZvbHVtZSxcblxuICAvLyAuL2luaXRfbWlkaVxuICBnZXRNSURJQWNjZXNzLFxuICBnZXRNSURJSW5wdXRzLFxuICBnZXRNSURJT3V0cHV0cyxcbiAgZ2V0TUlESUlucHV0SWRzLFxuICBnZXRNSURJT3V0cHV0SWRzLFxuICBnZXRNSURJSW5wdXRzQnlJZCxcbiAgZ2V0TUlESU91dHB1dHNCeUlkLFxuXG4gIC8vIGZyb20gLi9taWRpX2V2ZW50XG4gIE1JRElFdmVudCxcblxuICAvLyBmcm9tIC4vbWlkaV9ub3RlXG4gIE1JRElOb3RlLFxuXG4gIC8vIGZyb20gLi9zb25nXG4gIFNvbmcsXG5cbiAgLy8gZnJvbSAuL3RyYWNrXG4gIFRyYWNrLFxuXG4gIC8vIGZyb20gLi9wYXJ0XG4gIFBhcnQsXG5cbiAgLy8gZnJvbSAuL2luc3RydW1lbnRcbiAgSW5zdHJ1bWVudCxcblxuICBwYXJzZU1JRElGaWxlLFxuXG4gIGxvZzogZnVuY3Rpb24oaWQpe1xuICAgIHN3aXRjaChpZCl7XG4gICAgICBjYXNlICdmdW5jdGlvbnMnOlxuICAgICAgICBjb25zb2xlLmxvZyhgZnVuY3Rpb25zOlxuICAgICAgICAgIGNyZWF0ZU1JRElFdmVudFxuICAgICAgICAgIG1vdmVNSURJRXZlbnRcbiAgICAgICAgICBtb3ZlTUlESUV2ZW50VG9cbiAgICAgICAgICBjcmVhdGVNSURJTm90ZVxuICAgICAgICAgIGNyZWF0ZVNvbmdcbiAgICAgICAgICBhZGRUcmFja3NcbiAgICAgICAgICBjcmVhdGVUcmFja1xuICAgICAgICAgIGFkZFBhcnRzXG4gICAgICAgICAgY3JlYXRlUGFydFxuICAgICAgICAgIGFkZE1JRElFdmVudHNcbiAgICAgICAgYClcbiAgICAgICAgYnJlYWtcbiAgICAgIGRlZmF1bHQ6XG4gICAgfVxuICB9LFxufVxuXG4vLyBzdGFuZGFyZCBNSURJIGV2ZW50c1xuLy9jb25zdCBNSURJID0ge31cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShxYW1iaSwgJ05PVEVfT0ZGJywge3ZhbHVlOiAweDgwfSk7IC8vMTI4XG5PYmplY3QuZGVmaW5lUHJvcGVydHkocWFtYmksICdOT1RFX09OJywge3ZhbHVlOiAweDkwfSk7IC8vMTQ0XG5PYmplY3QuZGVmaW5lUHJvcGVydHkocWFtYmksICdQT0xZX1BSRVNTVVJFJywge3ZhbHVlOiAweEEwfSk7IC8vMTYwXG5PYmplY3QuZGVmaW5lUHJvcGVydHkocWFtYmksICdDT05UUk9MX0NIQU5HRScsIHt2YWx1ZTogMHhCMH0pOyAvLzE3NlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHFhbWJpLCAnUFJPR1JBTV9DSEFOR0UnLCB7dmFsdWU6IDB4QzB9KTsgLy8xOTJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShxYW1iaSwgJ0NIQU5ORUxfUFJFU1NVUkUnLCB7dmFsdWU6IDB4RDB9KTsgLy8yMDhcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShxYW1iaSwgJ1BJVENIX0JFTkQnLCB7dmFsdWU6IDB4RTB9KTsgLy8yMjRcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShxYW1iaSwgJ1NZU1RFTV9FWENMVVNJVkUnLCB7dmFsdWU6IDB4RjB9KTsgLy8yNDBcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShxYW1iaSwgJ01JRElfVElNRUNPREUnLCB7dmFsdWU6IDI0MX0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KHFhbWJpLCAnU09OR19QT1NJVElPTicsIHt2YWx1ZTogMjQyfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkocWFtYmksICdTT05HX1NFTEVDVCcsIHt2YWx1ZTogMjQzfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkocWFtYmksICdUVU5FX1JFUVVFU1QnLCB7dmFsdWU6IDI0Nn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KHFhbWJpLCAnRU9YJywge3ZhbHVlOiAyNDd9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShxYW1iaSwgJ1RJTUlOR19DTE9DSycsIHt2YWx1ZTogMjQ4fSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkocWFtYmksICdTVEFSVCcsIHt2YWx1ZTogMjUwfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkocWFtYmksICdDT05USU5VRScsIHt2YWx1ZTogMjUxfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkocWFtYmksICdTVE9QJywge3ZhbHVlOiAyNTJ9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShxYW1iaSwgJ0FDVElWRV9TRU5TSU5HJywge3ZhbHVlOiAyNTR9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShxYW1iaSwgJ1NZU1RFTV9SRVNFVCcsIHt2YWx1ZTogMjU1fSk7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHFhbWJpLCAnVEVNUE8nLCB7dmFsdWU6IDB4NTF9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShxYW1iaSwgJ1RJTUVfU0lHTkFUVVJFJywge3ZhbHVlOiAweDU4fSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkocWFtYmksICdFTkRfT0ZfVFJBQ0snLCB7dmFsdWU6IDB4MkZ9KTtcblxuXG5leHBvcnQgZGVmYXVsdCBxYW1iaVxuXG5leHBvcnQge1xuICAvLyBmcm9tIC4vaW5pdFxuICBpbml0LFxuXG5cbiAgLy8gZnJvbSAuL2luaXRfYXVkaW9cbiAgZ2V0QXVkaW9Db250ZXh0LFxuICBnZXRNYXN0ZXJWb2x1bWUsXG4gIHNldE1hc3RlclZvbHVtZSxcblxuICAvLyAuL2luaXRfbWlkaVxuICBnZXRNSURJQWNjZXNzLFxuICBnZXRNSURJSW5wdXRzLFxuICBnZXRNSURJT3V0cHV0cyxcbiAgZ2V0TUlESUlucHV0SWRzLFxuICBnZXRNSURJT3V0cHV0SWRzLFxuICBnZXRNSURJSW5wdXRzQnlJZCxcbiAgZ2V0TUlESU91dHB1dHNCeUlkLFxuXG4gIC8vIGZyb20gLi91dGlsXG4gIHBhcnNlU2FtcGxlcyxcblxuICAvLyBmcm9tIC4vbWlkaV9ldmVudFxuICBNSURJRXZlbnQsXG5cbiAgLy8gZnJvbSAuL21pZGlfbm90ZVxuICBNSURJTm90ZSxcblxuICAvLyBmcm9tIC4vc29uZ1xuICBTb25nLFxuXG4gIC8vIGZyb20gLi90cmFja1xuICBUcmFjayxcblxuICAvLyBmcm9tIC4vcGFydFxuICBQYXJ0LFxuXG4gIC8vIGZyb20gLi9pbnN0cnVtZW50XG4gIEluc3RydW1lbnQsXG5cbi8vICBNSURJLFxuXG4gIHBhcnNlTUlESUZpbGUsXG59XG4iLCJpbXBvcnQge2NvbnRleHR9IGZyb20gJy4vaW5pdF9hdWRpby5qcydcbmltcG9ydCB7Z2V0RXF1YWxQb3dlckN1cnZlfSBmcm9tICcuL3V0aWwuanMnXG5cblxuY2xhc3MgU2FtcGxle1xuXG4gIGNvbnN0cnVjdG9yKHNhbXBsZURhdGEsIGV2ZW50KXtcbiAgICB0aGlzLmV2ZW50ID0gZXZlbnRcbiAgICB0aGlzLnNhbXBsZURhdGEgPSBzYW1wbGVEYXRhXG5cbiAgICBpZih0aGlzLnNhbXBsZURhdGEgPT09IC0xIHx8IHR5cGVvZiB0aGlzLnNhbXBsZURhdGEgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiB0aGlzLnNhbXBsZURhdGEuYnVmZmVyID09PSAndW5kZWZpbmVkJyl7XG4gICAgICBpZih0eXBlb2YgdGhpcy5zYW1wbGVEYXRhID09PSAndW5kZWZpbmVkJyl7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tTQU1QTEVdJywgZXZlbnQpXG4gICAgICB9XG4gICAgICAvLyBjcmVhdGUgc2ltcGxlIHN5bnRoIHNhbXBsZVxuICAgICAgdGhpcy5zb3VyY2UgPSBjb250ZXh0LmNyZWF0ZU9zY2lsbGF0b3IoKTtcbiAgICAgIHRoaXMuc291cmNlLnR5cGUgPSAnc2luZSc7XG4gICAgICB0aGlzLnNvdXJjZS5mcmVxdWVuY3kudmFsdWUgPSBldmVudC5mcmVxdWVuY3lcbiAgICB9ZWxzZXtcbiAgICAgIHRoaXMuc291cmNlID0gY29udGV4dC5jcmVhdGVCdWZmZXJTb3VyY2UoKVxuICAgICAgdGhpcy5zb3VyY2UuYnVmZmVyID0gc2FtcGxlRGF0YS5idWZmZXI7XG4gICAgICAvL2NvbnNvbGUubG9nKHRoaXMuc291cmNlLmJ1ZmZlcilcbiAgICB9XG4gICAgdGhpcy5vdXRwdXQgPSBjb250ZXh0LmNyZWF0ZUdhaW4oKVxuICAgIHRoaXMudm9sdW1lID0gZXZlbnQuZGF0YTIgLyAxMjdcbiAgICB0aGlzLm91dHB1dC5nYWluLnZhbHVlID0gdGhpcy52b2x1bWVcbiAgICB0aGlzLnNvdXJjZS5jb25uZWN0KHRoaXMub3V0cHV0KVxuICAgIC8vdGhpcy5vdXRwdXQuY29ubmVjdChjb250ZXh0LmRlc3RpbmF0aW9uKVxuICB9XG5cbiAgc3RhcnQodGltZSl7XG4gICAgLy9jb25zb2xlLmxvZyh0aGlzLnNvdXJjZSk7XG4gICAgdGhpcy5zb3VyY2Uuc3RhcnQodGltZSk7XG4gIH1cblxuICBzdG9wKHRpbWUsIGNiKXtcbiAgICBpZih0eXBlb2YgdGhpcy5zYW1wbGVEYXRhID09PSAndW5kZWZpbmVkJyl7XG4gICAgICBjb25zb2xlLmxvZyh0aGlzLnNvdXJjZSlcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1tTQU1QTEVdJywgZXZlbnQpXG4gICAgfVxuXG4gICAgbGV0IHtyZWxlYXNlRHVyYXRpb24sIHJlbGVhc2VFbnZlbG9wZSwgcmVsZWFzZUVudmVsb3BlQXJyYXl9ID0gdGhpcy5zYW1wbGVEYXRhXG4gICAgaWYocmVsZWFzZUR1cmF0aW9uICYmIHJlbGVhc2VFbnZlbG9wZSl7XG4gICAgICB0aGlzLnNvdXJjZS5zdG9wKHRpbWUgKyByZWxlYXNlRHVyYXRpb24pXG4gICAgICBmYWRlT3V0KHRoaXMub3V0cHV0LCB7XG4gICAgICAgIHJlbGVhc2VEdXJhdGlvbixcbiAgICAgICAgcmVsZWFzZUVudmVsb3BlLFxuICAgICAgICByZWxlYXNlRW52ZWxvcGVBcnJheSxcbiAgICAgIH0pXG4gICAgfWVsc2V7XG4gICAgICB0aGlzLnNvdXJjZS5zdG9wKHRpbWUpO1xuICAgIH1cblxuICAgIHRoaXMuc291cmNlLm9uZW5kZWQgPSBjYjtcbiAgfVxufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBmYWRlT3V0KGdhaW5Ob2RlLCBzZXR0aW5ncyl7XG4gIGxldCBub3cgPSBjb250ZXh0LmN1cnJlbnRUaW1lXG4gIGxldCB2YWx1ZXMsIGksIG1heGlcblxuICAvL2NvbnNvbGUubG9nKHNldHRpbmdzLnJlbGVhc2VFbnZlbG9wZSlcbiAgc3dpdGNoKHNldHRpbmdzLnJlbGVhc2VFbnZlbG9wZSl7XG5cbiAgICBjYXNlICdsaW5lYXInOlxuICAgICAgZ2Fpbk5vZGUuZ2Fpbi5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZShnYWluTm9kZS5nYWluLnZhbHVlLCBub3cpXG4gICAgICBnYWluTm9kZS5nYWluLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKDAsIG5vdyArIHNldHRpbmdzLnJlbGVhc2VEdXJhdGlvbilcbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlICdlcXVhbF9wb3dlcic6XG4gICAgICB2YWx1ZXMgPSBnZXRFcXVhbFBvd2VyQ3VydmUoMTAwLCAnZmFkZU91dCcsIGdhaW5Ob2RlLmdhaW4udmFsdWUpXG4gICAgICBnYWluTm9kZS5nYWluLnNldFZhbHVlQ3VydmVBdFRpbWUodmFsdWVzLCBub3csIHNldHRpbmdzLnJlbGVhc2VEdXJhdGlvbilcbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlICdhcnJheSc6XG4gICAgICBtYXhpID0gc2V0dGluZ3MucmVsZWFzZUVudmVsb3BlQXJyYXkubGVuZ3RoXG4gICAgICB2YWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KG1heGkpXG4gICAgICBmb3IoaSA9IDA7IGkgPCBtYXhpOyBpKyspe1xuICAgICAgICB2YWx1ZXNbaV0gPSBzZXR0aW5ncy5yZWxlYXNlRW52ZWxvcGVBcnJheVtpXSAqIGdhaW5Ob2RlLmdhaW4udmFsdWVcbiAgICAgIH1cbiAgICAgIGdhaW5Ob2RlLmdhaW4uc2V0VmFsdWVDdXJ2ZUF0VGltZSh2YWx1ZXMsIG5vdywgc2V0dGluZ3MucmVsZWFzZUR1cmF0aW9uKVxuICAgICAgYnJlYWtcblxuICAgIGRlZmF1bHQ6XG4gIH1cbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2FtcGxlKC4uLmFyZ3Mpe1xuICByZXR1cm4gbmV3IFNhbXBsZSguLi5hcmdzKVxufVxuXG5cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJlbXB0eU9nZ1wiOiBcIlQyZG5Vd0FDQUFBQUFBQUFBQUJkeGQ0WEFBQUFBRGFTMGpRQkhnRjJiM0ppYVhNQUFBQUFBVVNzQUFBQUFBQUFnTHNBQUFBQUFBQzRBVTluWjFNQUFBQUFBQUFBQUFBQVhjWGVGd0VBQUFBYVhLK1FEejMvLy8vLy8vLy8vLy8vLy8vL01nTjJiM0ppYVhNdEFBQUFXR2x3YUM1UGNtY2diR2xpVm05eVltbHpJRWtnTWpBeE1ERXhNREVnS0ZOamFHRjFabVZ1ZFdkblpYUXBBQUFBQUFFRmRtOXlZbWx6SDBKRFZnRUFBQUVBR0dOVUtVYVpVdEpLaVJsemxERkdtV0tTU29tbGhCWkNTSjF6RkZPcE9kZWNhNnk1dFNDRUVCcFRVQ2tGbVZLT1Vta1pZNUFwQlpsU0VFdEpKWFFTT2llZFl4QmJTY0hXbUd1TFFiWWNoQTJhVWt3cHhKUlNpa0lJR1ZPTUtjV1VVa3BDQnlWMERqcm1IRk9PU2loQnVKeHpxN1dXbG1PTHFYU1NTdWNrWkV4Q1NDbUZra29IcFZOT1FrZzFsdFpTS1IxelVsSnFRZWdnaEJCQ3RpQ0VEWUxRa0ZVQUFBRUF3RUFRR3JJS0FGQUFBQkNLb1JpS0FvU0dyQUlBTWdBQUJLQW9qdUlvamlNNWttTkpGaEFhc2dvQUFBSUFFQUFBd0hBVVNaRVV5YkVrUzlJc1M5TkVVVlY5MVRaVlZmWjFYZGQxWGRkMUlEUmtGUUFBQVFCQVNLZVpwUm9nd2d4a0dBZ05XUVVBSUFBQUFFWW93aEFEUWtOV0FRQUFBUUFBWWlnNWlDYTA1bnh6am9ObU9XZ3F4ZVowY0NMVjVrbHVLdWJtbkhQT09TZWJjOFk0NTV4emluSm1NV2dtdE9hY2N4S0RaaWxvSnJUbW5IT2V4T1pCYTZxMDVweHp4am1uZzNGR0dPZWNjNXEwNWtGcU50Ym1uSE1XdEtZNWFpN0Y1cHh6SXVYbVNXMHUxZWFjYzg0NTU1eHp6am5ubkhPcUY2ZHpjRTQ0NTV4em92Ym1XbTVDRitlY2N6NFpwM3R6UWpqbm5IUE9PZWVjYzg0NTU1eHpndENRVlFBQUVBQUFRUmcyaG5HbklFaWZvNEVZUllocHlLUUgzYVBESkdnTWNncXBSNk9qa1ZMcUlKUlV4a2twblNBMFpCVUFBQWdBQUNHRUZGSklJWVVVVWtnaGhSUlNpQ0dHR0dMSUthZWNnZ29xcWFTaWlqTEtMTFBNTXNzc3M4d3k2N0N6empyc01NUVFRd3l0dEJKTFRiWFZXR090dWVlY2F3N1NXbW10dGRaS0thV1VVa29wQ0ExWkJRQ0FBQUFRQ0Jsa2tFRkdJWVVVVW9naHBweHl5aW1vb0FKQ1ExWUJBSUFBQUFJQUFBQTh5WE5FUjNSRVIzUkVSM1JFUjNSRXgzTThSNVJFU1pSRVNiUk15OVJNVHhWVjFaVmRXOVpsM2ZadFlSZDIzZmQxMy9kMTQ5ZUZZVm1XWlZtV1pWbVdaVm1XWlZtV1pWbUMwSkJWQUFBSUFBQ0FFRUlJSVlVVVVrZ2hwUmhqekRIbm9KTlFRaUEwWkJVQUFBZ0FJQUFBQU1CUkhNVnhKRWR5Sk1tU0xFbVRORXV6UE0zVFBFMzBSRkVVVGROVVJWZDBSZDIwUmRtVVRkZDBUZGwwVlZtMVhWbTJiZG5XYlYrV2JkLzNmZC8zZmQvM2ZkLzNmZC8zZFIwSURWa0ZBRWdBQU9oSWpxUklpcVJJanVNNGtpUUJvU0dyQUFBWkFBQUJBQ2lLb3ppTzQwaVNKRW1XcEVtZTVWbWlabXFtWjNxcXFBS2hJYXNBQUVBQUFBRUFBQUFBQUNpYTRpbW00aW1pNGptaUkwcWlaVnFpcG1xdUtKdXk2N3F1NjdxdTY3cXU2N3F1NjdxdTY3cXU2N3F1NjdxdTY3cXU2N3F1NjdxdTY3b3VFQnF5Q2dDUUFBRFFrUnpKa1J4SmtSUkprUnpKQVVKRFZnRUFNZ0FBQWdCd0RNZVFGTW14TEV2VFBNM1RQRTMwUkUvMFRFOFZYZEVGUWtOV0FRQ0FBQUFDQUFBQUFBQXdKTU5TTEVkek5FbVVWRXUxVkUyMVZFc1ZWVTlWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVTFUZE0wVFNBMFpDVUFBQVFBd0dLTndlVWdJU1VsNWQ0UXdoQ1RuakVtSWJWZUlRU1JrdDR4QmhXRG5qS2lESExlUXVNUWd4NElEVmtSQUVRQkFBREdJTWNRYzhnNVI2bVRFam5ucUhTVUd1Y2NwWTVTWnluRm1HTE5LSlhZVXF5TmM0NVNSNjJqbEdJc0xYYVVVbzJweGdJQUFBSWNBQUFDTElSQ1ExWUVBRkVBQUlReFNDbWtGR0tNT2FlY1E0d3A1NWh6aGpIbUhIT09PZWVnZEZJcTU1eDBUa3JFR0hPT09hZWNjMUk2SjVWelRrb25vUUFBZ0FBSEFJQUFDNkhRa0JVQlFKd0FnRUdTUEUveU5GR1VORThVUlZOMFhWRTBYZGZ5UE5YMFRGTlZQZEZVVlZOVmJkbFVWVm1XUE04MFBkTlVWYzgwVmRWVVZWazJWVldXUlZYVmJkTjFkZHQwVmQyV2JkdjNYVnNXZGxGVmJkMVVYZHMzVmRmMlhkbjJmVm5XZFdQeVBGWDFUTk4xUGROMFpkVjFiVnQxWFYzM1RGT1dUZGVWWmROMWJkdVZaVjEzWmRuM05kTjBYZE5WWmRsMFhkbDJaVmUzWFZuMmZkTjFoZCtWWlY5WFpWa1lkbDMzaFZ2WGxlVjBYZDFYWlZjM1ZsbjJmVnZYaGVIV2RXR1pQRTlWUGROMFhjODBYVmQxWFY5WFhkZldOZE9VWmROMWJkbFVYVmwyWmRuM1hWZldkYzgwWmRsMFhkczJYVmVXWFZuMmZWZVdkZDEwWFY5WFpWbjRWVmYyZFZuWGxlSFdiZUUzWGRmM1ZWbjJoVmVXZGVIV2RXRzVkVjBZUGxYMWZWTjJoZUYwWmQvWGhkOVpibDA0bHRGMWZXR1ZiZUZZWlZrNWZ1RllsdDMzbFdWMFhWOVliZGtZVmxrV2hsLzRuZVgyZmVONGRWMFpidDNuekxydkRNZnZwUHZLMDlWdFk1bDkzVmxtWDNlTzRSZzZ2L0RqcWFxdm02NHJES2NzQzcvdDY4YXorNzZ5aks3cis2b3NDNzhxMjhLeDY3N3ovTDZ3TEtQcytzSnF5OEt3MnJZeDNMNXVMTDl3SE10cjY4b3g2NzVSdG5WOFgzZ0t3L04wZFYxNVpsM0g5blYwNDBjNGZzb0FBSUFCQndDQUFCUEtRS0VoS3dLQU9BRUFqeVNKb21SWm9paFpsaWlLcHVpNm9taTZycVJwcHFscG5tbGFtbWVhcG1tcXNpbWFyaXhwbW1sYW5tYWFtcWVacG1pYXJtdWFwcXlLcGluTHBtcktzbW1hc3V5NnNtMjdybXpib21uS3NtbWFzbXlhcGl5N3NxdmJydXpxdXFSWnBxbDVubWxxbm1lYXBtcktzbW1hcnF0NW5tcDZubWlxbmlpcXFtcXFxcTJxcWl4Ym5tZWFtdWlwcGllS3FtcXFwcTJhcWlyTHBxcmFzbW1xdG15cXFtMjdxdXo2c20zcnVtbXFzbTJxcGkyYnFtcmJydXpxc2l6YnVpOXBtbWxxbm1lYW11ZVpwbW1hc215YXFpdGJucWVhbmlpcXF1YUpwbXFxcWl5YnBxcktsdWVacWllS3F1cUpubXVhcWlyTHBtcmFxbW1hdG15cXFpMmJwaXJMcm0zN3Z1dktzbTZxcW15YnFtcnJwbXJLc216THZ1L0txdTZLcGluTHBxcmFzbW1xc2kzYnN1L0xzcXo3b21uS3NtbXFzbTJxcWk3THNtMGJzMno3dW1pYXNtMnFwaTJicWlyYnNpMzd1aXpidXUvS3JtK3JxcXpyc2kzN3V1NzZybkRydWpDOHNtejdxcXo2dWl2YnVtL3JNdHYyZlVUVGxHVlROVzNiVkZWWmRtWFo5bVhiOW4zUk5HMWJWVlZiTmszVnRtVlo5bjFadG0xaE5FM1pObFZWMWszVnRHMVpsbTFodG1YaGRtWFp0MlZiOW5YWGxYVmYxMzNqMTJYZDVycXk3Y3V5cmZ1cXEvcTI3dnZDY091dThBb0FBQmh3QUFBSU1LRU1GQnF5RWdDSUFnQUFqR0dNTVFpTlVzNDVCNkZSeWpubklHVE9RUWdobGN3NUNDR1VramtIb1pTVU11Y2dsSkpTQ0tHVWxGb0xJWlNVVW1zRkFBQVVPQUFBQk5pZ0tiRTRRS0VoS3dHQVZBQUFnK05ZbHVlWm9tcmFzbU5KbmllS3FxbXF0dTFJbHVlSm9tbXFxbTFibmllS3BxbXFydXZybXVlSm9tbXFxdXZxdW1pYXBxbXFydXU2dWk2YW9xbXFxdXU2c3E2YnBxcXFyaXU3c3V6cnBxcXFxdXZLcml6N3dxcTZyaXZMc20zcndyQ3FydXZLc216YnRtL2N1cTdydnUvN3dwR3Q2N291L01JeERFY0JBT0FKRGdCQUJUYXNqbkJTTkJaWWFNaEtBQ0FEQUlBd0JpR0RFRUlHSVlTUVVrb2hwWlFTQUFBdzRBQUFFR0JDR1NnMFpFVUFFQ2NBQUJoREthU1VVa29wcFpSU1NpbWxsRkpLS2FXVVVrb3BwWlJTU2ltbGxGSklLYVdVVWtvcHBaUlNTaW1sbEZKS0thV1VVa29wcFpSU1NpbWxsRkpLS2FXVVVrb3BwWlJTU2ltbGxGSktxYVNVVWtvcHBaUlNTaW1sbEZKS0thV1VVa29wcFpSU1NpbWxsRkpLS2FXVVVrb3BwWlJTU2ltbGxGSktLYVdVVWtvcHBaUlNTaW1sbEZKS0thV1VVa29wcFpSU1NpbWxsRkpLS2FXVVVrb3BwWlJTU2ltbGxGSktLYVdVVWtvcHBaUlNTaW1sbEZKS0thV1VVa29wcFpSU1NpbWxsRkpLS2FXVVVrb3BwWlJTU2ltbGxGSktLYVdVVWtvcHBaUlNTaW1sbEZKS0thV1VVa29wcFpSU1NpbWxsRkpLS2FXVVVrb3BwWlJTU2ltbGxGSktLYVdVVWtvcHBaUlNTaW1sbEZKS0thV1VVa29wcFpSU1NpbWxsRkpLS2FXVVVrb3BwWlJTU2ltbGxGSktLWlZTU2ltbGxGSktLYVdVVWtvcHBaUlNTaW1sbEZKS0thV1VVa29wcFpSU1NpbWxsRkpLS2FXVVVrb3BwWlJTU2ltbGxGSktLYVdVVWtvcHBaUlNTaW1sbEZKS0thV1VVa29wcFpSU1NpbWxsRkpLS2FXVVVnb0FrSXB3QUpCNk1LRU1GQnF5RWdCSUJRQUFqRkZLS2NhY2d4QXg1aGhqMEVrb0tXTE1PY1ljbEpKUzVSeUVFRkpwTGJmS09RZ2hwTlJTYlpselVscUxNZVlZTStla3BCUmJ6VG1IVWxLTHNlYWFhKzZrdEZacnJqWG5XbHFyTmRlY2M4MjV0QlpycmpuWG5IUExNZGVjYzg0NTV4aHp6am5ubkhQT0JRRGdORGdBZ0I3WXNEckNTZEZZWUtFaEt3R0FWQUFBQWhtbEdIUE9PZWdRVW93NTV4eUVFQ0tGR0hQT09RZ2hWSXc1NXh4MEVFS29HSFBNT1FnaGhKQTU1eHlFRUVJSUlYTU9PdWdnaEJCQ0J4MkVFRUlJb1pUT1FRZ2hoQkJLS0NHRUVFSUlJWVFRT2dnaGhCQkNDQ0dFRUVJSUlZUlNTZ2doaEJCQ0NhR1VVQUFBWUlFREFFQ0FEYXNqbkJTTkJSWWFzaElBQUFJQWdCeVdvRkxPaEVHT1FZOE5RY3BSTXcxQ1REblJtV0pPYWpNVlU1QTVFSjEwRWhscVFkbGVNZ3NBQUlBZ0FDREFCQkFZSUNqNFFnaUlNUUFBUVlqTUVBbUZWYkRBb0F3YUhPWUJ3QU5FaEVRQWtKaWdTTHU0Z0M0RFhOREZYUWRDQ0VJUWdsZ2NRQUVKT0RqaGhpZmU4SVFibktCVFZPb2dBQUFBQUFBTUFPQUJBT0NnQUNJaW1xdXd1TURJME5qZzZQQUlBQUFBQUFBV0FQZ0FBRGcrZ0lpSTVpb3NMakF5TkRZNE9qd0NBQUFBQUFBQUFBQ0FnSUFBQUFBQUFFQUFBQUNBZ0U5bloxTUFCQUVBQUFBQUFBQUFYY1hlRndJQUFBQnEybnB4QWdFQkFBbz1cIixcbiAgXCJlbXB0eU1wM1wiOiBcIi8vc1F4QUFEd0FBQnBBQUFBQ0FBQURTQUFBQUVURUZOUlRNdU9Ua3VOVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlU9XCIsXG4gIFwiaGlnaHRpY2tcIjogXCJVa2xHUmtRRkFBQlhRVlpGWm0xMElCQUFBQUFCQUFFQVJLd0FBSWhZQVFBQ0FCQUFaR0YwWVNBRkFBQ3gveGYvZEFET0FDd0JzUDNwKzZIK3pBR29CT2tDQ3dCWC9FSDVPdnhsQTRrSjJ3Y1NBclQ5RS91dCtIVDJldlV4OThuNk9BRjVDQ1VNd1F2ZkNPc0p4QXgwRFNJTUVBcTlCaUFCM3ZoejdtTGtUOXNSMTMzWXhOMnM1UUx2MHZyVUJud1JueHVRSmVFc1NEQ2lNZDh5RlM4YUtGSWhvaFVzQ0tqNjR1NjI1T3JhQTlIdXlQbkVsY1Ard3h2Sld0VzI1NjM3VlEwakhQZ25CVERETTFvMEN6S0xLKzhoemhnRkRPejhTZTRKNDdEWVZ0RzB6NWZRcTlMQjEycmZBK2o5OXJvSEFoZWxJeU13SWpkVE91VThtandJT0dveGhDYjVFNTMvaiszazMvZlRZOHBUdzR5L1RyK2V3OERNdmRzazhSY0hSUmtTS080eUdUa0hQa1Uvcnp6eU5jZ3NyUjk0RHAvNXIrWnMxN3pPbmNvRHhoZkUzOFdMeW4vVGVPTWk5cjBJUnhsUktJUXp5VGxPUEtvOXlqbVdNY29rRFJMYy9ZN3J1ZHRkenUvRDJMMUl1KzI3SmNHM3lZclZMdWpsKzNVT1p4MVVLNVEwcXptTlBEazhaamVlTVBvanpoSCsvakx0UGQ1bTBoSExIc1lJdzVURU1NbkEwanZqOGZTT0Jpd1hBU1pnTXpNOGRVQkdRYkkrcnpqcEtrSVp5Z1pUOVFmbGNkYVJ5cVhDejcrVndVUEg3ODRyM0s3cyt2MEtEdThidnllTE1iNDNOanJoT0lvMGRTdlFIaTBQblA2aTdvdmczTlR4eTQvR2Y4WDh5SC9RQnR2WDU1UDJZZ2IwRmNVanN5NExObUk1ZWppWE0zOHI3aUM4Rkp3SFB2b2s3ZERnUWRhSnpsVEtJc29GenNyVmt1QTg3ZC82cUFpN0ZRMGg5Q2xLTUxFejNUT3JNQmNxWVNEOEU5QUZkL2RTNmtUZjZkYlUwWG5RdjlJSDJNWGZaK2xuOURFQUZ3d2RGeThnaWliNkthd3FlQ2hnSS9VYkhCT1RDWmovdnZYZTdJbmxGdUROM1AzYjBkMUY0Z3pwaWZHMit1NEQ3UXcxRmZ3Ym5DRCtJbGdqV3lITEhQTVZvZzJtQkwzN3F2UCs3TnZuWXVUdjRydmpmdWJONmszd3BQWjAvV2tFT3d0aUVVc1djeG0rR2w0YU9oaGlGREFQSXdtYkF0bjdUUFZ5Nzd6cWNlZnI1WUhtSHVsbDdlbnlmUG1jQUhnSGV3MVJFcjhWaGhkL0YrQVYxUkowRGlrSldRTmMvWlAzZWZLZDdodnMydXI0NnJIczV1OGU5Ti80OC8waEEvOEhGZ3d1RDA0UlNCSVJFcXNRT2c3bUNzc0dNQUpXL1huNEcvVEs4TGJ1enUwSTdxVHZuUEp5OXNYNmJQODRCTFlJYkF3ZEQ4NFFZeEc3RU9jT0RBeHdDRk1FQVFDOSs3UDNTdlRYOFhIdyt1OVI4S1R4SXZTbzkrWDdWUUNVQkowSU13emlEajRRTGhBR0Q5VU1yZ25UQlpjQlJ2MXYrWHYyVWZTKzh0ZngrdkVTODd6MCt2YjMrWmY5WmdFUUJTRUlVQXJXQzhrTTJReXpDNUVKRUFkdkJIZ0JYUDVuKytyNEF2ZDg5V2owN2ZNdzlEMzFKdmZwK1VqOXhRRDlBOFFHNVFoWENsRUxyQXN2Qzl3SjdnZDZCV0lDM3Y2Tys3VDRQUFpOOUVIeld2TmY5UHoxRnZpdCtxTDlyUUNIQXdFRy93ZUNDWlVLRnd2RENuSUpjQWNRQldjQ2FmOFovQ0Q1NXZhQjlkRDB3UFNQOVVMM20vazcvTXorSndFeUF3OEZ6QVk3Q0JzSmFRazVDV2tJMmdhdEJDSUNZZitqL0ZyNnZmaVY5ODcyc2ZaUDkxejRwL2xSKzNIOXpmODlBcm9FRkFmakNQMEpjd284Q2pBSmRRZGdCU0VEa2dEUS9WajdaZm5SOTVUMjhmVWQ5djMyVnZnMituYjgrLzZ4QVdvRTRBYkRDUDRKcEFxYkNxUUowd2VFQmZnQ1RBQ1QvUjM3TS9tKzk2NzJJUFk2OWdiM2FmaFcrdFQ4cWYrTUFqMEZnZ2N1Q1NjS1hBcmlDY01JRUFmeUJKWUNGd0NQL1J6N0EvbDc5M3oyRi9abjltSDM3ZmpkK2kzOXlmOXBBdDBFRkFmUkNOa0pHQXFyQ1pZSXZnWlBCSjhCNlA0Ly9NMzUwdmR6OXEvMWxmVXE5bXozUlBtaSszSCtiZ0ZWQk9RRzN3Z0hDa3dLMEFtN0NDQUhDZ1dtQWpBQVwiLFxuICBcImxvd3RpY2tcIjogXCJVa2xHUmxRRkFBQlhRVlpGWm0xMElCQUFBQUFCQUFFQVJLd0FBSWhZQVFBQ0FCQUFaR0YwWVRBRkFBQjAvNXYrVS80VC8zZ0Ewd0ZUQXVVQitmOGQvblQ5MGYxcS91Yit0ZjQ2L21iLzh3RlFBOWdDN3dDZC9tcitGQUdSQTNjRTZ3SmYvaDM2ZXZtdis4di9Od1JIQlpVQzIvNjArLy81RXZ1Wi9hWC9iZ0ZPQXA4QXp2emg5d2Z6TFBGNjh6VDR5LzJCQXlnSWZRd2FFallZMHgzMUlyd2w4U09XSFZFU09nUGg5TmZwUmVGdDIybllIZGREMkJYY1plRGE1SW5xZ1BEeDluUCs2Z1M0Q0JZTG53MHpFUzBXWHh2NEhrY2dMaC8xRytFWDFSTnBENHdLaWdYSC82cjUvZk51N2xUcGorWnU1aEhvWE90TDcxYnlyL1FwOTFMNjR2Nk9CTzRKb1E1ekVza1UraFUxRmlRVmVSUDdFV2dQNFFyMEJJVCt0UGlkOUMzeTF2Q2g4RkR4SnZLMjh2dnl5L0xBOHBMelUvWFA5NXY2eHZ3NC91RC9SQUsyQlNrS2NnNkJFU2NUWkJNZUVxa1BUUXhqQ0tFRVZ3RmkvbnY3aC9ocDlhRHlBdkhQOE1meEx2TSs5UFgwdVBXMTlnLzRMZnI3L0M0QUtnTmFCWFFHeXdiMEJoSUhXUWZXQjFvSXpBanRDRjhJSHdkdEJha0RWd0tMQWVZQTh2OXcva2o4MS9uUTk0djI5L1hYOWJ6MWJQVVk5VXoxWi9hSCtIcjd5UDRNQWk0Rit3Y2ZDbllMTmd5ZkRQc01TdzBzRFVBTWZncmNCNUlFTXdGYi9pWDhUL3BUK08vMVgvTWY4Y2J2ck8rMThNTHl2ZlZQK1JmOXdnQW9CQ0VIcHduSUM1RU40UTVBRDN3TzFBeTBDcHNJdndidkJOY0NiUUFyL25YOE9mc2YrdmI0bXZkYTlyajF6L1dYOXBMM2EvaEgrWlg2Ui93bi92UC9lUUVTQS9BRSt3WURDY3dLRkF5UERDa01GUXVTQ2U0SFZRYlNCSFFEQ3dJOEFOTDlKUHVZK0hYMjh2VHE4MlB6ZFBNVjlBejFNZlo0OXpENWdmdHgvc1FCQlFYTEI4Y0ovZ3FwQ3c4TWlnd1dEWEVOWFEyckREVUw3UWdEQnN3Q2R2OFMvSzc0V1BWazhoWHdvdTRQN212dTErOVQ4cHoxVXZsaS9ab0J3Z1dSQ2NzTVBnL0NFRVFSNFJEQUR3b085d3VzQ1ZNSDRBUlNBcG4vdWZ6ZCtXajNidlg3OHh6engvTDY4cXp6MXZTRDlxWDRHZnZkL2MwQWh3Ty9CV3dIbWdodkNRRUtWUW9uQ2xzSkN3aUlCaDBGMGdPZ0FtMEJPd0F4LzAzK1hQMGcvTGI2Y1BtWCtGLzR2ZmgrK1RINnMvb3MrNy83Y3Z3TC9aejlYUDVPLzNJQTNBRjlBenNGOWdhVUNBQUtIZ3VlQ3pjTDl3bnRCM3NGNHdJekFJMzk2ZnAxK0d2Mkl2V245TjMwcC9YaTltNzRHL3J1KzlQOWsvOGFBWUVDMUFNVEJTSUcwd1l1QjFnSGtnY0FDR0VJU0FoVEJ6RUZXQUt0LzVMOTJmdVUrdlg1MGZtZitTUDVpL2diK0JmNG12aXYrU3I3a3Z5Yi9VaityLzRYLzhyLytnQ2lBbzBFVUFhUkJ6d0lTd2pxQjNJSEdRZkNCdjhGcGdUTUFwUUFLZjY3KzVuNS92Zm45anoyeVBWbjlTTDFSUFhxOVNQM0R2bXIrNmYrc1FHS0JBY0grd2hPQ2gwTGF3czNDMjhLTEFtREI1QUZmUU5vQVZQL1p2M2UrN1A2c2ZuTCtDdjR2UGVNOTViMzdmZVYrSm41MVBvcS9MTDltditZQVZZRDNnUXVCbWNIU0Fpa0NJRUk3QWYrQnVFRm5nUVhBMXNCdi85di9wZjlNUDNXL0ZqOHEvc1IrNkg2VS9vMyttUDZ5L3BOKy9mN3h2eWUvV0grSmY5bUFENENRQVFKQmlzSHRnZjZCdzBJOFFkc0Ixc0d5d1Q0QWdnQkNQL28vS1g2bVBnMTk1NzJqZmF6OXVmMlMvY00rRTM1RS90Vy9hZi81d0gxQThBRktnZmtCL0FIZ3dmeEJsQUdnUVZJQk1NQ0p3R3MvNDMrdlAwaS9acjhMZnpsKzlINzZmdmkrOWY3NWZzZi9JbjhCUDEwL2VqOWNmNE8vN2YvZEFBY0FhVUJFZ0tNQWhnRHBBTUVCQ0VFRHdUZkEzSUR4UUw4QVNvQlV3Q0cvODcrSi82aC9ScjlwUHhrL0diOG9Qd0ovWEg5dy8zOS9VRCtxUDQxLzlEL1d3RGVBR3NCQWdLZEFoRURRUU5BQTBzRGJ3T1ZBNVlEVndQT0FoZ0NWQUdSQUE9PVwiLFxufSIsImltcG9ydCB7Z2V0TUlESU91dHB1dEJ5SWQsIGdldE1JRElPdXRwdXRzfSBmcm9tICcuL2luaXRfbWlkaSdcbmltcG9ydCB7Y29udGV4dH0gZnJvbSAnLi9pbml0X2F1ZGlvJ1xuXG5cbmNvbnN0IEJVRkZFUl9USU1FID0gMjAwIC8vIG1pbGxpc1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTY2hlZHVsZXJ7XG5cbiAgY29uc3RydWN0b3Ioc29uZyl7XG4gICAgdGhpcy5zb25nID0gc29uZ1xuICB9XG5cblxuICBpbml0KG1pbGxpcyl7XG4gICAgdGhpcy5zb25nU3RhcnRNaWxsaXMgPSBtaWxsaXNcbiAgICB0aGlzLmV2ZW50cyA9IHRoaXMuc29uZy5fZXZlbnRzXG4gICAgdGhpcy5udW1FdmVudHMgPSB0aGlzLmV2ZW50cy5sZW5ndGhcbiAgICB0aGlzLmluZGV4ID0gMFxuICAgIHRoaXMuc2V0SW5kZXgodGhpcy5zb25nU3RhcnRNaWxsaXMpXG4gIH1cblxuXG4gIHNldFRpbWVTdGFtcCh0aW1lU3RhbXApe1xuICAgIHRoaXMudGltZVN0YW1wID0gdGltZVN0YW1wXG4gIH1cblxuICAvLyBnZXQgdGhlIGluZGV4IG9mIHRoZSBldmVudCB0aGF0IGhhcyBpdHMgbWlsbGlzIHZhbHVlIGF0IG9yIHJpZ2h0IGFmdGVyIHRoZSBwcm92aWRlZCBtaWxsaXMgdmFsdWVcbiAgc2V0SW5kZXgobWlsbGlzKXtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yKGxldCBldmVudCBvZiB0aGlzLmV2ZW50cyl7XG4gICAgICBpZihldmVudC5taWxsaXMgPj0gbWlsbGlzKXtcbiAgICAgICAgdGhpcy5pbmRleCA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaSsrO1xuICAgIH1cbiAgfVxuXG5cbiAgZ2V0RXZlbnRzKCl7XG4gICAgbGV0IGV2ZW50cyA9IFtdXG4gICAgLy8gbWFpbiBsb29wXG4gICAgZm9yKGxldCBpID0gdGhpcy5pbmRleDsgaSA8IHRoaXMubnVtRXZlbnRzOyBpKyspe1xuICAgICAgbGV0IGV2ZW50ID0gdGhpcy5ldmVudHNbaV07XG4gICAgICAvL2NvbnNvbGUubG9nKGV2ZW50Lm1pbGxpcywgdGhpcy5tYXh0aW1lKVxuICAgICAgaWYoZXZlbnQubWlsbGlzIDwgdGhpcy5tYXh0aW1lKXtcblxuICAgICAgICAvL2V2ZW50LnRpbWUgPSB0aGlzLnRpbWVTdGFtcCArIGV2ZW50Lm1pbGxpcyAtIHRoaXMuc29uZ1N0YXJ0TWlsbGlzO1xuXG4gICAgICAgIGlmKGV2ZW50LnR5cGUgPT09ICdhdWRpbycpe1xuICAgICAgICAgIC8vIHRvIGJlIGltcGxlbWVudGVkXG4gICAgICAgIH1lbHNle1xuICAgICAgICAgIGV2ZW50cy5wdXNoKGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluZGV4Kys7XG4gICAgICB9ZWxzZXtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBldmVudHM7XG4gIH1cblxuXG4gIHVwZGF0ZShtaWxsaXMpe1xuICAgIHZhciBpLFxuICAgICAgZXZlbnQsXG4gICAgICBudW1FdmVudHMsXG4gICAgICB0cmFjayxcbiAgICAgIGV2ZW50cyxcbiAgICAgIGluc3RydW1lbnQsXG4gICAgICBzY2hlZHVsZWRUaW1lXG5cbiAgICAvL2NvbnNvbGUubG9nKHBvc2l0aW9uLCB0aGlzLm1heHRpbWUpXG4gICAgZXZlbnRzID0gdGhpcy5nZXRFdmVudHMoKVxuICAgIG51bUV2ZW50cyA9IGV2ZW50cy5sZW5ndGhcbiAgICB0aGlzLm1heHRpbWUgPSBtaWxsaXMgKyBCVUZGRVJfVElNRVxuXG4gICAgLy9jb25zb2xlLmxvZygndXBkYXRlJywgdGhpcy5tYXh0aW1lLCBudW1FdmVudHMpXG5cbiAgICBmb3IoaSA9IDA7IGkgPCBudW1FdmVudHM7IGkrKyl7XG4gICAgICBldmVudCA9IGV2ZW50c1tpXVxuICAgICAgdHJhY2sgPSBldmVudC5fdHJhY2tcbiAgICAgIGluc3RydW1lbnQgPSB0cmFjay5faW5zdHJ1bWVudFxuXG4gICAgICAvL2NvbnNvbGUubG9nKGV2ZW50LnRpY2tzKVxuXG4gICAgICAvLyBpZih0eXBlb2YgaW5zdHJ1bWVudCA9PT0gJ3VuZGVmaW5lZCcpe1xuICAgICAgLy8gICBjb250aW51ZVxuICAgICAgLy8gfVxuXG4gICAgICBpZihldmVudC5fcGFydC5tdXRlZCA9PT0gdHJ1ZSB8fCB0cmFjay5tdXRlZCA9PT0gdHJ1ZSB8fCBldmVudC5tdXRlZCA9PT0gdHJ1ZSl7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cblxuICAgICAgaWYoKGV2ZW50LnR5cGUgPT09IDE0NCB8fCBldmVudC50eXBlID09PSAxMjgpICYmIHR5cGVvZiBldmVudC5taWRpTm90ZSA9PT0gJ3VuZGVmaW5lZCcpe1xuICAgICAgICAvLyB0aGlzIGlzIHVzdWFsbHkgY2F1c2VkIGJ5IHRoZSBzYW1lIG5vdGUgb24gdGhlIHNhbWUgdGlja3MgdmFsdWUsIHdoaWNoIGlzIHByb2JhYmx5IGEgYnVnIGluIHRoZSBtaWRpIGZpbGVcbiAgICAgICAgLy9jb25zb2xlLmluZm8oJ25vIG1pZGlOb3RlSWQnLCBldmVudClcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gZGVidWcgbWludXRlX3dhbHR6IGRvdWJsZSBldmVudHNcbiAgICAgIC8vIGlmKGV2ZW50LnRpY2tzID4gNDAzMDApe1xuICAgICAgLy8gICBjb25zb2xlLmluZm8oZXZlbnQpXG4gICAgICAvLyB9XG5cbiAgICAgIHNjaGVkdWxlZFRpbWUgPSAodGhpcy50aW1lU3RhbXAgKyBldmVudC5taWxsaXMgLSB0aGlzLnNvbmdTdGFydE1pbGxpcylcbiAgICAgIC8vY29uc29sZS5sb2coJ3NjaGVkdWxlZCcsIHNjaGVkdWxlZFRpbWUsICdjdXJyZW50JywgY29udGV4dC5jdXJyZW50VGltZSAqIDEwMDApXG5cbiAgICAgIGlmKGV2ZW50LnR5cGUgPT09ICdhdWRpbycpe1xuICAgICAgICAvLyB0byBiZSBpbXBsZW1lbnRlZFxuICAgICAgfWVsc2V7XG5cbiAgICAgICAgLy8gc2VuZCB0byBqYXZhc2NyaXB0IGluc3RydW1lbnRcbiAgICAgICAgaWYodHlwZW9mIGluc3RydW1lbnQgIT09ICd1bmRlZmluZWQnKXtcbiAgICAgICAgICAvLyBjb252ZXJ0IHRvIHNlY29uZHMgYmVjYXVzZSB0aGUgYXVkaW8gY29udGV4dCB1c2VzIHNlY29uZHMgZm9yIHNjaGVkdWxpbmdcbiAgICAgICAgICBpbnN0cnVtZW50LnByb2Nlc3NNSURJRXZlbnQoZXZlbnQsIHNjaGVkdWxlZFRpbWUgLyAxMDAwLCB0cmFjay5fb3V0cHV0KVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2VuZCB0byBleHRlcm5hbCBoYXJkd2FyZSBvciBzb2Z0d2FyZSBpbnN0cnVtZW50XG4gICAgICAgIGxldCBjaGFubmVsID0gdHJhY2suY2hhbm5lbFxuICAgICAgICBsZXQgb2Zmc2V0ID0gKEJVRkZFUl9USU1FICogMikgLy8gd2h5IGRvZXMgdGhpcyB3b3JrP1xuXG4gICAgICAgIGZvcihsZXQgcG9ydElkIG9mIHRyYWNrLl9taWRpT3V0cHV0SWRzKXtcbiAgICAgICAgICBsZXQgcG9ydCA9IGdldE1JRElPdXRwdXRCeUlkKHBvcnRJZClcbiAgICAgICAgICBpZihwb3J0KXtcbiAgICAgICAgICAgIGlmKGV2ZW50LnR5cGUgPT09IDEyOCB8fCBldmVudC50eXBlID09PSAxNDQgfHwgZXZlbnQudHlwZSA9PT0gMTc2KXtcbiAgICAgICAgICAgICAgcG9ydC5zZW5kKFtldmVudC50eXBlICsgY2hhbm5lbCwgZXZlbnQuZGF0YTEsIGV2ZW50LmRhdGEyXSwgc2NoZWR1bGVkVGltZSArIG9mZnNldClcbiAgICAgICAgICAgIH1lbHNlIGlmKGV2ZW50LnR5cGUgPT09IDE5MiB8fCBldmVudC50eXBlID09PSAyMjQpe1xuICAgICAgICAgICAgICBwb3J0LnNlbmQoW2V2ZW50LnR5cGUgKyBjaGFubmVsLCBldmVudC5kYXRhMV0sIHNjaGVkdWxlZFRpbWUgKyBvZmZzZXQpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vY29uc29sZS5sb2codGhpcy5pbmRleCwgdGhpcy5udW1FdmVudHMpXG4gICAgLy9yZXR1cm4gdGhpcy5pbmRleCA+PSAxMFxuICAgIHJldHVybiB0aGlzLmluZGV4ID49IHRoaXMubnVtRXZlbnRzIC8vIGVuZCBvZiBzb25nXG4gIH1cblxuXG4gIGFsbE5vdGVzT2ZmKCl7XG4gICAgLy9jb25zb2xlLmxvZygnU1RPUCcpXG4vLy8qXG4gICAgbGV0IHRpbWVTdGFtcCA9IGNvbnRleHQuY3VycmVudFRpbWUgKiAxMDAwXG4gICAgbGV0IG91dHB1dHMgPSBnZXRNSURJT3V0cHV0cygpXG4gICAgb3V0cHV0cy5mb3JFYWNoKChvdXRwdXQpID0+IHtcbiAgICAgIG91dHB1dC5zZW5kKFsweEIwLCAweDdCLCAweDAwXSwgdGltZVN0YW1wICsgKEJVRkZFUl9USU1FICogMikpOyAvLyBzdG9wIGFsbCBub3Rlc1xuICAgICAgb3V0cHV0LnNlbmQoWzB4QjAsIDB4NzksIDB4MDBdLCB0aW1lU3RhbXAgKyAoQlVGRkVSX1RJTUUgKiAyKSk7IC8vIHJlc2V0IGFsbCBjb250cm9sbGVyc1xuICAgIH0pXG4vLyovXG4gICAgbGV0IHRyYWNrcyA9IHRoaXMuc29uZy5fdHJhY2tzXG4gICAgdHJhY2tzLmZvckVhY2goKHRyYWNrKSA9PiB7XG4gICAgICAvL2xldCBpbnN0cnVtZW50ID0gdHJhY2suX2luc3RydW1lbnRcbiAgICAgIC8vaWYodHlwZW9mIGluc3RydW1lbnQgIT09ICd1bmRlZmluZWQnKXtcbiAgICAgIC8vICBpbnN0cnVtZW50LmFsbE5vdGVzT2ZmKClcbiAgICAgIC8vfVxuICAgICAgdHJhY2suX2luc3RydW1lbnQuYWxsTm90ZXNPZmYoKVxuICAgIH0pXG4gIH1cbn1cblxuIiwiLy9AIGZsb3dcblxuaW1wb3J0IHtwYXJzZVRpbWVFdmVudHMsIHBhcnNlRXZlbnRzfSBmcm9tICcuL3BhcnNlX2V2ZW50cydcbi8vaW1wb3J0IHthZGRUYXNrLCByZW1vdmVUYXNrfSBmcm9tICcuL2hlYXJ0YmVhdCdcbmltcG9ydCB7Y29udGV4dH0gZnJvbSAnLi9pbml0X2F1ZGlvJ1xuaW1wb3J0IFNjaGVkdWxlciBmcm9tICcuL3NjaGVkdWxlcidcbmltcG9ydCB7TUlESUV2ZW50fSBmcm9tICcuL21pZGlfZXZlbnQnXG5pbXBvcnQge3NvbmdGcm9tTUlESUZpbGUsIHNvbmdGcm9tTUlESUZpbGVBc3luY30gZnJvbSAnLi9zb25nX2Zyb21fbWlkaWZpbGUnXG5pbXBvcnQgcWFtYmkgZnJvbSAnLi9xYW1iaSdcbmltcG9ydCB7c29ydEV2ZW50c30gZnJvbSAnLi91dGlsJ1xuaW1wb3J0IHtjYWxjdWxhdGVQb3NpdGlvbn0gZnJvbSAnLi9wb3NpdGlvbidcbmltcG9ydCB7UGxheWhlYWR9IGZyb20gJy4vcGxheWhlYWQnXG5pbXBvcnQge2FkZEV2ZW50TGlzdGVuZXIsIHJlbW92ZUV2ZW50TGlzdGVuZXIsIGRpc3BhdGNoRXZlbnR9IGZyb20gJy4vZXZlbnRsaXN0ZW5lcidcblxubGV0IHNvbmdJbmRleCA9IDBcblxuY29uc3QgZGVmYXVsdFNvbmcgPSB7XG4gIHBwcTogOTYwLFxuICBicG06IDEyMCxcbiAgYmFyczogMzAsXG4gIGxvd2VzdE5vdGU6IDAsXG4gIGhpZ2hlc3ROb3RlOiAxMjcsXG4gIG5vbWluYXRvcjogNCxcbiAgZGVub21pbmF0b3I6IDQsXG4gIHF1YW50aXplVmFsdWU6IDgsXG4gIGZpeGVkTGVuZ3RoVmFsdWU6IGZhbHNlLFxuICBwb3NpdGlvblR5cGU6ICdhbGwnLFxuICB1c2VNZXRyb25vbWU6IGZhbHNlLFxuICBhdXRvU2l6ZTogdHJ1ZSxcbiAgbG9vcDogZmFsc2UsXG4gIHBsYXliYWNrU3BlZWQ6IDEsXG4gIGF1dG9RdWFudGl6ZTogZmFsc2Vcbn1cbi8qXG50eXBlIHNvbmdTZXR0aW5ncyA9IHtcbiAgbmFtZTogc3RyaW5nLFxuICBwcHE6IG51bWJlcixcbiAgYnBtOiBudW1iZXIsXG4gIGJhcnM6IG51bWJlcixcbiAgbG93ZXN0Tm90ZTogbnVtYmVyLFxuICBoaWdoZXN0Tm90ZTogbnVtYmVyLFxuICBub21pbmF0b3I6IG51bWJlcixcbiAgZGVub21pbmF0b3I6IG51bWJlcixcbiAgcXVhbnRpemVWYWx1ZTogbnVtYmVyLFxuICBmaXhlZExlbmd0aFZhbHVlOiBudW1iZXIsXG4gIHBvc2l0aW9uVHlwZTogc3RyaW5nLFxuICB1c2VNZXRyb25vbWU6IGJvb2xlYW4sXG4gIGF1dG9TaXplOiBib29sZWFuLFxuICBsb29wOiBib29sZWFuLFxuICBwbGF5YmFja1NwZWVkOiBudW1iZXIsXG4gIGF1dG9RdWFudGl6ZTogYm9vbGVhblxufVxuKi9cblxuXG5leHBvcnQgY2xhc3MgU29uZ3tcblxuICBzdGF0aWMgZnJvbU1JRElGaWxlKGRhdGEpe1xuICAgIHJldHVybiBzb25nRnJvbU1JRElGaWxlKGRhdGEpXG4gIH1cblxuICBzdGF0aWMgZnJvbU1JRElGaWxlQXN5bmMoZGF0YSl7XG4gICAgcmV0dXJuIHNvbmdGcm9tTUlESUZpbGVBc3luYyhkYXRhKVxuICB9XG5cbiAgY29uc3RydWN0b3Ioc2V0dGluZ3M6IHt9ID0ge30pe1xuXG4gICAgdGhpcy5pZCA9IGBTXyR7c29uZ0luZGV4Kyt9XyR7bmV3IERhdGUoKS5nZXRUaW1lKCl9YDtcblxuICAgICh7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUgPSB0aGlzLmlkLFxuICAgICAgcHBxOiB0aGlzLnBwcSA9IGRlZmF1bHRTb25nLnBwcSxcbiAgICAgIGJwbTogdGhpcy5icG0gPSBkZWZhdWx0U29uZy5icG0sXG4gICAgICBiYXJzOiB0aGlzLmJhcnMgPSBkZWZhdWx0U29uZy5iYXJzLFxuICAgICAgbm9taW5hdG9yOiB0aGlzLm5vbWluYXRvciA9IGRlZmF1bHRTb25nLm5vbWluYXRvcixcbiAgICAgIGRlbm9taW5hdG9yOiB0aGlzLmRlbm9taW5hdG9yID0gZGVmYXVsdFNvbmcuZGVub21pbmF0b3IsXG4gICAgICBxdWFudGl6ZVZhbHVlOiB0aGlzLnF1YW50aXplVmFsdWUgPSBkZWZhdWx0U29uZy5xdWFudGl6ZVZhbHVlLFxuICAgICAgZml4ZWRMZW5ndGhWYWx1ZTogdGhpcy5maXhlZExlbmd0aFZhbHVlID0gZGVmYXVsdFNvbmcuZml4ZWRMZW5ndGhWYWx1ZSxcbiAgICAgIHVzZU1ldHJvbm9tZTogdGhpcy51c2VNZXRyb25vbWUgPSBkZWZhdWx0U29uZy51c2VNZXRyb25vbWUsXG4gICAgICBhdXRvU2l6ZTogdGhpcy5hdXRvU2l6ZSA9IGRlZmF1bHRTb25nLmF1dG9TaXplLFxuICAgICAgbG9vcDogdGhpcy5sb29wID0gZGVmYXVsdFNvbmcubG9vcCxcbiAgICAgIHBsYXliYWNrU3BlZWQ6IHRoaXMucGxheWJhY2tTcGVlZCA9IGRlZmF1bHRTb25nLnBsYXliYWNrU3BlZWQsXG4gICAgICBhdXRvUXVhbnRpemU6IHRoaXMuYXV0b1F1YW50aXplID0gZGVmYXVsdFNvbmcuYXV0b1F1YW50aXplLFxuICAgIH0gPSBzZXR0aW5ncyk7XG5cbiAgICB0aGlzLl90aW1lRXZlbnRzID0gW1xuICAgICAgbmV3IE1JRElFdmVudCgwLCBxYW1iaS5URU1QTywgdGhpcy5icG0pLFxuICAgICAgbmV3IE1JRElFdmVudCgwLCBxYW1iaS5USU1FX1NJR05BVFVSRSwgdGhpcy5ub21pbmF0b3IsIHRoaXMuZGVub21pbmF0b3IpLFxuICAgIF1cblxuICAgIC8vdGhpcy5fdGltZUV2ZW50cyA9IFtdXG4gICAgdGhpcy5fdXBkYXRlVGltZUV2ZW50cyA9IHRydWVcbiAgICB0aGlzLl9sYXN0RXZlbnQgPSBuZXcgTUlESUV2ZW50KDAsIHFhbWJpLkVORF9PRl9UUkFDSylcblxuICAgIHRoaXMuX3RyYWNrcyA9IFtdXG4gICAgdGhpcy5fdHJhY2tzQnlJZCA9IG5ldyBNYXAoKVxuXG4gICAgdGhpcy5fcGFydHMgPSBbXVxuICAgIHRoaXMuX3BhcnRzQnlJZCA9IG5ldyBNYXAoKVxuXG4gICAgdGhpcy5fZXZlbnRzID0gW11cbiAgICB0aGlzLl9ldmVudHNCeUlkID0gbmV3IE1hcCgpXG5cbiAgICB0aGlzLl9ub3RlcyA9IFtdXG4gICAgdGhpcy5fbm90ZXNCeUlkID0gbmV3IE1hcCgpXG5cbiAgICB0aGlzLl9uZXdFdmVudHMgPSBbXVxuICAgIHRoaXMuX21vdmVkRXZlbnRzID0gW11cbiAgICB0aGlzLl9yZW1vdmVkRXZlbnRzID0gW11cbiAgICB0aGlzLl90cmFuc3Bvc2VkRXZlbnRzID0gW11cblxuICAgIHRoaXMuX25ld1BhcnRzID0gW11cbiAgICB0aGlzLl9jaGFuZ2VkUGFydHMgPSBbXVxuICAgIHRoaXMuX3JlbW92ZWRQYXJ0cyA9IFtdXG5cbiAgICB0aGlzLl9zY2hlZHVsZXIgPSBuZXcgU2NoZWR1bGVyKHRoaXMpXG4gICAgdGhpcy5fcGxheWhlYWQgPSBuZXcgUGxheWhlYWQodGhpcylcbiAgICB0aGlzLl9taWxsaXMgPSAwXG5cbiAgICB0aGlzLl9wbGF5aW5nID0gZmFsc2VcbiAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZVxuICB9XG5cblxuICBhZGRUaW1lRXZlbnRzKC4uLmV2ZW50cyl7XG4gICAgLy9AVE9ETzogZmlsdGVyIHRpbWUgZXZlbnRzIG9uIHRoZSBzYW1lIHRpY2sgLT4gdXNlIHRoZSBsYXN0bHkgYWRkZWQgZXZlbnRzXG4gICAgdGhpcy5fdGltZUV2ZW50cy5wdXNoKC4uLmV2ZW50cylcbiAgICB0aGlzLl91cGRhdGVUaW1lRXZlbnRzID0gdHJ1ZVxuICB9XG5cbiAgYWRkVHJhY2tzKC4uLnRyYWNrcyl7XG4gICAgdHJhY2tzLmZvckVhY2goKHRyYWNrKSA9PiB7XG4gICAgICB0cmFjay5fc29uZyA9IHRoaXNcbiAgICAgIHRoaXMuX3RyYWNrcy5wdXNoKHRyYWNrKVxuICAgICAgdGhpcy5fdHJhY2tzQnlJZC5zZXQodHJhY2suaWQsIHRyYWNrKVxuICAgICAgdGhpcy5fbmV3RXZlbnRzLnB1c2goLi4udHJhY2suX2V2ZW50cylcbiAgICAgIHRoaXMuX25ld1BhcnRzLnB1c2goLi4udHJhY2suX3BhcnRzKVxuICAgIH0pXG4gIH1cblxuICAvLyBwcmVwYXJlIHNvbmcgZXZlbnRzIGZvciBwbGF5YmFja1xuICB1cGRhdGUoKTogdm9pZHtcblxuICAgIGxldCBjcmVhdGVFdmVudEFycmF5ID0gZmFsc2VcblxuICAgIGlmKHRoaXMuX3VwZGF0ZVRpbWVFdmVudHMgPT09IGZhbHNlXG4gICAgICAmJiB0aGlzLl9yZW1vdmVkRXZlbnRzLmxlbmd0aCA9PT0gMFxuICAgICAgJiYgdGhpcy5fbmV3RXZlbnRzLmxlbmd0aCA9PT0gMFxuICAgICAgJiYgdGhpcy5fbW92ZWRFdmVudHMubGVuZ3RoID09PSAwXG4gICAgKXtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICAvL2RlYnVnXG4gICAgLy90aGlzLmlzUGxheWluZyA9IHRydWVcblxuICAgIGNvbnNvbGUuZ3JvdXAoJ3VwZGF0ZSBzb25nJylcbiAgICBjb25zb2xlLnRpbWUoJ3RvdGFsJylcblxuICAgIC8vIGNoZWNrIGlmIHRpbWUgZXZlbnRzIGFyZSB1cGRhdGVkXG4gICAgaWYodGhpcy5fdXBkYXRlVGltZUV2ZW50cyA9PT0gdHJ1ZSl7XG4gICAgICAvL2NvbnNvbGUubG9nKCd1cGRhdGVUaW1lRXZlbnRzJywgdGhpcy5fdGltZUV2ZW50cy5sZW5ndGgpXG4gICAgICBwYXJzZVRpbWVFdmVudHModGhpcywgdGhpcy5fdGltZUV2ZW50cywgdGhpcy5pc1BsYXlpbmcpXG4gICAgICB0aGlzLl91cGRhdGVUaW1lRXZlbnRzID0gZmFsc2VcbiAgICAgIGNvbnNvbGUubG9nKCd0aW1lIGV2ZW50cyAlTycsIHRoaXMuX3RpbWVFdmVudHMpXG4gICAgfVxuXG4gICAgLy8gb25seSBwYXJzZSBuZXcgYW5kIG1vdmVkIGV2ZW50c1xuICAgIGxldCB0b2JlUGFyc2VkID0gW11cblxuXG4gICAgLy8gZmlsdGVyIHJlbW92ZWQgcGFydHNcbiAgICBjb25zb2xlLmxvZygncmVtb3ZlZCBwYXJ0cyAlTycsIHRoaXMuX3JlbW92ZWRQYXJ0cylcbiAgICB0aGlzLl9yZW1vdmVkUGFydHMuZm9yRWFjaCgocGFydCkgPT4ge1xuICAgICAgdGhpcy5wYXJ0c0J5SWQuZGVsZXRlKHBhcnQuaWQpXG4gICAgICB0aGlzLl9yZW1vdmVkRXZlbnRzLnB1c2goLi4ucGFydC5fZXZlbnRzKVxuICAgIH0pXG5cblxuICAgIC8vIGFkZCBuZXcgcGFydHNcbiAgICBjb25zb2xlLmxvZygnbmV3IHBhcnRzICVPJywgdGhpcy5fbmV3UGFydHMpXG4gICAgdGhpcy5fbmV3UGFydHMuZm9yRWFjaCgocGFydCkgPT4ge1xuICAgICAgcGFydC5fc29uZyA9IHRoaXNcbiAgICAgIHRoaXMuX3BhcnRzQnlJZC5zZXQocGFydC5pZCwgcGFydClcbiAgICAgIHRvYmVQYXJzZWQucHVzaCguLi5wYXJ0Ll9ldmVudHMpXG4gICAgICBwYXJ0LnVwZGF0ZSgpXG4gICAgfSlcblxuXG4gICAgLy8gdXBkYXRlIGNoYW5nZWQgcGFydHNcbiAgICBjb25zb2xlLmxvZygnY2hhbmdlZCBwYXJ0cyAlTycsIHRoaXMuX2NoYW5nZWRQYXJ0cylcbiAgICB0aGlzLl9jaGFuZ2VkUGFydHMuZm9yRWFjaCgocGFydCkgPT4ge1xuICAgICAgcGFydC51cGRhdGUoKVxuICAgIH0pXG5cblxuICAgIC8vIGZpbHRlciByZW1vdmVkIGV2ZW50c1xuICAgIGNvbnNvbGUubG9nKCdyZW1vdmVkIGV2ZW50cyAlTycsIHRoaXMuX3JlbW92ZWRFdmVudHMpXG4gICAgdGhpcy5fcmVtb3ZlZEV2ZW50cy5mb3JFYWNoKChldmVudCkgPT4ge1xuICAgICAgdGhpcy5fbm90ZXNCeUlkLmRlbGV0ZShldmVudC5taWRpTm90ZS5pZClcbiAgICAgIHRoaXMuX2V2ZW50c0J5SWQuZGVsZXRlKGV2ZW50LmlkKVxuICAgIH0pXG5cbiAgICBjcmVhdGVFdmVudEFycmF5ID0gdGhpcy5fcmVtb3ZlZEV2ZW50cy5sZW5ndGggPiAwXG5cbiAgICAvLyBhZGQgbmV3IGV2ZW50c1xuICAgIGNvbnNvbGUubG9nKCduZXcgZXZlbnRzICVPJywgdGhpcy5fbmV3RXZlbnRzKVxuICAgIHRoaXMuX25ld0V2ZW50cy5mb3JFYWNoKChldmVudCkgPT4ge1xuICAgICAgdGhpcy5fZXZlbnRzQnlJZC5zZXQoZXZlbnQuaWQsIGV2ZW50KVxuICAgICAgdGhpcy5fZXZlbnRzLnB1c2goZXZlbnQpXG4gICAgICB0b2JlUGFyc2VkLnB1c2goZXZlbnQpXG4gICAgICAvL2NvbnNvbGUubG9nKGV2ZW50LmlkKVxuICAgIH0pXG5cblxuICAgIC8vIG1vdmVkIGV2ZW50cyBuZWVkIHRvIGJlIHBhcnNlZFxuICAgIGNvbnNvbGUubG9nKCdtb3ZlZCAlTycsIHRoaXMuX21vdmVkRXZlbnRzKVxuICAgIHRoaXMuX21vdmVkRXZlbnRzLmZvckVhY2goKGV2ZW50KSA9PiB7XG4gICAgICB0b2JlUGFyc2VkLnB1c2goZXZlbnQpXG4gICAgfSlcblxuICAgIC8vdG9iZVBhcnNlZCA9IFsuLi50b2JlUGFyc2VkLCAuLi5BcnJheS5mcm9tKHNvbmcubW92ZWRFdmVudHMudmFsdWVzKCkpXVxuXG4gICAgY29uc29sZS50aW1lKCdwYXJzZScpXG4gICAgaWYodG9iZVBhcnNlZC5sZW5ndGggPiAwKXtcbiAgICAgIC8vY29uc29sZS5sb2coJ3RvYmVQYXJzZWQgJU8nLCB0b2JlUGFyc2VkKVxuICAgICAgdG9iZVBhcnNlZCA9IFsuLi50b2JlUGFyc2VkLCAuLi50aGlzLl90aW1lRXZlbnRzXVxuICAgICAgY29uc29sZS5sb2coJ3BhcnNlRXZlbnRzJywgdG9iZVBhcnNlZC5sZW5ndGggLSB0aGlzLl90aW1lRXZlbnRzLmxlbmd0aClcbiAgICAgIHBhcnNlRXZlbnRzKHRvYmVQYXJzZWQsIHRoaXMuaXNQbGF5aW5nKVxuICAgICAgdG9iZVBhcnNlZC5mb3JFYWNoKGV2ZW50ID0+IHtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhldmVudC5pZCwgZXZlbnQudHlwZSlcbiAgICAgICAgaWYoZXZlbnQudHlwZSA9PT0gcWFtYmkuTk9URV9PTil7XG4gICAgICAgICAgaWYoZXZlbnQubWlkaU5vdGUpe1xuICAgICAgICAgICAgdGhpcy5fbm90ZXNCeUlkLnNldChldmVudC5taWRpTm90ZUlkLCBldmVudC5taWRpTm90ZSlcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coZXZlbnQubWlkaU5vdGVJZCwgZXZlbnQudHlwZSlcbiAgICAgICAgICAgIC8vdGhpcy5fbm90ZXMucHVzaChldmVudC5taWRpTm90ZSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICB0aGlzLl9ub3RlcyA9IEFycmF5LmZyb20odGhpcy5fbm90ZXNCeUlkLnZhbHVlcygpKVxuICAgIH1cbiAgICBjb25zb2xlLnRpbWVFbmQoJ3BhcnNlJylcblxuICAgIGlmKGNyZWF0ZUV2ZW50QXJyYXkpe1xuICAgICAgY29uc29sZS50aW1lKCd0byBhcnJheScpXG4gICAgICB0aGlzLl9ldmVudHMgPSBBcnJheS5mcm9tKHRoaXMuX2V2ZW50c0J5SWQudmFsdWVzKCkpXG4gICAgICB0aGlzLl9ub3RlcyA9IEFycmF5LmZyb20odGhpcy5fbm90ZXNCeUlkLnZhbHVlcygpKVxuICAgICAgY29uc29sZS50aW1lRW5kKCd0byBhcnJheScpXG4gICAgfVxuXG4gICAgY29uc29sZS50aW1lKGBzb3J0aW5nICR7dGhpcy5fZXZlbnRzLmxlbmd0aH0gZXZlbnRzYClcbiAgICBzb3J0RXZlbnRzKHRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ub3Rlcy5zb3J0KGZ1bmN0aW9uKGEsIGIpe1xuICAgICAgcmV0dXJuIGEubm90ZU9uLnRpY2tzIC0gYi5ub3RlT24udGlja3NcbiAgICB9KVxuICAgIGNvbnNvbGUudGltZUVuZChgc29ydGluZyAke3RoaXMuX2V2ZW50cy5sZW5ndGh9IGV2ZW50c2ApXG5cbiAgICBjb25zb2xlLmxvZygnbm90ZXMgJU8nLCB0aGlzLl9ub3RlcylcblxuICAgIGNvbnNvbGUudGltZUVuZCgndG90YWwnKVxuICAgIGNvbnNvbGUuZ3JvdXBFbmQoJ3VwZGF0ZSBzb25nJylcbiAgICBjb25zb2xlLnRpbWVFbmQoJ3VwZGF0ZSBzb25nJylcblxuICAgIGxldCBsYXN0RXZlbnQgPSB0aGlzLl9ldmVudHNbdGhpcy5fZXZlbnRzLmxlbmd0aCAtIDFdXG4gICAgbGV0IGxhc3RUaW1lRXZlbnQgPSB0aGlzLl90aW1lRXZlbnRzW3RoaXMuX3RpbWVFdmVudHMubGVuZ3RoIC0gMV1cbiAgICBpZihsYXN0VGltZUV2ZW50LnRpY2tzID4gbGFzdFRpbWVFdmVudC50aWNrcyl7XG4gICAgICBsYXN0VGltZUV2ZW50ID0gbGFzdFRpbWVFdmVudFxuICAgIH1cbiAgICAoe1xuICAgICAgYmFyOiB0aGlzLl9sYXN0RXZlbnQuYmFyLFxuICAgICAgYmVhdDogdGhpcy5fbGFzdEV2ZW50LmJlYXQsXG4gICAgICBzaXh0ZWVudGg6IHRoaXMuX2xhc3RFdmVudC5zaXh0ZWVudGgsXG4gICAgICB0aWNrOiB0aGlzLl9sYXN0RXZlbnQudGljayxcbiAgICAgIHRpY2tzOiB0aGlzLl9sYXN0RXZlbnQudGlja3MsXG4gICAgICBtaWxsaXM6IHRoaXMuX2xhc3RFdmVudC5taWxsaXMsXG4gICAgfSA9IGxhc3RFdmVudClcbiAgICAvL2NvbnNvbGUubG9nKCdsYXN0IHRpY2snLCBsYXN0VGlja3MpXG4gICAgdGhpcy5fZHVyYXRpb25UaWNrcyA9IHRoaXMuX2xhc3RFdmVudC50aWNrc1xuICAgIHRoaXMuX2R1cmF0aW9uTWlsbGlzID0gdGhpcy5fbGFzdEV2ZW50Lm1pbGxpc1xuXG4gICAgdGhpcy5fcGxheWhlYWQudXBkYXRlU29uZygpXG4gIH1cblxuICBwbGF5KHR5cGUsIC4uLmFyZ3MpOiB2b2lke1xuICAgIHRoaXMuX3BsYXkodHlwZSwgLi4uYXJncylcbiAgICBkaXNwYXRjaEV2ZW50KHt0eXBlOiAncGxheScsIGRhdGE6IHRoaXMuX21pbGxpc30pXG4gIH1cblxuICBfcGxheSh0eXBlLCAuLi5hcmdzKXtcbiAgICBpZih0eXBlb2YgdHlwZSAhPT0gJ3VuZGVmaW5lZCcpe1xuICAgICAgdGhpcy5zZXRQb3NpdGlvbih0eXBlLCAuLi5hcmdzKVxuICAgIH1cbiAgICBpZih0aGlzLl9wbGF5aW5nKXtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuX3RpbWVTdGFtcCA9IGNvbnRleHQuY3VycmVudFRpbWUgKiAxMDAwXG4gICAgdGhpcy5fc2NoZWR1bGVyLnNldFRpbWVTdGFtcCh0aGlzLl90aW1lU3RhbXApXG5cbiAgICBpZih0aGlzLl9wYXVzZWQpe1xuICAgICAgdGhpcy5fcGF1c2VkID0gZmFsc2VcbiAgICB9XG5cbiAgICB0aGlzLl9wbGF5aW5nID0gdHJ1ZVxuICAgIHRoaXMuX3NjaGVkdWxlci5pbml0KHRoaXMuX21pbGxpcylcbiAgICB0aGlzLl9wbGF5aGVhZC5zZXQoJ21pbGxpcycsIHRoaXMuX21pbGxpcylcbiAgICB0aGlzLl9wdWxzZSgpXG4gIH1cblxuXG4gIHBhdXNlKCk6IHZvaWR7XG4gICAgdGhpcy5fcGF1c2VkID0gIXRoaXMuX3BhdXNlZFxuICAgIGlmKHRoaXMuX3BhdXNlZCl7XG4gICAgICB0aGlzLl9wbGF5aW5nID0gZmFsc2VcbiAgICAgIHRoaXMuX3NjaGVkdWxlci5hbGxOb3Rlc09mZigpXG4gICAgICBkaXNwYXRjaEV2ZW50KHt0eXBlOiAncGF1c2UnLCBkYXRhOiB0aGlzLl9wYXVzZWR9KVxuICAgIH1lbHNle1xuICAgICAgdGhpcy5wbGF5KClcbiAgICAgIGRpc3BhdGNoRXZlbnQoe3R5cGU6ICdwYXVzZScsIGRhdGE6IHRoaXMuX3BhdXNlZH0pXG4gICAgfVxuICB9XG5cbiAgc3RvcCgpOiB2b2lke1xuICAgIHRoaXMuX3NjaGVkdWxlci5hbGxOb3Rlc09mZigpXG4gICAgaWYodGhpcy5fcGxheWluZyB8fCB0aGlzLl9wYXVzZWQpe1xuICAgICAgdGhpcy5fcGxheWluZyA9IGZhbHNlXG4gICAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZVxuICAgIH1cbiAgICBpZih0aGlzLl9taWxsaXMgIT09IDApe1xuICAgICAgdGhpcy5fbWlsbGlzID0gMFxuICAgICAgdGhpcy5fcGxheWhlYWQuc2V0KCdtaWxsaXMnLCB0aGlzLl9taWxsaXMpXG4gICAgICBkaXNwYXRjaEV2ZW50KHt0eXBlOiAnc3RvcCd9KVxuICAgIH1cbiAgfVxuXG4gIGFsbE5vdGVzT2ZmKCl7XG4gICAgdGhpcy5fc2NoZWR1bGVyLmFsbE5vdGVzT2ZmKClcbiAgfVxuXG4gIGdldFRyYWNrcygpe1xuICAgIHJldHVybiBbLi4udGhpcy5fdHJhY2tzXVxuICB9XG5cbiAgZ2V0UGFydHMoKXtcbiAgICByZXR1cm4gWy4uLnRoaXMuX3BhcnRzXVxuICB9XG5cbiAgZ2V0RXZlbnRzKCl7XG4gICAgcmV0dXJuIFsuLi50aGlzLl9ldmVudHNdXG4gIH1cblxuICBnZXROb3Rlcygpe1xuICAgIHJldHVybiBbLi4udGhpcy5fbm90ZXNdXG4gIH1cblxuICBjYWxjdWxhdGVQb3NpdGlvbihhcmdzKXtcbiAgICByZXR1cm4gY2FsY3VsYXRlUG9zaXRpb24odGhpcywgYXJncylcbiAgfVxuXG4gIC8qXG4gICAgcG9zaXRpb246XG4gICAgICAtICd0aWNrcycsIDk2MDAwXG4gICAgICAtICdtaWxsaXMnLCAxMjM0XG4gICAgICAtICdwZXJjZW50YWdlJywgNTVcbiAgICAgIC0gJ2JhcnNiZWF0cycsIDEsIDQsIDAsIDI1IC0+IGJhciwgYmVhdCwgc2l4dGVlbnRoLCB0aWNrXG4gICAgICAtICd0aW1lJywgMCwgMywgNDksIDU2NiAtPiBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzXG4gICovXG4gIHNldFBvc2l0aW9uKHR5cGUsIC4uLmFyZ3Mpe1xuXG4gICAgbGV0IHdhc1BsYXlpbmcgPSB0aGlzLl9wbGF5aW5nXG4gICAgaWYodGhpcy5fcGxheWluZyl7XG4gICAgICB0aGlzLl9wbGF5aW5nID0gZmFsc2VcbiAgICAgIHRoaXMuX3NjaGVkdWxlci5hbGxOb3Rlc09mZigpXG4gICAgfVxuXG4gICAgbGV0IHRhcmdldFxuICAgIGxldCBwb3NpdGlvblxuXG4gICAgc3dpdGNoKHR5cGUpe1xuICAgICAgY2FzZSAndGlja3MnOlxuICAgICAgY2FzZSAnbWlsbGlzJzpcbiAgICAgIGNhc2UgJ3BlcmNlbnRhZ2UnOlxuICAgICAgICB0YXJnZXQgPSBhcmdzWzBdIHx8IDBcbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSAndGltZSc6XG4gICAgICBjYXNlICdiYXJzYmVhdHMnOlxuICAgICAgY2FzZSAnYmFyc2FuZGJlYXRzJzpcbiAgICAgICAgdGFyZ2V0ID0gYXJnc1xuICAgICAgICBicmVha1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjb25zb2xlLmxvZygndW5zdXBwb3J0ZWQgdHlwZScpXG4gICAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIG1pbGxpcyA9IGNhbGN1bGF0ZVBvc2l0aW9uKHRoaXMsIHtcbiAgICAvLyAgIHR5cGUsXG4gICAgLy8gICB0YXJnZXQsXG4gICAgLy8gICByZXN1bHQ6ICdtaWxsaXMnXG4gICAgLy8gfSkubWlsbGlzXG5cbiAgICBwb3NpdGlvbiA9IGNhbGN1bGF0ZVBvc2l0aW9uKHRoaXMsIHtcbiAgICAgIHR5cGUsXG4gICAgICB0YXJnZXQsXG4gICAgICByZXN1bHQ6ICdhbGwnXG4gICAgfSlcblxuICAgIHRoaXMuX21pbGxpcyA9IHBvc2l0aW9uLm1pbGxpc1xuXG4gICAgZGlzcGF0Y2hFdmVudCh7XG4gICAgICB0eXBlOiAncG9zaXRpb24nLFxuICAgICAgZGF0YTogcG9zaXRpb25cbiAgICB9KVxuXG4gICAgaWYod2FzUGxheWluZyl7XG4gICAgICB0aGlzLl9wbGF5KClcbiAgICB9XG4gICAgLy9jb25zb2xlLmxvZygnc2V0UG9zaXRpb24nLCB0aGlzLl9taWxsaXMpXG4gIH1cblxuICBnZXRQb3NpdGlvbigpe1xuICAgIHJldHVybiB0aGlzLl9wbGF5aGVhZC5nZXQoKS5wb3NpdGlvblxuICB9XG5cbiAgZ2V0UGxheWhlYWQoKXtcbiAgICByZXR1cm4gdGhpcy5fcGxheWhlYWQuZ2V0KClcbiAgfVxuXG4gIF9wdWxzZSgpOiB2b2lke1xuICAgIGlmKHRoaXMuX3BsYXlpbmcgPT09IGZhbHNlKXtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBsZXQgbm93ID0gY29udGV4dC5jdXJyZW50VGltZSAqIDEwMDBcbiAgICBsZXQgZGlmZiA9IG5vdyAtIHRoaXMuX3RpbWVTdGFtcFxuICAgIHRoaXMuX21pbGxpcyArPSBkaWZmXG4gICAgdGhpcy5fdGltZVN0YW1wID0gbm93XG4gICAgLy9jb25zb2xlLmxvZyhkaWZmLCB0aGlzLm1pbGxpcylcblxuICAgIHRoaXMuX3BsYXloZWFkLnVwZGF0ZSgnbWlsbGlzJywgZGlmZilcblxuICAgIGlmKHRoaXMuX21pbGxpcyA+PSB0aGlzLl9kdXJhdGlvbk1pbGxpcyl7XG4gICAgICB0aGlzLnN0b3AoKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5fc2NoZWR1bGVyLnVwZGF0ZSh0aGlzLl9taWxsaXMpXG5cbiAgICAvL2NvbnNvbGUubG9nKCdwdWxzZScsIGRpZmYpXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuX3B1bHNlLmJpbmQodGhpcykpXG4gIH1cblxuICBhZGRFdmVudExpc3RlbmVyKHR5cGUsIGNhbGxiYWNrKXtcbiAgICByZXR1cm4gYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBjYWxsYmFjaylcbiAgfVxuXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaWQpe1xuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaWQpXG4gIH1cbn1cbiIsIlxuaW1wb3J0IGZldGNoIGZyb20gJ2lzb21vcnBoaWMtZmV0Y2gnXG5pbXBvcnQge3BhcnNlTUlESUZpbGV9IGZyb20gJy4vbWlkaWZpbGUnXG5pbXBvcnQge01JRElFdmVudH0gZnJvbSAnLi9taWRpX2V2ZW50J1xuaW1wb3J0IHtQYXJ0fSBmcm9tICcuL3BhcnQnXG5pbXBvcnQge1RyYWNrfSBmcm9tICcuL3RyYWNrJ1xuaW1wb3J0IHtTb25nfSBmcm9tICcuL3NvbmcnXG5pbXBvcnQge2Jhc2U2NFRvQmluYXJ5fSBmcm9tICcuL3V0aWwnXG5pbXBvcnQge3N0YXR1cywganNvbiwgYXJyYXlCdWZmZXJ9IGZyb20gJy4vZmV0Y2hfaGVscGVycydcblxuY29uc3QgUFBRID0gOTYwXG5cblxuZnVuY3Rpb24gdG9Tb25nKHBhcnNlZCl7XG4gIGxldCB0cmFja3MgPSBwYXJzZWQudHJhY2tzXG4gIGxldCBwcHEgPSBwYXJzZWQuaGVhZGVyLnRpY2tzUGVyQmVhdFxuICBsZXQgcHBxRmFjdG9yID0gUFBRIC8gcHBxIC8vQFRPRE86IGdldCBwcHEgZnJvbSBjb25maWcgLT4gb25seSBuZWNlc3NhcnkgaWYgeW91IHdhbnQgdG8gY2hhbmdlIHRoZSBwcHEgb2YgdGhlIE1JREkgZmlsZSAhXG4gIGxldCB0aW1lRXZlbnRzID0gW11cbiAgbGV0IGJwbSA9IC0xXG4gIGxldCBub21pbmF0b3IgPSAtMVxuICBsZXQgZGVub21pbmF0b3IgPSAtMVxuICBsZXQgbmV3VHJhY2tzID0gW11cblxuICBmb3IobGV0IHRyYWNrIG9mIHRyYWNrcy52YWx1ZXMoKSl7XG4gICAgbGV0IGxhc3RUaWNrcywgbGFzdFR5cGVcbiAgICBsZXQgdGlja3MgPSAwXG4gICAgbGV0IHR5cGVcbiAgICBsZXQgY2hhbm5lbCA9IC0xXG4gICAgbGV0IHRyYWNrTmFtZVxuICAgIGxldCB0cmFja0luc3RydW1lbnROYW1lXG4gICAgbGV0IGV2ZW50cyA9IFtdO1xuXG4gICAgZm9yKGxldCBldmVudCBvZiB0cmFjayl7XG4gICAgICB0aWNrcyArPSAoZXZlbnQuZGVsdGFUaW1lICogcHBxRmFjdG9yKTtcblxuICAgICAgaWYoY2hhbm5lbCA9PT0gLTEgJiYgdHlwZW9mIGV2ZW50LmNoYW5uZWwgIT09ICd1bmRlZmluZWQnKXtcbiAgICAgICAgY2hhbm5lbCA9IGV2ZW50LmNoYW5uZWw7XG4gICAgICB9XG4gICAgICB0eXBlID0gZXZlbnQuc3VidHlwZTtcbiAgICAgIC8vY29uc29sZS5sb2coZXZlbnQuZGVsdGFUaW1lLCB0aWNrcywgdHlwZSk7XG5cbiAgICAgIHN3aXRjaChldmVudC5zdWJ0eXBlKXtcblxuICAgICAgICBjYXNlICd0cmFja05hbWUnOlxuICAgICAgICAgIHRyYWNrTmFtZSA9IGV2ZW50LnRleHQ7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnaW5zdHJ1bWVudE5hbWUnOlxuICAgICAgICAgIGlmKGV2ZW50LnRleHQpe1xuICAgICAgICAgICAgdHJhY2tJbnN0cnVtZW50TmFtZSA9IGV2ZW50LnRleHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ25vdGVPbic6XG4gICAgICAgICAgZXZlbnRzLnB1c2gobmV3IE1JRElFdmVudCh0aWNrcywgMHg5MCwgZXZlbnQubm90ZU51bWJlciwgZXZlbnQudmVsb2NpdHkpKVxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ25vdGVPZmYnOlxuICAgICAgICAgIGV2ZW50cy5wdXNoKG5ldyBNSURJRXZlbnQodGlja3MsIDB4ODAsIGV2ZW50Lm5vdGVOdW1iZXIsIGV2ZW50LnZlbG9jaXR5KSlcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdzZXRUZW1wbyc6XG4gICAgICAgICAgLy8gc29tZXRpbWVzIDIgdGVtcG8gZXZlbnRzIGhhdmUgdGhlIHNhbWUgcG9zaXRpb24gaW4gdGlja3NcbiAgICAgICAgICAvLyB3ZSB1c2UgdGhlIGxhc3QgaW4gdGhlc2UgY2FzZXMgKHNhbWUgYXMgQ3ViYXNlKVxuICAgICAgICAgIGxldCB0bXAgPSA2MDAwMDAwMCAvIGV2ZW50Lm1pY3Jvc2Vjb25kc1BlckJlYXQ7XG5cbiAgICAgICAgICBpZih0aWNrcyA9PT0gbGFzdFRpY2tzICYmIHR5cGUgPT09IGxhc3RUeXBlKXtcbiAgICAgICAgICAgIC8vY29uc29sZS5pbmZvKCd0ZW1wbyBldmVudHMgb24gdGhlIHNhbWUgdGljaycsIHRpY2tzLCB0bXApO1xuICAgICAgICAgICAgdGltZUV2ZW50cy5wb3AoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZihicG0gPT09IC0xKXtcbiAgICAgICAgICAgIGJwbSA9IHRtcDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGltZUV2ZW50cy5wdXNoKG5ldyBNSURJRXZlbnQodGlja3MsIDB4NTEsIHRtcCkpXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAndGltZVNpZ25hdHVyZSc6XG4gICAgICAgICAgLy8gc29tZXRpbWVzIDIgdGltZSBzaWduYXR1cmUgZXZlbnRzIGhhdmUgdGhlIHNhbWUgcG9zaXRpb24gaW4gdGlja3NcbiAgICAgICAgICAvLyB3ZSB1c2UgdGhlIGxhc3QgaW4gdGhlc2UgY2FzZXMgKHNhbWUgYXMgQ3ViYXNlKVxuICAgICAgICAgIGlmKGxhc3RUaWNrcyA9PT0gdGlja3MgJiYgbGFzdFR5cGUgPT09IHR5cGUpe1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKCd0aW1lIHNpZ25hdHVyZSBldmVudHMgb24gdGhlIHNhbWUgdGljaycsIHRpY2tzLCBldmVudC5udW1lcmF0b3IsIGV2ZW50LmRlbm9taW5hdG9yKTtcbiAgICAgICAgICAgIHRpbWVFdmVudHMucG9wKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYobm9taW5hdG9yID09PSAtMSl7XG4gICAgICAgICAgICBub21pbmF0b3IgPSBldmVudC5udW1lcmF0b3JcbiAgICAgICAgICAgIGRlbm9taW5hdG9yID0gZXZlbnQuZGVub21pbmF0b3JcbiAgICAgICAgICB9XG4gICAgICAgICAgdGltZUV2ZW50cy5wdXNoKG5ldyBNSURJRXZlbnQodGlja3MsIDB4NTgsIGV2ZW50Lm51bWVyYXRvciwgZXZlbnQuZGVub21pbmF0b3IpKVxuICAgICAgICAgIGJyZWFrO1xuXG5cbiAgICAgICAgY2FzZSAnY29udHJvbGxlcic6XG4gICAgICAgICAgZXZlbnRzLnB1c2gobmV3IE1JRElFdmVudCh0aWNrcywgMHhCMCwgZXZlbnQuY29udHJvbGxlclR5cGUsIGV2ZW50LnZhbHVlKSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAncHJvZ3JhbUNoYW5nZSc6XG4gICAgICAgICAgZXZlbnRzLnB1c2gobmV3IE1JRElFdmVudCh0aWNrcywgMHhDMCwgZXZlbnQucHJvZ3JhbU51bWJlcikpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3BpdGNoQmVuZCc6XG4gICAgICAgICAgZXZlbnRzLnB1c2gobmV3IE1JRElFdmVudCh0aWNrcywgMHhFMCwgZXZlbnQudmFsdWUpKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIC8vY29uc29sZS5sb2codHJhY2submFtZSwgZXZlbnQudHlwZSk7XG4gICAgICB9XG5cbiAgICAgIGxhc3RUeXBlID0gdHlwZVxuICAgICAgbGFzdFRpY2tzID0gdGlja3NcbiAgICB9XG5cbiAgICBpZihldmVudHMubGVuZ3RoID4gMCl7XG4gICAgICAvL2NvbnNvbGUuY291bnQoZXZlbnRzLmxlbmd0aClcbiAgICAgIGxldCBuZXdUcmFjayA9IG5ldyBUcmFjayh0cmFja05hbWUpXG4gICAgICBsZXQgcGFydCA9IG5ldyBQYXJ0KClcbiAgICAgIG5ld1RyYWNrLmFkZFBhcnRzKHBhcnQpXG4gICAgICBwYXJ0LmFkZEV2ZW50cyguLi5ldmVudHMpXG4gICAgICBuZXdUcmFja3MucHVzaChuZXdUcmFjaylcbiAgICB9XG4gIH1cblxuICBsZXQgc29uZyA9IG5ldyBTb25nKHtcbiAgICBwcHE6IFBQUSxcbiAgICBwbGF5YmFja1NwZWVkOiAxLFxuICAgIC8vcHBxLFxuICAgIGJwbSxcbiAgICBub21pbmF0b3IsXG4gICAgZGVub21pbmF0b3JcbiAgfSlcbiAgc29uZy5hZGRUcmFja3MoLi4ubmV3VHJhY2tzKVxuICBzb25nLmFkZFRpbWVFdmVudHMoLi4udGltZUV2ZW50cylcbiAgc29uZy51cGRhdGUoKVxuICByZXR1cm4gc29uZ1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc29uZ0Zyb21NSURJRmlsZShkYXRhLCBzZXR0aW5ncyA9IHt9KXtcbiAgbGV0IHNvbmcgPSBudWxsO1xuXG4gIGlmKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciA9PT0gdHJ1ZSl7XG4gICAgbGV0IGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICAgIHNvbmcgPSB0b1NvbmcocGFyc2VNSURJRmlsZShidWZmZXIpKTtcbiAgfWVsc2UgaWYodHlwZW9mIGRhdGEuaGVhZGVyICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZGF0YS50cmFja3MgIT09ICd1bmRlZmluZWQnKXtcbiAgICBzb25nID0gdG9Tb25nKGRhdGEpO1xuICB9ZWxzZXtcbiAgICBkYXRhID0gYmFzZTY0VG9CaW5hcnkoZGF0YSk7XG4gICAgaWYoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyID09PSB0cnVlKXtcbiAgICAgIGxldCBidWZmZXIgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgICAgIHNvbmcgPSB0b1NvbmcocGFyc2VNSURJRmlsZShidWZmZXIpKTtcbiAgICB9ZWxzZXtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ3dyb25nIGRhdGEnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc29uZ1xuICAvLyB7XG4gIC8vICAgcHBxID0gbmV3UFBRLFxuICAvLyAgIGJwbSA9IG5ld0JQTSxcbiAgLy8gICBwbGF5YmFja1NwZWVkID0gbmV3UGxheWJhY2tTcGVlZCxcbiAgLy8gfSA9IHNldHRpbmdzXG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIHNvbmdGcm9tTUlESUZpbGVBc3luYyh1cmwpe1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGZldGNoKHVybClcbiAgICAudGhlbihzdGF0dXMpXG4gICAgLnRoZW4oYXJyYXlCdWZmZXIpXG4gICAgLnRoZW4oZGF0YSA9PiB7XG4gICAgICByZXNvbHZlKHNvbmdGcm9tTUlESUZpbGUoZGF0YSkpXG4gICAgfSlcbiAgICAuY2F0Y2goZSA9PiB7XG4gICAgICByZWplY3QoZSlcbiAgICB9KVxuICB9KVxufVxuIiwiaW1wb3J0IHtQYXJ0fSBmcm9tICcuL3BhcnQnXG5pbXBvcnQge3NvcnRFdmVudHN9IGZyb20gJy4vdXRpbCdcbmltcG9ydCB7Y29udGV4dCwgbWFzdGVyR2Fpbn0gZnJvbSAnLi9pbml0X2F1ZGlvJ1xuaW1wb3J0IHtJbnN0cnVtZW50fSBmcm9tICcuL2luc3RydW1lbnQnXG5cblxubGV0IHRyYWNrSW5kZXggPSAwXG5cbmV4cG9ydCBjbGFzcyBUcmFja3tcblxuICBjb25zdHJ1Y3RvcihuYW1lOiBzdHJpbmcgPSBudWxsKXtcbiAgICB0aGlzLmlkID0gYFRSXyR7dHJhY2tJbmRleCsrfV8ke25ldyBEYXRlKCkuZ2V0VGltZSgpfWBcbiAgICB0aGlzLm5hbWUgPSBuYW1lIHx8IHRoaXMuaWRcbiAgICB0aGlzLmNoYW5uZWwgPSAwXG4gICAgdGhpcy5tdXRlZCA9IGZhbHNlXG4gICAgdGhpcy52b2x1bWUgPSAwLjVcbiAgICB0aGlzLl9vdXRwdXQgPSBjb250ZXh0LmNyZWF0ZUdhaW4oKVxuICAgIHRoaXMuX291dHB1dC5nYWluLnZhbHVlID0gdGhpcy52b2x1bWVcbiAgICB0aGlzLl9vdXRwdXQuY29ubmVjdChtYXN0ZXJHYWluKVxuICAgIHRoaXMuX21pZGlPdXRwdXRJZHMgPSBbXVxuICAgIHRoaXMuX3NvbmcgPSBudWxsXG4gICAgdGhpcy5fcGFydHMgPSBbXVxuICAgIHRoaXMuX3BhcnRzQnlJZCA9IG5ldyBNYXAoKVxuICAgIHRoaXMuX2V2ZW50cyA9IFtdXG4gICAgdGhpcy5fZXZlbnRzQnlJZCA9IG5ldyBNYXAoKVxuICAgIHRoaXMuX25lZWRzVXBkYXRlID0gZmFsc2VcbiAgICB0aGlzLl9jcmVhdGVFdmVudEFycmF5ID0gZmFsc2VcbiAgICB0aGlzLnNldEluc3RydW1lbnQobmV3IEluc3RydW1lbnQoKSlcbiAgfVxuXG4gIHNldEluc3RydW1lbnQoaW5zdHJ1bWVudCl7XG4gICAgdGhpcy5faW5zdHJ1bWVudCA9IGluc3RydW1lbnRcbiAgICBpbnN0cnVtZW50LmNvbm5lY3QodGhpcy5fb3V0cHV0KVxuICB9XG5cbiAgc2V0TUlESU91dHB1dHMoLi4ub3V0cHV0SWRzKXtcbiAgICAvL2NvbnNvbGUubG9nKG91dHB1dElkcylcbiAgICB0aGlzLl9taWRpT3V0cHV0SWRzLnB1c2goLi4ub3V0cHV0SWRzKVxuICB9XG5cbiAgcmVtb3ZlTUlESU91dHB1dHMoLi4ub3V0cHV0cyl7XG4gICAgLy90aGlzLl9taWRpT3V0cHV0cyA9IHRoaXMuX21pZGlPdXRwdXRzLmZpbHRlciguLi5vdXRwdXRzKVxuICB9XG5cbiAgY29weSgpe1xuICAgIGxldCB0ID0gbmV3IFRyYWNrKHRoaXMubmFtZSArICdfY29weScpIC8vIGltcGxlbWVudCBnZXROYW1lT2ZDb3B5KCkgaW4gdXRpbCAoc2VlIGhlYXJ0YmVhdClcbiAgICBsZXQgcGFydHMgPSBbXVxuICAgIHRoaXMuX3BhcnRzLmZvckVhY2goZnVuY3Rpb24ocGFydCl7XG4gICAgICBsZXQgY29weSA9IHBhcnQuY29weSgpXG4gICAgICBjb25zb2xlLmxvZyhjb3B5KVxuICAgICAgcGFydHMucHVzaChjb3B5KVxuICAgIH0pXG4gICAgdC5hZGRQYXJ0cyguLi5wYXJ0cylcbiAgICB0LnVwZGF0ZSgpXG4gICAgcmV0dXJuIHRcbiAgfVxuXG4gIHRyYW5zcG9zZShhbW91bnQ6IG51bWJlcil7XG4gICAgdGhpcy5fZXZlbnRzLmZvckVhY2goKGV2ZW50KSA9PiB7XG4gICAgICBldmVudC50cmFuc3Bvc2UoYW1vdW50KVxuICAgIH0pXG4gIH1cblxuICBhZGRQYXJ0cyguLi5wYXJ0cyl7XG4gICAgbGV0IHNvbmcgPSB0aGlzLl9zb25nXG4gICAgcGFydHMuZm9yRWFjaCgocGFydCkgPT4ge1xuICAgICAgcGFydC5fdHJhY2sgPSB0aGlzXG4gICAgICB0aGlzLl9wYXJ0c0J5SWQuc2V0KHBhcnQuaWQsIHBhcnQpXG4gICAgICB0aGlzLl9wYXJ0cy5wdXNoKHBhcnQpXG4gICAgICBpZihzb25nKXtcbiAgICAgICAgcGFydC5fc29uZyA9IHNvbmdcbiAgICAgICAgc29uZy5fbmV3UGFydHMucHVzaChwYXJ0KVxuICAgICAgfVxuXG4gICAgICBsZXQgZXZlbnRzID0gcGFydC5fZXZlbnRzXG4gICAgICBldmVudHMuZm9yRWFjaCgoZXZlbnQpID0+IHtcbiAgICAgICAgZXZlbnQuX3RyYWNrID0gdGhpc1xuICAgICAgICBpZihzb25nKXtcbiAgICAgICAgICBldmVudC5fc29uZyA9IHNvbmdcbiAgICAgICAgICAvL3NvbmcuX25ld0V2ZW50cy5wdXNoKGV2ZW50KVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2V2ZW50c0J5SWQuc2V0KGV2ZW50LmlkLCBldmVudClcbiAgICAgIH0pXG4gICAgICB0aGlzLl9ldmVudHMucHVzaCguLi5ldmVudHMpXG4gICAgfSlcbiAgICB0aGlzLl9uZWVkc1VwZGF0ZSA9IHRydWVcbiAgfVxuXG4gIHJlbW92ZVBhcnRzKC4uLnBhcnRzKXtcbiAgICBsZXQgc29uZyA9IHRoaXMuX3NvbmdcblxuICAgIHBhcnRzLmZvckVhY2goKHBhcnQpID0+IHtcbiAgICAgIHBhcnQuX3RyYWNrID0gbnVsbFxuICAgICAgdGhpcy5fcGFydHNCeUlkLmRlbGV0ZShwYXJ0LmlkLCBwYXJ0KVxuICAgICAgaWYoc29uZyl7XG4gICAgICAgIHNvbmcuX2RlbGV0ZWRQYXJ0cy5wdXNoKHBhcnQpXG4gICAgICB9XG5cbiAgICAgIGxldCBldmVudHMgPSBwYXJ0Ll9ldmVudHNcbiAgICAgIGV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGV2ZW50KXtcbiAgICAgICAgZXZlbnQuX3RyYWNrID0gbnVsbFxuICAgICAgICBpZihzb25nKXtcbiAgICAgICAgICBldmVudC5fc29uZyA9IG51bGxcbiAgICAgICAgICAvL3NvbmcuX2RlbGV0ZWRFdmVudHMucHVzaChldmVudClcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9ldmVudHNCeUlkLmRlbGV0ZShldmVudC5pZCwgZXZlbnQpXG4gICAgICB9KVxuICAgIH0pXG4gICAgdGhpcy5fbmVlZHNVcGRhdGUgPSB0cnVlXG4gICAgdGhpcy5fY3JlYXRlRXZlbnRBcnJheSA9IHRydWVcbiAgfVxuXG4gIGdldFBhcnRzKCl7XG4gICAgaWYodGhpcy5fbmVlZHNVcGRhdGUpe1xuICAgICAgdGhpcy5fcGFydHMgPSBBcnJheS5mcm9tKHRoaXMuX3BhcnRzQnlJZC52YWx1ZXMoKSlcbiAgICAgIHRoaXMuX2V2ZW50cyA9IEFycmF5LmZyb20odGhpcy5fZXZlbnRzQnlJZC52YWx1ZXMoKSlcbiAgICAgIHRoaXMuX25lZWRzVXBkYXRlID0gZmFsc2VcbiAgICB9XG4gICAgcmV0dXJuIFsuLi50aGlzLl9wYXJ0c11cbiAgfVxuXG5cbiAgdHJhbnNwb3NlUGFydHMoYW1vdW50OiBudW1iZXIsIC4uLnBhcnRzKXtcbiAgICBwYXJ0cy5mb3JFYWNoKGZ1bmN0aW9uKHBhcnQpe1xuICAgICAgcGFydC50cmFuc3Bvc2UoYW1vdW50KVxuICAgIH0pXG4gIH1cblxuICBtb3ZlUGFydHModGlja3M6IG51bWJlciwgLi4ucGFydHMpe1xuICAgIHBhcnRzLmZvckVhY2goZnVuY3Rpb24ocGFydCl7XG4gICAgICBwYXJ0Lm1vdmUodGlja3MpXG4gICAgfSlcbiAgfVxuXG4gIG1vdmVQYXJ0c1RvKHRpY2tzOiBudW1iZXIsIC4uLnBhcnRzKXtcbiAgICBwYXJ0cy5mb3JFYWNoKGZ1bmN0aW9uKHBhcnQpe1xuICAgICAgcGFydC5tb3ZlVG8odGlja3MpXG4gICAgfSlcbiAgfVxuXG4gIGFkZEV2ZW50cyguLi5ldmVudHMpe1xuICAgIGxldCBwID0gbmV3IFBhcnQoKVxuICAgIHAuYWRkRXZlbnRzKC4uLmV2ZW50cylcbiAgICB0aGlzLmFkZFBhcnRzKHApXG4gIH1cblxuICByZW1vdmVFdmVudHMoLi4uZXZlbnRzKXtcbiAgICBsZXQgcGFydHMgPSBuZXcgU2V0KClcbiAgICBldmVudHMuZm9yRWFjaCgoZXZlbnQpID0+IHtcbiAgICAgIHBhcnRzLnNldChldmVudC5fcGFydClcbiAgICAgIGV2ZW50Ll9wYXJ0ID0gbnVsbFxuICAgICAgZXZlbnQuX3RyYWNrID0gbnVsbFxuICAgICAgZXZlbnQuX3NvbmcgPSBudWxsXG4gICAgICB0aGlzLl9ldmVudHNCeUlkLmRlbGV0ZShldmVudC5pZClcbiAgICB9KVxuICAgIGlmKHRoaXMuX3Nvbmcpe1xuICAgICAgdGhpcy5fc29uZy5fY2hhbmdlZFBhcnRzLnB1c2goLi4uQXJyYXkuZnJvbShwYXJ0cy5lbnRyaWVzKCkpKVxuICAgICAgdGhpcy5fc29uZy5fcmVtb3ZlZEV2ZW50cy5wdXNoKC4uLmV2ZW50cylcbiAgICB9XG4gICAgdGhpcy5fbmVlZHNVcGRhdGUgPSB0cnVlXG4gICAgdGhpcy5fY3JlYXRlRXZlbnRBcnJheSA9IHRydWVcbiAgfVxuXG4gIG1vdmVFdmVudHModGlja3M6IG51bWJlciwgLi4uZXZlbnRzKXtcbiAgICBsZXQgcGFydHMgPSBuZXcgU2V0KClcbiAgICBldmVudHMuZm9yRWFjaCgoZXZlbnQpID0+IHtcbiAgICAgIGV2ZW50Lm1vdmUodGlja3MpXG4gICAgICBwYXJ0cy5zZXQoZXZlbnQucGFydClcbiAgICB9KVxuICAgIGlmKHRoaXMuX3Nvbmcpe1xuICAgICAgdGhpcy5fc29uZy5fY2hhbmdlZFBhcnRzLnB1c2goLi4uQXJyYXkuZnJvbShwYXJ0cy5lbnRyaWVzKCkpKVxuICAgICAgdGhpcy5fc29uZy5fbW92ZWRFdmVudHMucHVzaCguLi5ldmVudHMpXG4gICAgfVxuICB9XG5cbiAgbW92ZUV2ZW50c1RvKHRpY2tzOiBudW1iZXIsIC4uLmV2ZW50cyl7XG4gICAgbGV0IHBhcnRzID0gbmV3IFNldCgpXG4gICAgZXZlbnRzLmZvckVhY2goKGV2ZW50KSA9PiB7XG4gICAgICBldmVudC5tb3ZlVG8odGlja3MpXG4gICAgICBwYXJ0cy5zZXQoZXZlbnQucGFydClcbiAgICB9KVxuICAgIGlmKHRoaXMuX3Nvbmcpe1xuICAgICAgdGhpcy5fc29uZy5fY2hhbmdlZFBhcnRzLnB1c2goLi4uQXJyYXkuZnJvbShwYXJ0cy5lbnRyaWVzKCkpKVxuICAgICAgdGhpcy5fc29uZy5fbW92ZWRFdmVudHMucHVzaCguLi5ldmVudHMpXG4gICAgfVxuICB9XG5cbiAgZ2V0RXZlbnRzKGZpbHRlcjogc3RyaW5nW10gPSBudWxsKXsgLy8gY2FuIGJlIHVzZSBhcyBmaW5kRXZlbnRzXG4gICAgaWYodGhpcy5fbmVlZHNVcGRhdGUpe1xuICAgICAgdGhpcy51cGRhdGUoKVxuICAgIH1cbiAgICByZXR1cm4gWy4uLnRoaXMuX2V2ZW50c10gLy9AVE9ETyBpbXBsZW1lbnQgZmlsdGVyIC0+IGZpbHRlckV2ZW50cygpIHNob3VsZCBiZSBhIHV0aWxpdHkgZnVuY3Rpb24gKG5vdCBhIGNsYXNzIG1ldGhvZClcbiAgfVxuXG4gIG11dGUoZmxhZzogYm9vbGVhbiA9IG51bGwpe1xuICAgIGlmKGZsYWcpe1xuICAgICAgdGhpcy5fbXV0ZWQgPSBmbGFnXG4gICAgfWVsc2V7XG4gICAgICB0aGlzLl9tdXRlZCA9ICF0aGlzLl9tdXRlZFxuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZSgpeyAvLyB5b3Ugc2hvdWxkIG9ubHkgdXNlIHRoaXMgaW4gaHVnZSBzb25ncyAoPjEwMCB0cmFja3MpXG4gICAgaWYodGhpcy5fY3JlYXRlRXZlbnRBcnJheSl7XG4gICAgICB0aGlzLl9ldmVudHMgPSBBcnJheS5mcm9tKHRoaXMuX2V2ZW50c0J5SWQudmFsdWVzKCkpXG4gICAgICB0aGlzLl9jcmVhdGVFdmVudEFycmF5ID0gZmFsc2VcbiAgICB9XG4gICAgc29ydEV2ZW50cyh0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fbmVlZHNVcGRhdGUgPSBmYWxzZVxuICB9XG59XG5cbiIsImltcG9ydCBmZXRjaCBmcm9tICdpc29tb3JwaGljLWZldGNoJ1xuXG5jb25zdFxuICBtUEkgPSBNYXRoLlBJLFxuICBtUG93ID0gTWF0aC5wb3csXG4gIG1Sb3VuZCA9IE1hdGgucm91bmQsXG4gIG1GbG9vciA9IE1hdGguZmxvb3IsXG4gIG1SYW5kb20gPSBNYXRoLnJhbmRvbVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXROaWNlVGltZShtaWxsaXMpe1xuICBsZXQgaCwgbSwgcywgbXMsXG4gICAgc2Vjb25kcyxcbiAgICB0aW1lQXNTdHJpbmcgPSAnJztcblxuICBzZWNvbmRzID0gbWlsbGlzIC8gMTAwMDsgLy8g4oaSIG1pbGxpcyB0byBzZWNvbmRzXG4gIGggPSBtRmxvb3Ioc2Vjb25kcyAvICg2MCAqIDYwKSk7XG4gIG0gPSBtRmxvb3IoKHNlY29uZHMgJSAoNjAgKiA2MCkpIC8gNjApO1xuICBzID0gbUZsb29yKHNlY29uZHMgJSAoNjApKTtcbiAgbXMgPSBtUm91bmQoKHNlY29uZHMgLSAoaCAqIDM2MDApIC0gKG0gKiA2MCkgLSBzKSAqIDEwMDApO1xuXG4gIHRpbWVBc1N0cmluZyArPSBoICsgJzonO1xuICB0aW1lQXNTdHJpbmcgKz0gbSA8IDEwID8gJzAnICsgbSA6IG07XG4gIHRpbWVBc1N0cmluZyArPSAnOic7XG4gIHRpbWVBc1N0cmluZyArPSBzIDwgMTAgPyAnMCcgKyBzIDogcztcbiAgdGltZUFzU3RyaW5nICs9ICc6JztcbiAgdGltZUFzU3RyaW5nICs9IG1zID09PSAwID8gJzAwMCcgOiBtcyA8IDEwID8gJzAwJyArIG1zIDogbXMgPCAxMDAgPyAnMCcgKyBtcyA6IG1zO1xuXG4gIC8vY29uc29sZS5sb2coaCwgbSwgcywgbXMpO1xuICByZXR1cm4ge1xuICAgIGhvdXI6IGgsXG4gICAgbWludXRlOiBtLFxuICAgIHNlY29uZDogcyxcbiAgICBtaWxsaXNlY29uZDogbXMsXG4gICAgdGltZUFzU3RyaW5nOiB0aW1lQXNTdHJpbmcsXG4gICAgdGltZUFzQXJyYXk6IFtoLCBtLCBzLCBtc11cbiAgfTtcbn1cblxuXG4vLyBhZGFwdGVkIHZlcnNpb24gb2YgaHR0cHM6Ly9naXRodWIuY29tL2Rhbmd1ZXIvYmxvZy1leGFtcGxlcy9ibG9iL21hc3Rlci9qcy9iYXNlNjQtYmluYXJ5LmpzXG5leHBvcnQgZnVuY3Rpb24gYmFzZTY0VG9CaW5hcnkoaW5wdXQpe1xuICBsZXQga2V5U3RyID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89JyxcbiAgICBieXRlcywgdWFycmF5LCBidWZmZXIsXG4gICAgbGtleTEsIGxrZXkyLFxuICAgIGNocjEsIGNocjIsIGNocjMsXG4gICAgZW5jMSwgZW5jMiwgZW5jMywgZW5jNCxcbiAgICBpLCBqID0gMDtcblxuICBieXRlcyA9IE1hdGguY2VpbCgoMyAqIGlucHV0Lmxlbmd0aCkgLyA0LjApO1xuICBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoYnl0ZXMpO1xuICB1YXJyYXkgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xuXG4gIGxrZXkxID0ga2V5U3RyLmluZGV4T2YoaW5wdXQuY2hhckF0KGlucHV0Lmxlbmd0aCAtIDEpKTtcbiAgbGtleTIgPSBrZXlTdHIuaW5kZXhPZihpbnB1dC5jaGFyQXQoaW5wdXQubGVuZ3RoIC0gMSkpO1xuICBpZihsa2V5MSA9PSA2NCkgYnl0ZXMtLTsgLy9wYWRkaW5nIGNoYXJzLCBzbyBza2lwXG4gIGlmKGxrZXkyID09IDY0KSBieXRlcy0tOyAvL3BhZGRpbmcgY2hhcnMsIHNvIHNraXBcblxuICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoL1teQS1aYS16MC05XFwrXFwvXFw9XS9nLCAnJyk7XG5cbiAgZm9yKGkgPSAwOyBpIDwgYnl0ZXM7IGkgKz0gMykge1xuICAgIC8vZ2V0IHRoZSAzIG9jdGVjdHMgaW4gNCBhc2NpaSBjaGFyc1xuICAgIGVuYzEgPSBrZXlTdHIuaW5kZXhPZihpbnB1dC5jaGFyQXQoaisrKSk7XG4gICAgZW5jMiA9IGtleVN0ci5pbmRleE9mKGlucHV0LmNoYXJBdChqKyspKTtcbiAgICBlbmMzID0ga2V5U3RyLmluZGV4T2YoaW5wdXQuY2hhckF0KGorKykpO1xuICAgIGVuYzQgPSBrZXlTdHIuaW5kZXhPZihpbnB1dC5jaGFyQXQoaisrKSk7XG5cbiAgICBjaHIxID0gKGVuYzEgPDwgMikgfCAoZW5jMiA+PiA0KTtcbiAgICBjaHIyID0gKChlbmMyICYgMTUpIDw8IDQpIHwgKGVuYzMgPj4gMik7XG4gICAgY2hyMyA9ICgoZW5jMyAmIDMpIDw8IDYpIHwgZW5jNDtcblxuICAgIHVhcnJheVtpXSA9IGNocjE7XG4gICAgaWYoZW5jMyAhPSA2NCkgdWFycmF5W2krMV0gPSBjaHIyO1xuICAgIGlmKGVuYzQgIT0gNjQpIHVhcnJheVtpKzJdID0gY2hyMztcbiAgfVxuICAvL2NvbnNvbGUubG9nKGJ1ZmZlcik7XG4gIHJldHVybiBidWZmZXI7XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIHR5cGVTdHJpbmcobyl7XG4gIGlmKHR5cGVvZiBvICE9ICdvYmplY3QnKXtcbiAgICByZXR1cm4gdHlwZW9mIG87XG4gIH1cblxuICBpZihvID09PSBudWxsKXtcbiAgICByZXR1cm4gJ251bGwnO1xuICB9XG5cbiAgLy9vYmplY3QsIGFycmF5LCBmdW5jdGlvbiwgZGF0ZSwgcmVnZXhwLCBzdHJpbmcsIG51bWJlciwgYm9vbGVhbiwgZXJyb3JcbiAgbGV0IGludGVybmFsQ2xhc3MgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykubWF0Y2goL1xcW29iamVjdFxccyhcXHcrKVxcXS8pWzFdO1xuICByZXR1cm4gaW50ZXJuYWxDbGFzcy50b0xvd2VyQ2FzZSgpO1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBzb3J0RXZlbnRzKGV2ZW50cyl7XG4gIGV2ZW50cy5zb3J0KGZ1bmN0aW9uKGEsIGIpe1xuICAgIGlmKGEudGlja3MgPT09IGIudGlja3Mpe1xuICAgICAgbGV0IHIgPSBhLnR5cGUgLSBiLnR5cGU7XG4gICAgICBpZihhLnR5cGUgPT09IDE3NiAmJiBiLnR5cGUgPT09IDE0NCl7XG4gICAgICAgIHIgPSAtMVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJcbiAgICB9XG4gICAgcmV0dXJuIGEudGlja3MgLSBiLnRpY2tzXG4gIH0pXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjaGVja0lmQmFzZTY0KGRhdGEpe1xuICBsZXQgcGFzc2VkID0gdHJ1ZTtcbiAgdHJ5e1xuICAgIGF0b2IoZGF0YSk7XG4gIH1jYXRjaChlKXtcbiAgICBwYXNzZWQgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gcGFzc2VkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RXF1YWxQb3dlckN1cnZlKG51bVN0ZXBzLCB0eXBlLCBtYXhWYWx1ZSkge1xuICBsZXQgaSwgdmFsdWUsIHBlcmNlbnQsXG4gICAgdmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheShudW1TdGVwcylcblxuICBmb3IoaSA9IDA7IGkgPCBudW1TdGVwczsgaSsrKXtcbiAgICBwZXJjZW50ID0gaSAvIG51bVN0ZXBzXG4gICAgaWYodHlwZSA9PT0gJ2ZhZGVJbicpe1xuICAgICAgdmFsdWUgPSBNYXRoLmNvcygoMS4wIC0gcGVyY2VudCkgKiAwLjUgKiBtUEkpICogbWF4VmFsdWVcbiAgICB9ZWxzZSBpZih0eXBlID09PSAnZmFkZU91dCcpe1xuICAgICAgdmFsdWUgPSBNYXRoLmNvcyhwZXJjZW50ICogMC41ICogTWF0aC5QSSkgKiBtYXhWYWx1ZVxuICAgIH1cbiAgICB2YWx1ZXNbaV0gPSB2YWx1ZVxuICAgIGlmKGkgPT09IG51bVN0ZXBzIC0gMSl7XG4gICAgICB2YWx1ZXNbaV0gPSB0eXBlID09PSAnZmFkZUluJyA/IDEgOiAwXG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZXNcbn1cblxuXG5cbi8qXG4vL29sZCBzY2hvb2wgYWpheFxuXG5leHBvcnQgZnVuY3Rpb24gYWpheChjb25maWcpe1xuICBsZXRcbiAgICByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCksXG4gICAgbWV0aG9kID0gdHlwZW9mIGNvbmZpZy5tZXRob2QgPT09ICd1bmRlZmluZWQnID8gJ0dFVCcgOiBjb25maWcubWV0aG9kLFxuICAgIGZpbGVTaXplO1xuXG4gIGZ1bmN0aW9uIGV4ZWN1dG9yKHJlc29sdmUsIHJlamVjdCl7XG5cbiAgICByZWplY3QgPSByZWplY3QgfHwgZnVuY3Rpb24oKXt9O1xuICAgIHJlc29sdmUgPSByZXNvbHZlIHx8IGZ1bmN0aW9uKCl7fTtcblxuICAgIHJlcXVlc3Qub25sb2FkID0gZnVuY3Rpb24oKXtcbiAgICAgIGlmKHJlcXVlc3Quc3RhdHVzICE9PSAyMDApe1xuICAgICAgICByZWplY3QocmVxdWVzdC5zdGF0dXMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmKGNvbmZpZy5yZXNwb25zZVR5cGUgPT09ICdqc29uJyl7XG4gICAgICAgIGZpbGVTaXplID0gcmVxdWVzdC5yZXNwb25zZS5sZW5ndGg7XG4gICAgICAgIHJlc29sdmUoSlNPTi5wYXJzZShyZXF1ZXN0LnJlc3BvbnNlKSwgZmlsZVNpemUpO1xuICAgICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICAgIH1lbHNle1xuICAgICAgICByZXNvbHZlKHJlcXVlc3QucmVzcG9uc2UpO1xuICAgICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24oZSl7XG4gICAgICBjb25maWcub25FcnJvcihlKTtcbiAgICB9O1xuXG4gICAgcmVxdWVzdC5vcGVuKG1ldGhvZCwgY29uZmlnLnVybCwgdHJ1ZSk7XG5cbiAgICBpZihjb25maWcub3ZlcnJpZGVNaW1lVHlwZSl7XG4gICAgICByZXF1ZXN0Lm92ZXJyaWRlTWltZVR5cGUoY29uZmlnLm92ZXJyaWRlTWltZVR5cGUpO1xuICAgIH1cblxuICAgIGlmKGNvbmZpZy5yZXNwb25zZVR5cGUpe1xuICAgICAgaWYoY29uZmlnLnJlc3BvbnNlVHlwZSA9PT0gJ2pzb24nKXtcbiAgICAgICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSAndGV4dCc7XG4gICAgICB9ZWxzZXtcbiAgICAgICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSBjb25maWcucmVzcG9uc2VUeXBlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmKG1ldGhvZCA9PT0gJ1BPU1QnKSB7XG4gICAgICByZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtdHlwZScsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnKTtcbiAgICB9XG5cbiAgICBpZihjb25maWcuZGF0YSl7XG4gICAgICByZXF1ZXN0LnNlbmQoY29uZmlnLmRhdGEpO1xuICAgIH1lbHNle1xuICAgICAgcmVxdWVzdC5zZW5kKCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKGV4ZWN1dG9yKTtcbn1cbiovIl19
